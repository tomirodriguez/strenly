---
description: Create a professional commit following Conventional Commits
allowed-tools:
  - Bash(git add:*)
  - Bash(git status:*)
  - Bash(git diff:*)
  - Bash(git log:*)
  - Bash(git commit:*)
  - Read
  - Glob
  - Grep
---

<objective>
Create a git commit following Conventional Commits specification by analyzing actual changes.

This ensures consistent, professional commit messages that describe the purpose of changes clearly.
</objective>

<context>
Current status: !git status
Staged changes: !git diff --staged --stat
Unstaged changes: !git diff --stat
Recent commits: !git log --oneline -5
</context>

<process>
1. Analyze changes from context above to understand what was modified
2. Determine commit type based on changes:
   - `feat`: New feature or capability
   - `fix`: Bug fix
   - `refactor`: Code restructuring without behavior change
   - `docs`: Documentation only
   - `test`: Adding or updating tests
   - `chore`: Maintenance tasks, dependencies
   - `style`: Formatting, whitespace (no logic change)
   - `perf`: Performance improvement
3. Identify scope from the primary area affected (e.g., `auth`, `api`, `ui`, `core`)
4. Write commit message:
   - Subject: `type(scope): concise description` (max 72 chars, imperative mood)
   - Body (if needed): Explain **why**, not what (the diff shows what)
5. Stage relevant files with `git add`
6. Create commit with the message
7. Show the result with `git log -1`
</process>

<success_criteria>
- Commit type accurately reflects the nature of changes
- Scope identifies the affected area
- Subject is concise (â‰¤72 chars) and uses imperative mood
- Commit created successfully
</success_criteria>

<verification>
Run `git log -1 --format="%s%n%n%b"` to verify commit message format.
</verification>

<rules>
- NEVER add "Co-Authored-By", "Generated by", or any AI attribution
- NEVER include obvious information the diff already shows
- Use imperative mood: "add feature" not "added feature"
- Be specific: "fix null check in auth middleware" not "fix bug"
- Group related changes into one commit when they serve one purpose
</rules>
