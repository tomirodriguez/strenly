# Domain Entity Full Example

Complete implementation of a User domain entity with validation and query helpers.

```typescript
// src/core/domain/entities/user.ts
import { err, ok, type Result } from 'neverthrow'
import { type DomainError, validationError } from '@/core/errors'

const ENTITY = 'user'

// ============================================================
// TYPES
// ============================================================

export type UserRole = 'admin' | 'member' | 'viewer'

export type User = {
  readonly id: string
  readonly organizationId: string
  readonly name: string
  readonly email: string
  readonly role: UserRole
  readonly createdAt: Date
  readonly updatedAt: Date
}

// Input type - ID comes from use case (via generateId dependency)
export type CreateUserInput = {
  id: string                    // Generated by use case, not by domain
  organizationId: string
  name: string
  email: string
  role?: UserRole
}

// ============================================================
// VALIDATION FUNCTIONS (private)
// ============================================================

const validateName = (name: string): Result<string, DomainError> => {
  const trimmed = name.trim()
  if (trimmed.length === 0) {
    return err(validationError(ENTITY, 'name', 'Name is required'))
  }
  if (trimmed.length > 100) {
    return err(validationError(ENTITY, 'name', 'Name cannot exceed 100 characters'))
  }
  return ok(trimmed)
}

const validateEmail = (email: string): Result<string, DomainError> => {
  const trimmed = email.trim().toLowerCase()
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(trimmed)) {
    return err(validationError(ENTITY, 'email', 'Invalid email format'))
  }
  return ok(trimmed)
}

// ============================================================
// FACTORY FUNCTION
// ============================================================

/**
 * Creates a validated User entity.
 *
 * The ID is provided by the use case (via generateId dependency).
 * This function validates all business rules before returning the entity.
 */
export const createUser = (input: CreateUserInput): Result<User, DomainError> => {
  const nameResult = validateName(input.name)
  if (nameResult.isErr()) return err(nameResult.error)

  const emailResult = validateEmail(input.email)
  if (emailResult.isErr()) return err(emailResult.error)

  const now = new Date()

  return ok({
    id: input.id,
    organizationId: input.organizationId,
    name: nameResult.value,
    email: emailResult.value,
    role: input.role ?? 'member',
    createdAt: now,
    updatedAt: now,
  })
}

// ============================================================
// QUERY HELPERS (use Pick<> to only require needed fields)
// ============================================================

export type UserRoleData = Pick<User, 'role'>

export const isAdmin = (user: UserRoleData): boolean => {
  return user.role === 'admin'
}

export const canManageMembers = (user: UserRoleData): boolean => {
  return user.role === 'admin' || user.role === 'owner'
}
```

## State Machine Pattern

For entities with state transitions:

```typescript
// Types for state
export type SubscriptionStatus = 'active' | 'cancelled'
export type SubscriptionState = 'trial' | 'active' | 'expired' | 'cancelled'

// Data type for state queries
export type SubscriptionStatusData = Pick<Subscription, 'status' | 'trialEndsAt' | 'currentPeriodEnd'>

// State query - derives state from data, receives `now` as parameter
export const getSubscriptionState = (
  subscription: SubscriptionStatusData,
  now: Date = new Date(),
): SubscriptionState => {
  if (subscription.status === 'cancelled') return 'cancelled'
  if (isInTrial(subscription, now)) return 'trial'
  if (isActive(subscription, now)) return 'active'
  return 'expired'
}

// Mutation helpers - return new immutable instance
export const cancelSubscription = (subscription: Subscription): Subscription => ({
  ...subscription,
  status: 'cancelled',
  updatedAt: new Date(),
})
```
