---
phase: 04-coach-workout-logging
plan: 06
type: execute
wave: 3
depends_on: ["04-03", "04-04", "04-05"]
files_modified:
  - packages/contracts/src/workout-logs/workout-log.ts
  - packages/contracts/src/workout-logs/create-log.ts
  - packages/contracts/src/workout-logs/save-log.ts
  - packages/contracts/src/workout-logs/list-logs.ts
  - packages/backend/src/procedures/workout-logs/router.ts
  - packages/backend/src/procedures/router.ts
autonomous: true

must_haves:
  truths:
    - "Contracts define Zod schemas for all workout log API operations"
    - "Procedures expose all use cases via oRPC router"
    - "Procedure returns full aggregate for client rendering"
  artifacts:
    - path: "packages/contracts/src/workout-logs/workout-log.ts"
      provides: "WorkoutLog Zod schemas"
      exports: ["workoutLogSchema", "loggedExerciseSchema", "loggedSeriesSchema"]
    - path: "packages/backend/src/procedures/workout-logs/router.ts"
      provides: "workoutLogs oRPC router"
      exports: ["workoutLogsRouter"]
  key_links:
    - from: "packages/backend/src/procedures/workout-logs/router.ts"
      to: "use cases"
      via: "procedure handlers"
      pattern: "createLog|saveLog|getLog|listAthleteLogs"
    - from: "packages/backend/src/procedures/router.ts"
      to: "workout-logs router"
      via: "router composition"
      pattern: "workoutLogs"
---

<objective>
Create API contracts (Zod schemas) and oRPC procedures for workout logging.

Purpose: Contracts define the API boundary, procedures expose use cases as HTTP endpoints. This enables frontend to call workout log operations via oRPC client.

Output: Complete API layer with contracts and procedures for all workout log operations.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-coach-workout-logging/04-RESEARCH.md

# From prior plans
@packages/backend/src/use-cases/workout-logs/create-log.ts
@packages/backend/src/use-cases/workout-logs/save-log.ts

# Reference: Existing contracts and procedures
@packages/contracts/src/programs/program.ts
@packages/backend/src/procedures/programs/router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Workout Log Contracts</name>
  <skills>/contracts</skills>
  <files>
    packages/contracts/src/workout-logs/workout-log.ts
    packages/contracts/src/workout-logs/create-log.ts
    packages/contracts/src/workout-logs/save-log.ts
    packages/contracts/src/workout-logs/list-logs.ts
  </files>
  <action>
Create Zod schemas for workout log API operations:

**workout-log.ts:**
```typescript
import { z } from 'zod'

// LoggedSeries schema
export const loggedSeriesSchema = z.object({
  orderIndex: z.number().int().min(0),
  repsPerformed: z.number().int().min(0).nullable(),
  weightUsed: z.number().min(0).nullable(),
  rpe: z.number().min(1).max(10).nullable(),
  skipped: z.boolean(),
  prescribedReps: z.number().int().nullable(),
  prescribedWeight: z.number().nullable(),
})

export type LoggedSeriesInput = z.infer<typeof loggedSeriesSchema>

// LoggedExercise schema
export const loggedExerciseSchema = z.object({
  id: z.string().min(1),
  exerciseId: z.string().min(1),
  groupItemId: z.string().min(1),
  orderIndex: z.number().int().min(0),
  notes: z.string().nullable(),
  skipped: z.boolean(),
  series: z.array(loggedSeriesSchema),
})

export type LoggedExerciseInput = z.infer<typeof loggedExerciseSchema>

// WorkoutLog aggregate schema (for output)
export const workoutLogAggregateSchema = z.object({
  id: z.string(),
  organizationId: z.string(),
  athleteId: z.string(),
  programId: z.string(),
  sessionId: z.string(),
  weekId: z.string(),
  logDate: z.coerce.date(),
  status: z.enum(['completed', 'partial', 'skipped']),
  sessionRpe: z.number().min(1).max(10).nullable(),
  sessionNotes: z.string().nullable(),
  exercises: z.array(loggedExerciseSchema),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
})

export type WorkoutLogAggregate = z.infer<typeof workoutLogAggregateSchema>
```

**create-log.ts:**
```typescript
import { z } from 'zod'
import { workoutLogAggregateSchema } from './workout-log'

export const createLogInputSchema = z.object({
  athleteId: z.string().min(1),
  programId: z.string().min(1),
  sessionId: z.string().min(1),
  weekId: z.string().min(1),
  logDate: z.coerce.date().optional(),
})

export type CreateLogInput = z.infer<typeof createLogInputSchema>

export const createLogOutputSchema = workoutLogAggregateSchema
```

**save-log.ts:**
```typescript
import { z } from 'zod'
import { loggedExerciseSchema, workoutLogAggregateSchema } from './workout-log'

export const saveLogInputSchema = z.object({
  id: z.string().min(1),
  athleteId: z.string().min(1),
  programId: z.string().min(1),
  sessionId: z.string().min(1),
  weekId: z.string().min(1),
  logDate: z.coerce.date(),
  sessionRpe: z.number().min(1).max(10).nullable(),
  sessionNotes: z.string().nullable(),
  exercises: z.array(loggedExerciseSchema),
})

export type SaveLogInput = z.infer<typeof saveLogInputSchema>

export const saveLogOutputSchema = workoutLogAggregateSchema
```

**list-logs.ts:**
```typescript
import { z } from 'zod'
import { workoutLogAggregateSchema } from './workout-log'

export const listAthleteLogsInputSchema = z.object({
  athleteId: z.string().min(1),
  status: z.enum(['completed', 'partial', 'skipped']).optional(),
  fromDate: z.coerce.date().optional(),
  toDate: z.coerce.date().optional(),
  limit: z.number().int().min(1).max(100).optional(),
  offset: z.number().int().min(0).optional(),
})

export type ListAthleteLogsInput = z.infer<typeof listAthleteLogsInputSchema>

export const listAthleteLogsOutputSchema = z.object({
  items: z.array(workoutLogAggregateSchema),
  totalCount: z.number().int(),
})

// Pending workouts schema
export const pendingWorkoutSchema = z.object({
  athleteId: z.string(),
  athleteName: z.string(),
  programId: z.string(),
  programName: z.string(),
  sessionId: z.string(),
  sessionName: z.string(),
  weekId: z.string(),
  weekName: z.string(),
})

export const listPendingWorkoutsInputSchema = z.object({
  limit: z.number().int().min(1).max(100).optional(),
  offset: z.number().int().min(0).optional(),
})

export const listPendingWorkoutsOutputSchema = z.object({
  items: z.array(pendingWorkoutSchema),
  totalCount: z.number().int(),
})
```

Update packages/contracts/package.json exports if needed.
  </action>
  <verify>
    `pnpm typecheck` passes in contracts package
    Schemas can be imported in backend
  </verify>
  <done>
    All workout log Zod schemas defined
    Types exported for use by frontend and backend
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Workout Logs Procedures</name>
  <skills>/procedure</skills>
  <files>
    packages/backend/src/procedures/workout-logs/router.ts
    packages/backend/src/procedures/router.ts
  </files>
  <action>
Create the oRPC procedures for workout logs:

**router.ts:**
```typescript
import { orpc } from '@strenly/orpc'
import { organizationProcedure } from '../base'
import {
  createLogInputSchema,
  createLogOutputSchema,
} from '@strenly/contracts/workout-logs/create-log'
import {
  saveLogInputSchema,
  saveLogOutputSchema,
} from '@strenly/contracts/workout-logs/save-log'
import {
  listAthleteLogsInputSchema,
  listAthleteLogsOutputSchema,
  listPendingWorkoutsInputSchema,
  listPendingWorkoutsOutputSchema,
} from '@strenly/contracts/workout-logs/list-logs'
import { workoutLogAggregateSchema } from '@strenly/contracts/workout-logs/workout-log'
import { z } from 'zod'

import { createLog } from '../../use-cases/workout-logs/create-log'
import { saveLog } from '../../use-cases/workout-logs/save-log'
import { getLog } from '../../use-cases/workout-logs/get-log'
import { listAthleteLogs } from '../../use-cases/workout-logs/list-athlete-logs'
import { listPendingWorkouts } from '../../use-cases/workout-logs/list-pending-workouts'
import { deleteLog } from '../../use-cases/workout-logs/delete-log'

export const workoutLogsRouter = orpc.router({
  // Initialize a new log from program prescription (returns pre-filled, doesn't save)
  create: organizationProcedure
    .input(createLogInputSchema)
    .output(createLogOutputSchema)
    .mutation(async ({ input, context }) => {
      const result = await createLog(context, input, {
        programRepository: context.repos.program,
        workoutLogRepository: context.repos.workoutLog,
      })

      if (result.isErr()) {
        throw new Error(result.error.message)
      }

      return result.value
    }),

  // Save (persist) a workout log
  save: organizationProcedure
    .input(saveLogInputSchema)
    .output(saveLogOutputSchema)
    .mutation(async ({ input, context }) => {
      const result = await saveLog(context, input, {
        workoutLogRepository: context.repos.workoutLog,
      })

      if (result.isErr()) {
        throw new Error(result.error.message)
      }

      return result.value
    }),

  // Get a single log by ID
  get: organizationProcedure
    .input(z.object({ logId: z.string() }))
    .output(workoutLogAggregateSchema)
    .query(async ({ input, context }) => {
      const result = await getLog(context, input.logId, {
        workoutLogRepository: context.repos.workoutLog,
      })

      if (result.isErr()) {
        throw new Error(result.error.message)
      }

      return result.value
    }),

  // List logs for an athlete (history view)
  listByAthlete: organizationProcedure
    .input(listAthleteLogsInputSchema)
    .output(listAthleteLogsOutputSchema)
    .query(async ({ input, context }) => {
      const result = await listAthleteLogs(context, input, {
        workoutLogRepository: context.repos.workoutLog,
      })

      if (result.isErr()) {
        throw new Error(result.error.message)
      }

      return result.value
    }),

  // List pending workouts (dashboard view)
  listPending: organizationProcedure
    .input(listPendingWorkoutsInputSchema)
    .output(listPendingWorkoutsOutputSchema)
    .query(async ({ input, context }) => {
      const result = await listPendingWorkouts(context, input, {
        workoutLogRepository: context.repos.workoutLog,
      })

      if (result.isErr()) {
        throw new Error(result.error.message)
      }

      return result.value
    }),

  // Delete a log
  delete: organizationProcedure
    .input(z.object({ logId: z.string() }))
    .output(z.void())
    .mutation(async ({ input, context }) => {
      const result = await deleteLog(context, input.logId, {
        workoutLogRepository: context.repos.workoutLog,
      })

      if (result.isErr()) {
        throw new Error(result.error.message)
      }
    }),
})
```

**Update router.ts:**
Add workoutLogsRouter to the main router:
```typescript
import { workoutLogsRouter } from './workout-logs/router'

export const router = orpc.router({
  // ... existing routers
  workoutLogs: workoutLogsRouter,
})
```

Also add workoutLog repository to the context repos object in the procedure base.
  </action>
  <verify>
    `pnpm typecheck` passes
    Router exports workoutLogsRouter
    Main router includes workoutLogs
  </verify>
  <done>
    All workout log procedures created
    Router integrated with main app router
    Procedures call use cases with proper context
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compiles
pnpm typecheck

# Verify router exports
grep "workoutLogs" packages/backend/src/procedures/router.ts
```
</verification>

<success_criteria>
1. Contracts define Zod schemas for all workout log operations
2. Procedures expose create, save, get, listByAthlete, listPending, delete
3. workoutLogsRouter integrated with main router
4. All procedures use organizationProcedure for auth context
5. Procedures return full aggregate schema for client rendering
</success_criteria>

<output>
After completion, create `.planning/phases/04-coach-workout-logging/04-06-SUMMARY.md`
</output>
