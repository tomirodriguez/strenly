---
phase: 04-coach-workout-logging
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - packages/backend/src/use-cases/workout-logs/create-log.ts
  - packages/backend/src/use-cases/workout-logs/save-log.ts
  - packages/backend/src/use-cases/workout-logs/get-log.ts
autonomous: true

must_haves:
  truths:
    - "createLog initializes log from program prescription with pre-filled values"
    - "saveLog validates via domain factory and persists full aggregate"
    - "getLog returns existing log or null"
    - "All use cases check authorization before business logic"
  artifacts:
    - path: "packages/backend/src/use-cases/workout-logs/create-log.ts"
      provides: "createLog use case"
      exports: ["createLog"]
    - path: "packages/backend/src/use-cases/workout-logs/save-log.ts"
      provides: "saveLog use case"
      exports: ["saveLog"]
    - path: "packages/backend/src/use-cases/workout-logs/get-log.ts"
      provides: "getLog use case"
      exports: ["getLog"]
  key_links:
    - from: "packages/backend/src/use-cases/workout-logs/create-log.ts"
      to: "program repository"
      via: "load program aggregate"
      pattern: "loadProgramAggregate"
    - from: "packages/backend/src/use-cases/workout-logs/save-log.ts"
      to: "workout log repository"
      via: "save aggregate"
      pattern: "repository\\.save"
---

<objective>
Implement core use cases for creating, saving, and retrieving workout logs.

Purpose: Use cases orchestrate business logic - authorization, domain validation, and repository calls. createLog is particularly important as it pre-fills logged values from program prescriptions.

Output: Three use cases that handle the main logging operations, following neverthrow pattern.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-coach-workout-logging/04-RESEARCH.md

# From prior plans
@packages/core/src/domain/entities/workout-log/types.ts
@packages/core/src/ports/workout-log-repository.port.ts

# Reference: Existing use case patterns
@packages/backend/src/use-cases/programs/save-draft.ts
@packages/backend/src/use-cases/programs/get-program.ts
@packages/core/src/services/authorization.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create createLog Use Case</name>
  <skills>/use-case, /authorization</skills>
  <files>packages/backend/src/use-cases/workout-logs/create-log.ts</files>
  <action>
Create the createLog use case that initializes a workout log from program prescriptions:

```typescript
import { ResultAsync, errAsync, okAsync } from 'neverthrow'
import type { WorkoutLog } from '@strenly/core/domain/entities/workout-log/types'
import { createWorkoutLog } from '@strenly/core/domain/entities/workout-log/workout-log'
import { hasPermission } from '@strenly/core/services/authorization'
import type { WorkoutLogRepository } from '@strenly/core/ports/workout-log-repository.port'
import type { ProgramRepositoryPort } from '@strenly/core/ports/program-repository.port'
import type { OrganizationContext } from '@strenly/core/types/organization-context'

type CreateLogInput = {
  athleteId: string
  programId: string
  sessionId: string
  weekId: string
  logDate?: Date  // Defaults to now
}

type CreateLogError =
  | { type: 'unauthorized'; message: string }
  | { type: 'program_not_found'; message: string }
  | { type: 'session_not_found'; message: string }
  | { type: 'log_already_exists'; message: string }
  | { type: 'validation_error'; message: string }
  | { type: 'repository_error'; message: string }

type CreateLogDeps = {
  programRepository: ProgramRepositoryPort
  workoutLogRepository: WorkoutLogRepository
}

export function createLog(
  ctx: OrganizationContext,
  input: CreateLogInput,
  deps: CreateLogDeps
): ResultAsync<WorkoutLog, CreateLogError> {
  // 1. Check authorization
  if (!hasPermission(ctx.role, 'workout_log:create')) {
    return errAsync({ type: 'unauthorized', message: 'Cannot create workout logs' })
  }

  // 2. Check if log already exists for this session/week
  return deps.workoutLogRepository
    .findByAthleteSessionWeek(ctx, input.athleteId, input.sessionId, input.weekId)
    .mapErr((e) => ({ type: 'repository_error' as const, message: e.message }))
    .andThen((existing) => {
      if (existing) {
        return errAsync({ type: 'log_already_exists' as const, message: 'Log already exists for this session and week' })
      }
      return okAsync(undefined)
    })
    // 3. Load program aggregate to get prescription data
    .andThen(() =>
      deps.programRepository
        .loadProgramAggregate(ctx, input.programId)
        .mapErr((e) => ({ type: 'program_not_found' as const, message: e.message ?? 'Program not found' }))
    )
    // 4. Extract session and pre-fill exercises from prescription
    .andThen((program) => {
      const week = program.weeks.find((w) => w.id === input.weekId)
      if (!week) {
        return errAsync({ type: 'session_not_found' as const, message: 'Week not found in program' })
      }

      const session = week.sessions.find((s) => s.id === input.sessionId)
      if (!session) {
        return errAsync({ type: 'session_not_found' as const, message: 'Session not found in program' })
      }

      // Build LoggedExercise array from session groups/items
      const exercises = []
      for (const group of session.exerciseGroups) {
        for (const item of group.items) {
          exercises.push({
            id: `lex-${crypto.randomUUID()}`,
            exerciseId: item.exerciseId,
            groupItemId: item.id,
            orderIndex: exercises.length,
            notes: null,
            skipped: false,
            series: item.series.map((s, idx) => ({
              orderIndex: idx,
              // Pre-fill actual with prescribed values
              repsPerformed: s.reps,
              weightUsed: s.intensityType === 'absolute' ? s.intensityValue : null,
              rpe: null,  // Never pre-fill - athlete-specific
              skipped: false,
              // Snapshot prescribed values for deviation display
              prescribedReps: s.reps,
              prescribedWeight: s.intensityType === 'absolute' ? s.intensityValue : null,
            })),
          })
        }
      }

      // 5. Create domain entity (validates)
      const logResult = createWorkoutLog({
        id: `log-${crypto.randomUUID()}`,
        organizationId: ctx.organizationId,
        athleteId: input.athleteId,
        programId: input.programId,
        sessionId: input.sessionId,
        weekId: input.weekId,
        logDate: input.logDate ?? new Date(),
        status: 'partial',  // New logs start as partial
        sessionRpe: null,
        sessionNotes: null,
        exercises,
      })

      if (logResult.isErr()) {
        return errAsync({ type: 'validation_error' as const, message: logResult.error.message })
      }

      return okAsync(logResult.value)
    })
    // 6. Note: We do NOT save here - client will call saveLog after editing
    // This just returns the pre-filled log for client-side editing
}
```

Key points:
- Does NOT persist - returns pre-filled log for client-side editing
- Pre-fills repsPerformed/weightUsed from prescription
- Never pre-fills RPE (athlete-specific)
- Snapshots prescribed values for deviation display later
  </action>
  <verify>
    `pnpm typecheck` passes
    Function exports createLog
  </verify>
  <done>
    createLog use case initializes log from program prescription
    Pre-fills actual values with prescribed values
    Snapshots prescription for deviation display
  </done>
</task>

<task type="auto">
  <name>Task 2: Create saveLog and getLog Use Cases</name>
  <skills>/use-case, /authorization</skills>
  <files>
    packages/backend/src/use-cases/workout-logs/save-log.ts
    packages/backend/src/use-cases/workout-logs/get-log.ts
  </files>
  <action>
**save-log.ts:**
```typescript
import { ResultAsync, errAsync, okAsync } from 'neverthrow'
import type { WorkoutLog, CreateWorkoutLogInput } from '@strenly/core/domain/entities/workout-log/types'
import { createWorkoutLog } from '@strenly/core/domain/entities/workout-log/workout-log'
import { hasPermission } from '@strenly/core/services/authorization'
import type { WorkoutLogRepository } from '@strenly/core/ports/workout-log-repository.port'
import type { OrganizationContext } from '@strenly/core/types/organization-context'

type SaveLogError =
  | { type: 'unauthorized'; message: string }
  | { type: 'validation_error'; message: string }
  | { type: 'repository_error'; message: string }

type SaveLogDeps = {
  workoutLogRepository: WorkoutLogRepository
}

export function saveLog(
  ctx: OrganizationContext,
  input: CreateWorkoutLogInput,
  deps: SaveLogDeps
): ResultAsync<WorkoutLog, SaveLogError> {
  // 1. Check authorization
  if (!hasPermission(ctx.role, 'workout_log:update')) {
    return errAsync({ type: 'unauthorized', message: 'Cannot save workout logs' })
  }

  // 2. Validate via domain factory
  const logResult = createWorkoutLog({
    ...input,
    organizationId: ctx.organizationId,
    updatedAt: new Date(),
  })

  if (logResult.isErr()) {
    return errAsync({ type: 'validation_error', message: logResult.error.message })
  }

  const log = logResult.value

  // 3. Calculate status based on exercises
  const allCompleted = log.exercises.length > 0 &&
    log.exercises.every((e) => !e.skipped && e.series.every((s) => !s.skipped))
  const allSkipped = log.exercises.length > 0 &&
    log.exercises.every((e) => e.skipped)

  const status = allSkipped ? 'skipped' : allCompleted ? 'completed' : 'partial'

  // Update status in the log
  const logWithStatus = { ...log, status }

  // 4. Persist
  return deps.workoutLogRepository
    .save(ctx, logWithStatus)
    .map(() => logWithStatus)
    .mapErr((e) => ({ type: 'repository_error' as const, message: e.message }))
}
```

**get-log.ts:**
```typescript
import { ResultAsync, errAsync } from 'neverthrow'
import type { WorkoutLog } from '@strenly/core/domain/entities/workout-log/types'
import { hasPermission } from '@strenly/core/services/authorization'
import type { WorkoutLogRepository } from '@strenly/core/ports/workout-log-repository.port'
import type { OrganizationContext } from '@strenly/core/types/organization-context'

type GetLogError =
  | { type: 'unauthorized'; message: string }
  | { type: 'not_found'; message: string }
  | { type: 'repository_error'; message: string }

type GetLogDeps = {
  workoutLogRepository: WorkoutLogRepository
}

export function getLog(
  ctx: OrganizationContext,
  logId: string,
  deps: GetLogDeps
): ResultAsync<WorkoutLog, GetLogError> {
  // 1. Check authorization
  if (!hasPermission(ctx.role, 'workout_log:read')) {
    return errAsync({ type: 'unauthorized', message: 'Cannot read workout logs' })
  }

  // 2. Load from repository
  return deps.workoutLogRepository
    .findById(ctx, logId)
    .mapErr((e) => ({ type: 'repository_error' as const, message: e.message }))
    .andThen((log) => {
      if (!log) {
        return errAsync({ type: 'not_found' as const, message: 'Workout log not found' })
      }
      return okAsync(log)
    })
}
```
  </action>
  <verify>
    `pnpm typecheck` passes
    Both files export their use case functions
  </verify>
  <done>
    saveLog validates via domain factory and persists
    getLog loads log by ID with authorization
    Status calculated automatically from exercise states
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compiles
pnpm typecheck

# Verify exports
grep "export function" packages/backend/src/use-cases/workout-logs/*.ts
```
</verification>

<success_criteria>
1. createLog loads program and pre-fills from prescription
2. createLog snapshots prescribed values for deviation display
3. saveLog validates via createWorkoutLog and persists
4. saveLog auto-calculates status (completed/partial/skipped)
5. getLog returns log by ID with authorization check
6. All use cases check permissions before business logic
</success_criteria>

<output>
After completion, create `.planning/phases/04-coach-workout-logging/04-04-SUMMARY.md`
</output>
