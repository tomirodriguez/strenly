---
phase: 04-coach-workout-logging
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - packages/backend/src/infrastructure/repositories/workout-log.repository.ts
autonomous: true

must_haves:
  truths:
    - "Repository saves workout log aggregate atomically (DELETE + INSERT)"
    - "Repository loads workout log with all exercises and series"
    - "All queries filter by organizationId for multi-tenancy"
    - "listPendingWorkouts returns sessions without logs for dashboard"
  artifacts:
    - path: "packages/backend/src/infrastructure/repositories/workout-log.repository.ts"
      provides: "WorkoutLogRepository implementation"
      exports: ["createWorkoutLogRepository"]
      min_lines: 200
  key_links:
    - from: "packages/backend/src/infrastructure/repositories/workout-log.repository.ts"
      to: "WorkoutLogRepository port"
      via: "implements interface"
      pattern: "WorkoutLogRepository"
    - from: "packages/backend/src/infrastructure/repositories/workout-log.repository.ts"
      to: "database schema"
      via: "drizzle queries"
      pattern: "workoutLogs|loggedExercises"
---

<objective>
Implement the WorkoutLogRepository that persists workout logs to the database.

Purpose: Provides the data access layer for workout logs following the aggregate pattern established in Phase 3.4. Uses DELETE + INSERT for save operations to match the program aggregate approach.

Output: Complete repository implementation with all CRUD operations, complex queries for pending workouts dashboard, and proper multi-tenancy filtering.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-coach-workout-logging/04-RESEARCH.md

# From Plan 01 and 02
@packages/core/src/ports/workout-log-repository.port.ts
@packages/database/src/schema/workout-logs.ts
@packages/database/src/schema/logged-exercises.ts

# Reference: Existing repository pattern
@packages/backend/src/infrastructure/repositories/program.repository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WorkoutLogRepository</name>
  <skills>/repository</skills>
  <files>packages/backend/src/infrastructure/repositories/workout-log.repository.ts</files>
  <action>
Implement the WorkoutLogRepository following the aggregate pattern:

**Structure:**
```typescript
import { eq, and, desc, sql, isNull } from 'drizzle-orm'
import { ResultAsync, errAsync, okAsync } from 'neverthrow'
import type { Database } from '@strenly/database'
import { workoutLogs, loggedExercises } from '@strenly/database/schema'
import { reconstituteWorkoutLog } from '@strenly/core/domain/entities/workout-log/workout-log'
import type { WorkoutLog } from '@strenly/core/domain/entities/workout-log/types'
import type {
  WorkoutLogRepository,
  WorkoutLogRepositoryError,
  WorkoutLogFilters
} from '@strenly/core/ports/workout-log-repository.port'
import type { OrganizationContext } from '@strenly/core/types/organization-context'

export function createWorkoutLogRepository(db: Database): WorkoutLogRepository {
  return {
    save(ctx, log) { ... },
    findById(ctx, logId) { ... },
    findByAthleteSessionWeek(ctx, athleteId, sessionId, weekId) { ... },
    listByAthlete(ctx, athleteId, filters) { ... },
    listPendingWorkouts(ctx, filters) { ... },
    delete(ctx, logId) { ... },
  }
}
```

**save(ctx, log):**
- Use transaction for atomicity
- DELETE existing logged_exercises for this log
- DELETE existing workout_log record
- INSERT new workout_log record
- INSERT all logged_exercises with series as JSONB
- Map domain types to DB columns (add log- prefix to ID if missing)

**findById(ctx, logId):**
- Query workout_logs with organizationId filter
- Query logged_exercises for this log
- Map DB rows to domain types
- Use reconstituteWorkoutLog() to create aggregate
- Return null if not found (not error)

**findByAthleteSessionWeek(ctx, athleteId, sessionId, weekId):**
- Query workout_logs with all three conditions + organizationId
- Load exercises if found
- Used to check existence before creating new log

**listByAthlete(ctx, athleteId, filters):**
- Query with optional filters (status, date range)
- Order by logDate DESC (most recent first)
- Apply pagination (limit, offset)
- Return totalCount for pagination UI
- Load exercises for each log (consider N+1 - batch if needed)

**listPendingWorkouts(ctx, filters):**
This is a complex query that finds sessions without logs. Implementation:
1. Get all active programs with athletes assigned
2. For each program, get sessions from first week as canonical structure
3. LEFT JOIN to workout_logs to find which are missing
4. Return athlete name, program name, session name, week info

SQL pattern:
```sql
SELECT DISTINCT
  a.id as athlete_id, a.name as athlete_name,
  p.id as program_id, p.name as program_name,
  ps.id as session_id, ps.name as session_name,
  pw.id as week_id, pw.name as week_name
FROM programs p
JOIN athletes a ON p.athlete_id = a.id
JOIN program_weeks pw ON pw.program_id = p.id
JOIN program_sessions ps ON ps.program_id = p.id
LEFT JOIN workout_logs wl ON
  wl.athlete_id = a.id AND
  wl.session_id = ps.id AND
  wl.week_id = pw.id
WHERE p.organization_id = $1
  AND p.status = 'active'
  AND p.athlete_id IS NOT NULL
  AND wl.id IS NULL
ORDER BY a.name, p.name, pw.order_index, ps.order_index
LIMIT $2 OFFSET $3
```

**delete(ctx, logId):**
- Verify log exists and belongs to organization
- DELETE from workout_logs (cascade handles logged_exercises)
- Return NOT_FOUND if doesn't exist

**Error handling:**
- Wrap all DB operations in try/catch
- Map constraint violations to CONFLICT error
- Map other errors to DATABASE_ERROR
  </action>
  <verify>
    `pnpm typecheck` passes
    Repository exports createWorkoutLogRepository function
  </verify>
  <done>
    WorkoutLogRepository implementation complete
    All methods filter by organizationId
    save() uses atomic DELETE + INSERT
    listPendingWorkouts() returns unlogged sessions for dashboard
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Repository Factory</name>
  <skills>/repository</skills>
  <files>packages/backend/src/infrastructure/repositories/index.ts</files>
  <action>
Export the repository factory from the repositories index:

If packages/backend/src/infrastructure/repositories/index.ts exists:
- Add export for createWorkoutLogRepository

If it doesn't exist, repositories are imported directly - skip this step.

Verify the repository can be imported in use cases.
  </action>
  <verify>
    Repository can be imported: `import { createWorkoutLogRepository } from './infrastructure/repositories/workout-log.repository'`
  </verify>
  <done>
    Repository factory is accessible for use case injection
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compiles
pnpm typecheck

# Verify implementation
grep "createWorkoutLogRepository" packages/backend/src/infrastructure/repositories/workout-log.repository.ts
```
</verification>

<success_criteria>
1. Repository implements all WorkoutLogRepository port methods
2. save() atomically replaces log aggregate using transaction
3. All queries filter by ctx.organizationId
4. listPendingWorkouts() finds sessions without logs (complex join)
5. findById/findByAthleteSessionWeek return null when not found (not error)
</success_criteria>

<output>
After completion, create `.planning/phases/04-coach-workout-logging/04-03-SUMMARY.md`
</output>
