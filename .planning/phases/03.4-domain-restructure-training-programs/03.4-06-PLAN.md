---
phase: 03.4-domain-restructure-training-programs
plan: 06
type: execute
wave: 4
depends_on: ["03.4-04", "03.4-05"]
files_modified:
  - apps/coach-web/src/stores/grid-store.ts
  - apps/coach-web/src/components/programs/program-grid/transform-program.ts
  - apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts
  - apps/coach-web/src/features/programs/hooks/queries/use-program.ts
  - apps/coach-web/src/features/programs/hooks/queries/use-exercises-map.ts
autonomous: true

must_haves:
  truths:
    - "Grid store produces complete program aggregate on getChanges()"
    - "Transform function converts API aggregate to grid display format"
    - "Save mutation sends full aggregate (not deltas)"
    - "Program query receives full aggregate"
    - "Exercise names display correctly in grid (via exercises lookup)"
    - "Series format correctly using formatSeriesToNotation from contracts"
  artifacts:
    - path: "apps/coach-web/src/stores/grid-store.ts"
      provides: "Store that builds aggregate from grid state"
      exports: ["useGridStore", "getAggregateForSave"]
    - path: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      provides: "Transform aggregate to grid display format with exercise name lookup"
      exports: ["transformProgramToGrid"]
    - path: "apps/coach-web/src/features/programs/hooks/queries/use-exercises-map.ts"
      provides: "Hook to fetch exercises map for name lookup"
      exports: ["useExercisesMap"]
  key_links:
    - from: "apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts"
      to: "apps/coach-web/src/stores/grid-store.ts"
      via: "getAggregateForSave"
      pattern: "getAggregateForSave"
    - from: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      to: "@strenly/contracts/programs/program"
      via: "Program type import"
      pattern: "import.*Program.*from.*contracts"
    - from: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      to: "@strenly/contracts/programs/prescription"
      via: "formatSeriesToNotation import"
      pattern: "import.*formatSeriesToNotation.*from.*contracts"
---

<objective>
Update the frontend grid store and hooks to work with the Program aggregate. The store builds the complete aggregate for save operations. Transform functions convert between API aggregate and grid display format.

Purpose: Complete the full-stack alignment by updating the frontend to send/receive the complete Program aggregate instead of delta changes.

Output: Grid store that produces aggregate, updated hooks for aggregate API.
</objective>

<exercise_name_handling>
**CRITICAL: Handling Exercise Names in the Grid**

The Program aggregate (from API) contains `exerciseId` but NOT `exerciseName`.
The grid needs to display exercise names. Solution:

1. **Create useExercisesMap hook** - fetches all exercises and returns Map<exerciseId, exerciseName>
2. **Pass exercises map to transform function** - transformProgramToGrid(program, exercisesMap)
3. **Look up exercise names during transform** - exercisesMap.get(item.exerciseId) ?? 'Unknown'

This is a JOIN operation done client-side, which is efficient because:
- Exercises are cached (TanStack Query)
- Programs typically have 10-30 exercises (small lookup)
- Avoids N+1 API calls
</exercise_name_handling>

<series_formatting>
**CRITICAL: Series Formatting**

Use the EXISTING `formatSeriesToNotation` function from contracts package:

```typescript
import { formatSeriesToNotation } from '@strenly/contracts/programs/prescription'

// Series[] -> "3x10@80%" string
const notation = formatSeriesToNotation(item.series)
```

Do NOT hand-roll series formatting. The contracts package has a tested formatter
that handles all edge cases (AMRAP, rep ranges, RPE, RIR, tempo, etc.).
</series_formatting>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-05-SUMMARY.md

# Current store and hooks
@apps/coach-web/src/stores/grid-store.ts
@apps/coach-web/src/components/programs/program-grid/transform-program.ts
@apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts

# New contract types
@packages/contracts/src/programs/program.ts
@packages/contracts/src/programs/save-draft.ts

# Existing formatter - USE THIS
@packages/contracts/src/programs/prescription.ts
</context>

<skills>
/orpc-query - TanStack Query + oRPC patterns
</skills>

<tasks>

<task type="auto">
  <name>Task 1: Create useExercisesMap Hook for Name Lookup</name>
  <files>apps/coach-web/src/features/programs/hooks/queries/use-exercises-map.ts</files>
  <action>
    Create a hook that fetches all exercises and returns a Map for efficient lookup.

    ```typescript
    // apps/coach-web/src/features/programs/hooks/queries/use-exercises-map.ts
    import { useQuery } from '@tanstack/react-query'
    import { orpc } from '@/lib/api-client'

    /**
     * Returns a Map of exerciseId -> exerciseName for display in the grid.
     * Exercises are cached, so this is efficient even with multiple components using it.
     */
    export function useExercisesMap() {
      const { data: exercises, ...rest } = useQuery({
        ...orpc.exercises.list.queryOptions({
          input: { limit: 1000 }, // Fetch all exercises (usually < 500)
        }),
        staleTime: 5 * 60 * 1000, // 5 minutes - exercises don't change often
      })

      // Build Map for O(1) lookup
      const exercisesMap = new Map<string, string>()
      if (exercises?.items) {
        for (const exercise of exercises.items) {
          exercisesMap.set(exercise.id, exercise.name)
        }
      }

      return {
        exercisesMap,
        isLoading: rest.isLoading,
        error: rest.error,
      }
    }
    ```

    This hook:
    - Fetches all exercises once (with long cache time)
    - Returns a Map for O(1) name lookup by exerciseId
    - Used by the transform function to display exercise names
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web
    ```
  </verify>
  <done>
    useExercisesMap hook created for efficient exercise name lookup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Grid Store to Build Aggregate</name>
  <files>apps/coach-web/src/stores/grid-store.ts</files>
  <action>
    Refactor the grid store to maintain the program aggregate and provide it for save operations.

    Key changes:

    1. Store the original program aggregate (from API load)
    2. Track mutations directly on the aggregate structure (not deltas)
    3. Provide getAggregateForSave() that returns the complete Program for the API

    Updated store structure:

    ```typescript
    import type { Program, Week, Session, ExerciseGroup, GroupItem, Series } from '@strenly/contracts/programs/program'
    import { parsePrescriptionToSeries } from '@strenly/contracts/programs/prescription'

    interface GridState {
      // The program aggregate (source of truth)
      program: Program | null
      programId: string | null

      // Grid display data (derived from program)
      gridData: GridData | null

      // Dirty tracking
      isDirty: boolean
      lastLoadedAt: Date | null
    }

    interface GridActions {
      // Initialize with loaded program aggregate
      initialize: (program: Program) => void

      // Update prescription for an exercise in a specific week
      updatePrescription: (exerciseRowId: string, weekId: string, notation: string) => void

      // Update which exercise is in a row
      updateExercise: (rowId: string, exerciseId: string, exerciseName: string) => void

      // Add exercise to a session
      addExercise: (sessionId: string, exerciseId: string, exerciseName: string) => void

      // Add week
      addWeek: () => void

      // Add session
      addSession: (name: string) => void

      // Update superset group
      updateSupersetGroup: (rowId: string, groupLetter: string | null) => void

      // Get the complete aggregate for save
      getAggregateForSave: () => {
        programId: string
        program: Omit<Program, 'id' | 'organizationId' | 'createdAt' | 'updatedAt'>
      } | null

      // Reset to server state
      reset: (program: Program) => void

      // Mark as saved
      markSaved: () => void
    }
    ```

    Implementation approach:

    1. `initialize(program)`: Store the program aggregate and derive gridData via transformProgramToGrid

    2. `updatePrescription()`: Find the item in the aggregate, parse notation to series, update in place
       - Use `parsePrescriptionToSeries` from contracts to convert notation -> Series[]

    3. `addWeek()`: Add a new week to program.weeks array with generated ID

    4. `addSession()`: Add a new session to ALL weeks (sessions span weeks)

    5. `addExercise()`: Add a new group with one item to a session

    6. `getAggregateForSave()`: Return the current program aggregate state

    The key insight: Instead of tracking deltas, we mutate a copy of the aggregate.
    On save, we send the entire aggregate. On success, we mark clean.

    ```typescript
    getAggregateForSave: () => {
      const state = get()
      if (!state.program || !state.programId) return null

      return {
        programId: state.programId,
        program: {
          name: state.program.name,
          description: state.program.description,
          athleteId: state.program.athleteId,
          isTemplate: state.program.isTemplate,
          status: state.program.status,
          weeks: state.program.weeks,
        },
      }
    }
    ```

    Note: The store no longer needs:
    - changedPrescriptions Map
    - changedExerciseRows Map
    - newWeeks/newSessions/newExerciseRows Maps
    - tempId tracking

    These were needed for delta-based save. With aggregate save, we just send the whole thing.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web
    ```
  </verify>
  <done>
    Grid store maintains program aggregate and provides getAggregateForSave().
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Transform Function with Exercise Names and Series Formatting</name>
  <files>apps/coach-web/src/components/programs/program-grid/transform-program.ts</files>
  <action>
    Update the transform function to:
    1. Accept exercisesMap parameter for name lookup
    2. Use formatSeriesToNotation from contracts for series formatting

    ```typescript
    import type { Program, Week, Session, ExerciseGroup, GroupItem, Series } from '@strenly/contracts/programs/program'
    import { formatSeriesToNotation } from '@strenly/contracts/programs/prescription'
    import type { GridData, GridRow, GridColumn } from './types'

    /**
     * Transform Program aggregate to GridData for display.
     *
     * @param program - The program aggregate from the API
     * @param exercisesMap - Map of exerciseId -> exerciseName for display
     */
    export function transformProgramToGrid(
      program: Program,
      exercisesMap: Map<string, string>,
    ): GridData {
      // Build columns from weeks
      const columns: GridColumn[] = [
        { id: 'exercise', name: 'Ejercicio', type: 'exercise' },
        ...program.weeks.map(week => ({
          id: week.id,
          name: week.name,
          type: 'week' as const,
          weekId: week.id,
        })),
      ]

      // Build rows from sessions
      // Sessions in the aggregate are per-week (same structure, different prescriptions)
      // The grid shows sessions as rows that span all week columns

      const rows: GridRow[] = []

      // Use first week's session structure as canonical (all weeks have same sessions)
      const firstWeek = program.weeks[0]
      if (!firstWeek) {
        return { columns, rows }
      }

      for (const session of firstWeek.sessions) {
        // Add session header row
        rows.push({
          id: `session-header-${session.id}`,
          type: 'session-header',
          sessionId: session.id,
          sessionName: session.name,
          supersetGroup: null,
          supersetOrder: null,
          supersetPosition: null,
          isSubRow: false,
          parentRowId: null,
          setTypeLabel: null,
          prescriptions: {},
        })

        // Add exercise rows for this session
        for (const group of session.exerciseGroups) {
          for (const item of group.items) {
            // Build prescriptions map (weekId -> notation string)
            const prescriptions: Record<string, string> = {}

            for (const week of program.weeks) {
              // Find this item in the corresponding session/group in this week
              const weekSession = week.sessions.find(s => s.id === session.id)
              const weekGroup = weekSession?.exerciseGroups.find(g => g.id === group.id)
              const weekItem = weekGroup?.items.find(i => i.id === item.id)

              if (weekItem && weekItem.series.length > 0) {
                // Use formatSeriesToNotation from contracts - DO NOT hand-roll
                prescriptions[week.id] = formatSeriesToNotation(weekItem.series)
              } else {
                prescriptions[week.id] = ''
              }
            }

            // Calculate group letter/position for superset display
            const groupSize = group.items.length
            const itemIndex = group.items.indexOf(item)
            const groupLetter = String.fromCharCode(65 + session.exerciseGroups.indexOf(group)) // A, B, C...
            const groupIndex = itemIndex + 1 // 1, 2, 3...

            // Look up exercise name from the exercisesMap
            const exerciseName = exercisesMap.get(item.exerciseId) ?? 'Ejercicio desconocido'

            rows.push({
              id: item.id,
              type: 'exercise',
              sessionId: session.id,
              sessionName: session.name,
              exercise: {
                exerciseId: item.exerciseId,
                exerciseName: exerciseName,  // From exercisesMap lookup
                position: item.orderIndex,
              },
              supersetGroup: groupSize > 1 ? groupLetter : null,
              supersetOrder: groupSize > 1 ? groupIndex : null,
              supersetPosition: groupSize > 1
                ? (itemIndex === 0 ? 'first' : itemIndex === groupSize - 1 ? 'last' : 'middle')
                : null,
              groupLetter: groupSize > 1 ? groupLetter : undefined,
              groupIndex: groupSize > 1 ? groupIndex : undefined,
              isSubRow: false,
              parentRowId: null,
              setTypeLabel: null,
              prescriptions,
            })
          }
        }

        // Add "add exercise" row for this session
        rows.push({
          id: `add-exercise-${session.id}`,
          type: 'add-exercise',
          sessionId: session.id,
          sessionName: session.name,
          supersetGroup: null,
          supersetOrder: null,
          supersetPosition: null,
          isSubRow: false,
          parentRowId: null,
          setTypeLabel: null,
          prescriptions: {},
        })
      }

      return { columns, rows }
    }
    ```

    Also update or keep the recalculateSessionGroups helper for superset labeling.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web
    ```
  </verify>
  <done>
    Transform function uses exercisesMap for names and formatSeriesToNotation for series.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Hooks for Aggregate API</name>
  <files>
    apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts
    apps/coach-web/src/features/programs/hooks/queries/use-program.ts
  </files>
  <action>
    Update the hooks to work with the new aggregate-based API.

    **use-save-draft.ts:**

    ```typescript
    import { useMutation, useQueryClient } from '@tanstack/react-query'
    import { orpc } from '@/lib/api-client'
    import { useGridStore } from '@/stores/grid-store'
    import type { SaveDraftInput } from '@strenly/contracts/programs/save-draft'

    export function useSaveDraft() {
      const queryClient = useQueryClient()
      const getAggregateForSave = useGridStore(state => state.getAggregateForSave)
      const markSaved = useGridStore(state => state.markSaved)

      return useMutation({
        mutationFn: async () => {
          const aggregate = getAggregateForSave()
          if (!aggregate) {
            throw new Error('No program data to save')
          }

          // Call API with full aggregate
          return orpc.programs.prescriptions.saveDraft.mutate(aggregate)
        },
        onSuccess: () => {
          // Mark store as saved
          markSaved()

          // Invalidate program queries to refetch fresh data
          queryClient.invalidateQueries({ queryKey: orpc.programs.key() })
        },
      })
    }
    ```

    **use-program.ts (if fetching for grid):**

    ```typescript
    import { useQuery } from '@tanstack/react-query'
    import { orpc } from '@/lib/api-client'
    import type { Program } from '@strenly/contracts/programs/program'

    export function useProgram(programId: string) {
      return useQuery({
        ...orpc.programs.get.queryOptions({ input: { programId } }),
        enabled: !!programId,
      })
    }
    ```

    The data returned is now the full Program aggregate which can be passed directly to the grid store's initialize().

    Also update the program editor page to:
    1. Fetch program with useProgram
    2. Fetch exercises with useExercisesMap
    3. Initialize grid store with program aggregate + exercisesMap
    4. Use useSaveDraft for save button

    ```typescript
    // In program editor page
    const { data: program, isLoading: programLoading } = useProgram(programId)
    const { exercisesMap, isLoading: exercisesLoading } = useExercisesMap()
    const initialize = useGridStore(state => state.initialize)

    useEffect(() => {
      if (program && exercisesMap.size > 0) {
        initialize(program, exercisesMap)
      }
    }, [program, exercisesMap, initialize])
    ```
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web
    ```
  </verify>
  <done>
    Hooks work with aggregate API - save sends full program, load receives full aggregate.
  </done>
</task>

</tasks>

<verification>
```bash
# Type check frontend
cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web

# Verify store exports
grep -q "getAggregateForSave" apps/coach-web/src/stores/grid-store.ts

# Verify transform function signature includes exercisesMap
grep -q "exercisesMap" apps/coach-web/src/components/programs/program-grid/transform-program.ts

# Verify formatSeriesToNotation is imported
grep -q "formatSeriesToNotation" apps/coach-web/src/components/programs/program-grid/transform-program.ts

# Full project type check
cd /Users/tomiardz/Projects/treino && pnpm typecheck
```
</verification>

<success_criteria>
- Grid store maintains program aggregate
- getAggregateForSave() returns complete program for API
- Transform function accepts exercisesMap for name lookup
- Transform function uses formatSeriesToNotation from contracts
- useSaveDraft sends full aggregate
- useProgram receives full aggregate
- useExercisesMap provides exercise name lookup
- Frontend typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-domain-restructure-training-programs/03.4-06-SUMMARY.md`
</output>
