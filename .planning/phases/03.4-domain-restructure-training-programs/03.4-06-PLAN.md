---
phase: 03.4-domain-restructure-training-programs
plan: 06
type: execute
wave: 4
depends_on: ["03.4-04", "03.4-05"]
files_modified:
  - apps/coach-web/src/stores/grid-store.ts
  - apps/coach-web/src/components/programs/program-grid/transform-program.ts
  - apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts
  - apps/coach-web/src/features/programs/hooks/queries/use-program.ts
autonomous: true

must_haves:
  truths:
    - "Grid store produces complete program aggregate on getChanges()"
    - "Transform function converts API aggregate to grid display format"
    - "Save mutation sends full aggregate (not deltas)"
    - "Program query receives full aggregate"
  artifacts:
    - path: "apps/coach-web/src/stores/grid-store.ts"
      provides: "Store that builds aggregate from grid state"
      exports: ["useGridStore", "getAggregateForSave"]
    - path: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      provides: "Transform aggregate to grid display format"
      exports: ["transformProgramToGrid"]
  key_links:
    - from: "apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts"
      to: "apps/coach-web/src/stores/grid-store.ts"
      via: "getAggregateForSave"
      pattern: "getAggregateForSave"
    - from: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      to: "@strenly/contracts/programs/program"
      via: "Program type import"
      pattern: "import.*Program.*from.*contracts"
---

<objective>
Update the frontend grid store and hooks to work with the Program aggregate. The store builds the complete aggregate for save operations. Transform functions convert between API aggregate and grid display format.

Purpose: Complete the full-stack alignment by updating the frontend to send/receive the complete Program aggregate instead of delta changes.

Output: Grid store that produces aggregate, updated hooks for aggregate API.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-05-SUMMARY.md

# Current store and hooks
@apps/coach-web/src/stores/grid-store.ts
@apps/coach-web/src/components/programs/program-grid/transform-program.ts
@apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts

# New contract types
@packages/contracts/src/programs/program.ts
@packages/contracts/src/programs/save-draft.ts
</context>

<skills>
/orpc-query - TanStack Query + oRPC patterns
</skills>

<tasks>

<task type="auto">
  <name>Task 1: Update Grid Store to Build Aggregate</name>
  <files>apps/coach-web/src/stores/grid-store.ts</files>
  <action>
    Refactor the grid store to maintain the program aggregate and provide it for save operations.

    Key changes:

    1. Store the original program aggregate (from API load)
    2. Track mutations directly on the aggregate structure (not deltas)
    3. Provide getAggregateForSave() that returns the complete Program for the API

    Updated store structure:

    ```typescript
    import type { Program, Week, Session, ExerciseGroup, GroupItem, Series } from '@strenly/contracts/programs/program'
    import { formatSeriesToNotation, parsePrescriptionToSeries } from '@strenly/contracts/programs/prescription'

    interface GridState {
      // The program aggregate (source of truth)
      program: Program | null
      programId: string | null

      // Grid display data (derived from program)
      gridData: GridData | null

      // Dirty tracking
      isDirty: boolean
      lastLoadedAt: Date | null
    }

    interface GridActions {
      // Initialize with loaded program aggregate
      initialize: (program: Program) => void

      // Update prescription for an exercise in a specific week
      updatePrescription: (exerciseRowId: string, weekId: string, notation: string) => void

      // Update which exercise is in a row
      updateExercise: (rowId: string, exerciseId: string, exerciseName: string) => void

      // Add exercise to a session
      addExercise: (sessionId: string, exerciseId: string, exerciseName: string) => void

      // Add week
      addWeek: () => void

      // Add session
      addSession: (name: string) => void

      // Update superset group
      updateSupersetGroup: (rowId: string, groupLetter: string | null) => void

      // Get the complete aggregate for save
      getAggregateForSave: () => {
        programId: string
        program: Omit<Program, 'id' | 'organizationId' | 'createdAt' | 'updatedAt'>
      } | null

      // Reset to server state
      reset: (program: Program) => void

      // Mark as saved
      markSaved: () => void
    }
    ```

    Implementation approach:

    1. `initialize(program)`: Store the program aggregate and derive gridData via transformProgramToGrid

    2. `updatePrescription()`: Find the item in the aggregate, parse notation to series, update in place

    3. `addWeek()`: Add a new week to program.weeks array with generated ID

    4. `addSession()`: Add a new session to ALL weeks (sessions span weeks)

    5. `addExercise()`: Add a new group with one item to a session

    6. `getAggregateForSave()`: Return the current program aggregate state

    The key insight: Instead of tracking deltas, we mutate a copy of the aggregate.
    On save, we send the entire aggregate. On success, we mark clean.

    ```typescript
    getAggregateForSave: () => {
      const state = get()
      if (!state.program || !state.programId) return null

      return {
        programId: state.programId,
        program: {
          name: state.program.name,
          description: state.program.description,
          athleteId: state.program.athleteId,
          isTemplate: state.program.isTemplate,
          status: state.program.status,
          weeks: state.program.weeks,
        },
      }
    }
    ```

    Note: The store no longer needs:
    - changedPrescriptions Map
    - changedExerciseRows Map
    - newWeeks/newSessions/newExerciseRows Maps
    - tempId tracking

    These were needed for delta-based save. With aggregate save, we just send the whole thing.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web
    ```
  </verify>
  <done>
    Grid store maintains program aggregate and provides getAggregateForSave().
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Transform Function for Aggregate</name>
  <files>apps/coach-web/src/components/programs/program-grid/transform-program.ts</files>
  <action>
    Update the transform function to work with the new Program aggregate structure.

    The function transforms Program aggregate -> GridData for display:

    ```typescript
    import type { Program, Week, Session, ExerciseGroup, GroupItem, Series } from '@strenly/contracts/programs/program'
    import { formatSeriesToNotation } from '@strenly/contracts/programs/prescription'
    import type { GridData, GridRow, GridColumn } from './types'

    export function transformProgramToGrid(program: Program): GridData {
      // Build columns from weeks
      const columns: GridColumn[] = [
        { id: 'exercise', name: 'Ejercicio', type: 'exercise' },
        ...program.weeks.map(week => ({
          id: week.id,
          name: week.name,
          type: 'week' as const,
          weekId: week.id,
        })),
      ]

      // Build rows from sessions
      // Note: Sessions in the aggregate are per-week, but the grid shows sessions that span weeks
      // The aggregate structure has weeks -> sessions -> groups -> items -> series
      // For display, we need to show sessions across weeks (same session in each week column)

      const rows: GridRow[] = []

      // Since sessions are shared across weeks in the display (different prescriptions per week),
      // we need to take the first week's session structure as canonical
      const firstWeek = program.weeks[0]
      if (!firstWeek) {
        return { columns, rows }
      }

      for (const session of firstWeek.sessions) {
        // Add session header row
        rows.push({
          id: `session-header-${session.id}`,
          type: 'session-header',
          sessionId: session.id,
          sessionName: session.name,
          supersetGroup: null,
          supersetOrder: null,
          supersetPosition: null,
          isSubRow: false,
          parentRowId: null,
          setTypeLabel: null,
          prescriptions: {},
        })

        // Add exercise rows for this session
        for (const group of session.exerciseGroups) {
          for (const item of group.items) {
            // Build prescriptions map (weekId -> notation string)
            const prescriptions: Record<string, string> = {}

            for (const week of program.weeks) {
              // Find this item in the corresponding session/group in this week
              const weekSession = week.sessions.find(s => s.id === session.id)
              const weekGroup = weekSession?.exerciseGroups.find(g => g.id === group.id)
              const weekItem = weekGroup?.items.find(i => i.id === item.id)

              if (weekItem && weekItem.series.length > 0) {
                prescriptions[week.id] = formatSeriesToNotation(weekItem.series)
              } else {
                prescriptions[week.id] = ''
              }
            }

            // Calculate group letter/position for superset display
            const groupSize = group.items.length
            const itemIndex = group.items.indexOf(item)
            const groupLetter = String.fromCharCode(65 + session.exerciseGroups.indexOf(group)) // A, B, C...
            const groupIndex = itemIndex + 1 // 1, 2, 3...

            rows.push({
              id: item.id,
              type: 'exercise',
              sessionId: session.id,
              sessionName: session.name,
              exercise: {
                exerciseId: item.exerciseId,
                exerciseName: item.exerciseName ?? 'Unknown', // Need to look up from exercises
                position: item.orderIndex,
              },
              supersetGroup: groupSize > 1 ? groupLetter : null,
              supersetOrder: groupSize > 1 ? groupIndex : null,
              supersetPosition: groupSize > 1
                ? (itemIndex === 0 ? 'first' : itemIndex === groupSize - 1 ? 'last' : 'middle')
                : null,
              groupLetter: groupSize > 1 ? groupLetter : undefined,
              groupIndex: groupSize > 1 ? groupIndex : undefined,
              isSubRow: false,
              parentRowId: null,
              setTypeLabel: null,
              prescriptions,
            })
          }
        }

        // Add "add exercise" row for this session
        rows.push({
          id: `add-exercise-${session.id}`,
          type: 'add-exercise',
          sessionId: session.id,
          sessionName: session.name,
          supersetGroup: null,
          supersetOrder: null,
          supersetPosition: null,
          isSubRow: false,
          parentRowId: null,
          setTypeLabel: null,
          prescriptions: {},
        })
      }

      return { columns, rows }
    }
    ```

    Also update or keep the recalculateSessionGroups helper for superset labeling.

    Note: The aggregate structure stores series per item per week. The grid needs prescription notation strings per week.
    formatSeriesToNotation converts Series[] -> string notation.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web
    ```
  </verify>
  <done>
    Transform function converts Program aggregate to GridData for display.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Hooks for Aggregate API</name>
  <files>
    apps/coach-web/src/features/programs/hooks/mutations/use-save-draft.ts
    apps/coach-web/src/features/programs/hooks/queries/use-program.ts
  </files>
  <action>
    Update the hooks to work with the new aggregate-based API.

    **use-save-draft.ts:**

    ```typescript
    import { useMutation, useQueryClient } from '@tanstack/react-query'
    import { orpc } from '@/lib/api-client'
    import { useGridStore } from '@/stores/grid-store'
    import type { SaveDraftInput } from '@strenly/contracts/programs/save-draft'

    export function useSaveDraft() {
      const queryClient = useQueryClient()
      const getAggregateForSave = useGridStore(state => state.getAggregateForSave)
      const markSaved = useGridStore(state => state.markSaved)

      return useMutation({
        mutationFn: async () => {
          const aggregate = getAggregateForSave()
          if (!aggregate) {
            throw new Error('No program data to save')
          }

          // Call API with full aggregate
          return orpc.programs.prescriptions.saveDraft.mutate(aggregate)
        },
        onSuccess: () => {
          // Mark store as saved
          markSaved()

          // Invalidate program queries to refetch fresh data
          queryClient.invalidateQueries({ queryKey: orpc.programs.key() })
        },
      })
    }
    ```

    **use-program.ts (if fetching for grid):**

    ```typescript
    import { useQuery } from '@tanstack/react-query'
    import { orpc } from '@/lib/api-client'
    import type { Program } from '@strenly/contracts/programs/program'

    export function useProgram(programId: string) {
      return useQuery({
        ...orpc.programs.get.queryOptions({ input: { programId } }),
        enabled: !!programId,
      })
    }
    ```

    The data returned is now the full Program aggregate which can be passed directly to the grid store's initialize().

    Also update the program editor page to:
    1. Fetch program with useProgram
    2. Initialize grid store with program aggregate
    3. Use useSaveDraft for save button

    ```typescript
    // In program editor page
    const { data: program, isLoading } = useProgram(programId)
    const initialize = useGridStore(state => state.initialize)

    useEffect(() => {
      if (program) {
        initialize(program)
      }
    }, [program, initialize])
    ```
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web
    ```
  </verify>
  <done>
    Hooks work with aggregate API - save sends full program, load receives full aggregate.
  </done>
</task>

</tasks>

<verification>
```bash
# Type check frontend
cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter coach-web

# Verify store exports
grep -q "getAggregateForSave" apps/coach-web/src/stores/grid-store.ts

# Verify transform function exists
grep -q "transformProgramToGrid" apps/coach-web/src/components/programs/program-grid/transform-program.ts

# Full project type check
cd /Users/tomiardz/Projects/treino && pnpm typecheck
```
</verification>

<success_criteria>
- Grid store maintains program aggregate
- getAggregateForSave() returns complete program for API
- Transform function converts aggregate to grid display format
- useSaveDraft sends full aggregate
- useProgram receives full aggregate
- Frontend typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-domain-restructure-training-programs/03.4-06-SUMMARY.md`
</output>
