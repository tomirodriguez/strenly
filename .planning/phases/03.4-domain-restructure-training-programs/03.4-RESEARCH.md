# Phase 3.4: Domain Restructure - Training Programs - Research

**Researched:** 2026-01-26
**Domain:** Clean Architecture, DDD Aggregates, Training Program Domain Model
**Confidence:** HIGH

## Summary

This phase restructures the core domain to correctly model training programs as a proper DDD aggregate. The current codebase has fragmented domain entities that evolved across phases 3.0-3.3 without proper aggregate design. The Program entity exists as a flat structure with separate entities for nested concerns (Prescription, ExerciseGroup, PrescriptionSeries), but these don't function as a cohesive aggregate with invariant enforcement.

The target architecture establishes Program as an Aggregate Root containing the entire training plan hierarchy: Program -> Weeks -> Sessions -> ExerciseGroups -> GroupItems -> Series. This enables validating the entire program in one operation before persistence, implementing a DELETE + INSERT save strategy for simplicity, and removing legacy entities that no longer fit the model.

This is a domain restructure phase - the database schema and frontend grid already work correctly from phases 3.2/3.3. The gap is in the `packages/core` domain layer where entities don't properly model the aggregate, and the backend which passes data through without full aggregate validation.

**Primary recommendation:** Create a proper Program aggregate in `packages/core` that owns the entire hierarchy, validate through the aggregate before any persistence, implement full replace-on-save in the repository, and delete all legacy entities/code that don't fit the new model.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| neverthrow | ^8.x | Result types for domain validation | Already in use, provides `ok()/err()` for aggregate validation |
| Drizzle ORM | ^0.38.x | Database operations with transactions | Already configured, supports bulk operations and transactions |
| Zod | ^3.x | Schema validation at API boundary | Contracts already use Zod, continue pattern |
| Zustand | ^5.x | Client-side state management | Already in use for grid state |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| uuid/crypto.randomUUID | native | ID generation | For new domain entities |
| Vitest | ^3.x | Testing | 90%+ coverage on domain entities |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Full domain events | Simple aggregate methods | Events add complexity for this scale |
| Separate repositories per entity | Single aggregate repository | Multiple repos add coordination overhead |

**Installation:**
```bash
# No new dependencies needed - using existing stack
```

## Architecture Patterns

### Recommended Domain Structure
```
packages/core/src/domain/entities/
  program/                      # Program aggregate folder
    program.ts                  # Aggregate root with full hierarchy
    program.test.ts             # Comprehensive aggregate tests
    week.ts                     # Week value object/entity
    session.ts                  # Session value object/entity
    exercise-group.ts           # ExerciseGroup value object/entity
    group-item.ts               # GroupItem with series
    series.ts                   # Individual set value object
    types.ts                    # Shared types for the aggregate
```

### Pattern 1: Aggregate Root with Nested Validation

**What:** The Program aggregate root contains and validates the entire hierarchy. No child entity can be created or modified outside the aggregate.

**When to use:** Always for the Program domain - this is the transactional boundary.

**Example:**
```typescript
// Source: DDD pattern applied to project conventions
export type Program = {
  readonly id: string
  readonly organizationId: string
  readonly name: string
  readonly description: string | null
  readonly athleteId: string | null
  readonly isTemplate: boolean
  readonly status: ProgramStatus
  readonly weeks: ReadonlyArray<Week>
  readonly createdAt: Date
  readonly updatedAt: Date
}

export type Week = {
  readonly id: string
  readonly name: string
  readonly orderIndex: number
  readonly sessions: ReadonlyArray<Session>
}

export type Session = {
  readonly id: string
  readonly name: string
  readonly orderIndex: number
  readonly exerciseGroups: ReadonlyArray<ExerciseGroup>
}

export type ExerciseGroup = {
  readonly id: string
  readonly name: string | null
  readonly orderIndex: number
  readonly items: ReadonlyArray<GroupItem>
}

export type GroupItem = {
  readonly id: string
  readonly exerciseId: string
  readonly orderIndex: number
  readonly series: ReadonlyArray<Series>
}

export type Series = {
  readonly orderIndex: number
  readonly reps: number | null
  readonly repsMax: number | null
  readonly isAmrap: boolean
  readonly intensityType: IntensityType | null
  readonly intensityValue: number | null
  readonly tempo: string | null
  readonly restSeconds: number | null
}
```

### Pattern 2: Factory with Full Validation

**What:** The `createProgram()` factory validates the entire aggregate before returning `ok()`.

**When to use:** When creating a new program or reconstituting from API input.

**Example:**
```typescript
// Source: Project conventions + DDD aggregate pattern
export type CreateProgramInput = {
  id: string
  organizationId: string
  name: string
  description?: string | null
  athleteId?: string | null
  isTemplate?: boolean
  status?: ProgramStatus
  weeks?: WeekInput[]
  createdAt?: Date
  updatedAt?: Date
}

export function createProgram(input: CreateProgramInput): Result<Program, ProgramError> {
  // 1. Validate program-level invariants
  const nameResult = validateProgramName(input.name)
  if (nameResult.isErr()) return err(nameResult.error)

  // 2. Validate and create weeks (recursively validates sessions, groups, items, series)
  const weeksResult = validateAndCreateWeeks(input.weeks ?? [])
  if (weeksResult.isErr()) return err(weeksResult.error)

  // 3. Validate cross-aggregate invariants (e.g., unique orderIndexes)
  const orderResult = validateOrderIndexes(weeksResult.value)
  if (orderResult.isErr()) return err(orderResult.error)

  return ok({
    id: input.id,
    organizationId: input.organizationId,
    name: nameResult.value,
    description: input.description ?? null,
    athleteId: input.athleteId ?? null,
    isTemplate: input.isTemplate ?? false,
    status: input.status ?? 'draft',
    weeks: weeksResult.value,
    createdAt: input.createdAt ?? new Date(),
    updatedAt: input.updatedAt ?? new Date(),
  })
}
```

### Pattern 3: Reconstitute for Database Loads

**What:** A separate `reconstituteProgram()` function loads from database without validation (data is already valid).

**When to use:** When loading a program from the database for display or editing.

**Example:**
```typescript
// Source: Project conventions
export function reconstituteProgram(props: Program): Program {
  return { ...props }
}
```

### Pattern 4: Replace-on-Save (DELETE + INSERT)

**What:** Instead of tracking deltas, save operation deletes all children and re-inserts the entire hierarchy.

**When to use:** Every time the program aggregate is saved. This is simpler than tracking changes and ensures data integrity.

**Example:**
```typescript
// Source: User decision + simplicity benefit
// In repository:
async saveProgramAggregate(ctx: OrganizationContext, program: Program): Promise<{ updatedAt: Date }> {
  await db.transaction(async (tx) => {
    // Delete all children (cascades handle prescriptions)
    await tx.delete(programExercises).where(
      inArray(programExercises.sessionId,
        tx.select({ id: programSessions.id })
          .from(programSessions)
          .where(eq(programSessions.programId, program.id))
      )
    )
    await tx.delete(exerciseGroups).where(
      inArray(exerciseGroups.sessionId,
        tx.select({ id: programSessions.id })
          .from(programSessions)
          .where(eq(programSessions.programId, program.id))
      )
    )
    await tx.delete(programSessions).where(eq(programSessions.programId, program.id))
    await tx.delete(programWeeks).where(eq(programWeeks.programId, program.id))

    // Re-insert everything
    for (const week of program.weeks) {
      await tx.insert(programWeeks).values({ ... })
      for (const session of week.sessions) {
        await tx.insert(programSessions).values({ ... })
        for (const group of session.exerciseGroups) {
          await tx.insert(exerciseGroups).values({ ... })
          for (const item of group.items) {
            await tx.insert(programExercises).values({ ... })
            if (item.series.length > 0) {
              await tx.insert(prescriptions).values({ ... })
            }
          }
        }
      }
    }

    // Update program metadata
    await tx.update(programs).set({ updatedAt: new Date() }).where(eq(programs.id, program.id))
  })
}
```

### Anti-Patterns to Avoid

- **Anemic domain model:** Don't make Program a plain data container with all logic in use cases. The aggregate should validate its invariants.
- **Exposing children directly:** Don't allow ExerciseGroup or Week to be created outside the aggregate context. All modifications go through Program methods.
- **Change tracking in domain:** Don't track deltas in the domain. Use replace-on-save strategy - simpler and guarantees consistency.
- **Multiple repositories for nested entities:** Don't have separate WeekRepository, SessionRepository. One ProgramRepository handles the aggregate.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| ID generation | Custom ID generator | `crypto.randomUUID()` | Standard, collision-resistant |
| Result types | Try/catch everywhere | neverthrow `Result<T, E>` | Already in codebase, type-safe |
| Validation chaining | Manual if/else nesting | neverthrow `.andThen()` | Cleaner, composable |
| Transaction management | Manual BEGIN/COMMIT | Drizzle `db.transaction()` | Handles rollback, nesting |
| Frontend state | useReducer + manual tracking | Zustand store | Already implemented |

**Key insight:** The project already has established patterns for all these concerns. Use them consistently rather than inventing new approaches.

## Common Pitfalls

### Pitfall 1: Validating Parts Instead of Whole

**What goes wrong:** Validating individual series or items without aggregate context, missing cross-entity invariants.

**Why it happens:** Temptation to reuse existing entity validators directly.

**How to avoid:** Always validate through the aggregate root. Individual validators can exist but are called by the aggregate factory.

**Warning signs:** Seeing `createSeries()` or `createGroupItem()` called outside of `createProgram()`.

### Pitfall 2: Tracking Changes in Domain

**What goes wrong:** Trying to track what changed (added weeks, modified prescriptions) in the domain layer for efficient updates.

**Why it happens:** Premature optimization - thinking DELETE + INSERT is inefficient.

**How to avoid:** Trust the replace-on-save strategy. For a training program (typically 4-6 weeks, 3-5 sessions, ~20 exercises per session), the cost is negligible. The simplicity benefit is enormous.

**Warning signs:** Domain entities having `changedFields` or `isNew` flags.

### Pitfall 3: Missing Invariants Across Weeks

**What goes wrong:** Not validating that series data is consistent across weeks for the same exercise (e.g., week 2 references an exercise not in week 1).

**Why it happens:** The current model stores prescriptions per (exerciseRow, week), but the domain model has series nested under GroupItem.

**How to avoid:** The new model stores series per GroupItem per Week. Validation ensures weeks have consistent exercise structure.

**Warning signs:** Runtime errors when grid expects data that doesn't exist.

### Pitfall 4: Breaking Frontend Assumptions

**What goes wrong:** Changing domain structure without updating the transform functions that convert domain -> GridData.

**Why it happens:** Domain restructure focused only on backend.

**How to avoid:** Plan includes updating `transform-program.ts` and ensuring Zustand store getChanges() produces the right shape for the new saveDraft contract.

**Warning signs:** TypeScript errors in frontend after domain changes.

### Pitfall 5: Not Deleting Legacy Code

**What goes wrong:** Keeping old Prescription entity "just in case", leading to confusion about which model is canonical.

**Why it happens:** Fear of removing code that might be needed.

**How to avoid:** User decision is explicit: "Delete all legacy code completely (no deprecated folder)". Remove old entities, their tests, and any references.

**Warning signs:** Multiple entity files for similar concepts (e.g., both `prescription.ts` and new series-based model).

## Code Examples

Verified patterns from official sources and project conventions:

### Aggregate Factory with Recursive Validation

```typescript
// Source: Project conventions + DDD aggregate pattern
// File: packages/core/src/domain/entities/program/program.ts

import { err, ok, type Result } from 'neverthrow'

export function createProgram(input: CreateProgramInput): Result<Program, ProgramError> {
  // Name validation
  const trimmedName = input.name.trim()
  if (trimmedName.length === 0) {
    return err({ type: 'NAME_REQUIRED', message: 'Program name is required' })
  }
  if (trimmedName.length < 3) {
    return err({ type: 'NAME_TOO_SHORT', message: 'Program name must be at least 3 characters' })
  }
  if (trimmedName.length > 100) {
    return err({ type: 'NAME_TOO_LONG', message: 'Program name must not exceed 100 characters' })
  }

  // Validate weeks
  const validatedWeeks: Week[] = []
  for (const weekInput of input.weeks ?? []) {
    const weekResult = validateWeek(weekInput)
    if (weekResult.isErr()) {
      return err(weekResult.error)
    }
    validatedWeeks.push(weekResult.value)
  }

  // Validate unique orderIndexes within weeks
  const weekIndexes = new Set<number>()
  for (const week of validatedWeeks) {
    if (weekIndexes.has(week.orderIndex)) {
      return err({ type: 'DUPLICATE_ORDER_INDEX', message: `Duplicate week orderIndex: ${week.orderIndex}` })
    }
    weekIndexes.add(week.orderIndex)
  }

  const now = new Date()
  return ok({
    id: input.id,
    organizationId: input.organizationId,
    name: trimmedName,
    description: input.description ?? null,
    athleteId: input.athleteId ?? null,
    isTemplate: input.isTemplate ?? false,
    status: input.status ?? 'draft',
    weeks: validatedWeeks,
    createdAt: input.createdAt ?? now,
    updatedAt: input.updatedAt ?? now,
  })
}
```

### Series Validation

```typescript
// Source: Existing prescription-series.ts patterns + project conventions
// File: packages/core/src/domain/entities/program/series.ts

export function validateSeries(input: SeriesInput, orderIndex: number): Result<Series, ProgramError> {
  if (orderIndex < 0) {
    return err({ type: 'INVALID_ORDER_INDEX', message: 'Series order index cannot be negative' })
  }

  if (input.reps !== null && input.reps < 0) {
    return err({ type: 'INVALID_REPS', message: 'Reps cannot be negative' })
  }

  if (input.isAmrap && input.reps !== null && input.reps > 0) {
    return err({ type: 'AMRAP_WITH_REPS', message: 'AMRAP series should have reps of null or 0' })
  }

  if (input.repsMax !== null && input.reps !== null && input.repsMax < input.reps) {
    return err({ type: 'INVALID_REP_RANGE', message: 'Max reps must be >= min reps' })
  }

  // Intensity validation (similar to existing prescription-series.ts)
  if (input.intensityType !== null && input.intensityValue !== null) {
    if (input.intensityType === 'percentage' && (input.intensityValue < 0 || input.intensityValue > 100)) {
      return err({ type: 'INVALID_PERCENTAGE', message: 'Percentage must be between 0 and 100' })
    }
    if (input.intensityType === 'rpe' && (input.intensityValue < 0 || input.intensityValue > 10)) {
      return err({ type: 'INVALID_RPE', message: 'RPE must be between 0 and 10' })
    }
    if (input.intensityType === 'rir' && (input.intensityValue < 0 || input.intensityValue > 10)) {
      return err({ type: 'INVALID_RIR', message: 'RIR must be between 0 and 10' })
    }
  }

  return ok({
    orderIndex,
    reps: input.reps,
    repsMax: input.repsMax ?? null,
    isAmrap: input.isAmrap,
    intensityType: input.intensityType ?? null,
    intensityValue: input.intensityValue ?? null,
    tempo: input.tempo ?? null,
    restSeconds: input.restSeconds ?? null,
  })
}
```

### Repository saveProgramAggregate

```typescript
// Source: Drizzle ORM transaction docs + project repository patterns
// File: packages/backend/src/infrastructure/repositories/program.repository.ts

saveProgramAggregate(
  ctx: OrganizationContext,
  program: Program,
): ResultAsync<{ updatedAt: Date }, ProgramRepositoryError> {
  return RA.fromPromise(
    (async () => {
      const updatedAt = new Date()

      await db.transaction(async (tx) => {
        // 1. Delete all child data (ON DELETE CASCADE handles prescriptions)
        await tx.delete(programExercises).where(
          sql`${programExercises.sessionId} IN (
            SELECT id FROM ${programSessions} WHERE program_id = ${program.id}
          )`
        )
        await tx.delete(exerciseGroups).where(
          sql`${exerciseGroups.sessionId} IN (
            SELECT id FROM ${programSessions} WHERE program_id = ${program.id}
          )`
        )
        await tx.delete(programSessions).where(eq(programSessions.programId, program.id))
        await tx.delete(programWeeks).where(eq(programWeeks.programId, program.id))

        // 2. Insert weeks
        for (const week of program.weeks) {
          await tx.insert(programWeeks).values({
            id: week.id,
            programId: program.id,
            name: week.name,
            orderIndex: week.orderIndex,
            createdAt: updatedAt,
            updatedAt,
          })
        }

        // 3. Insert sessions (linked to programId, not weekId for current schema)
        for (const week of program.weeks) {
          for (const session of week.sessions) {
            await tx.insert(programSessions).values({
              id: session.id,
              programId: program.id,
              name: session.name,
              orderIndex: session.orderIndex,
              createdAt: updatedAt,
              updatedAt,
            })

            // 4. Insert exercise groups
            for (const group of session.exerciseGroups) {
              await tx.insert(exerciseGroups).values({
                id: group.id,
                sessionId: session.id,
                orderIndex: group.orderIndex,
                name: group.name,
                createdAt: updatedAt,
                updatedAt,
              })

              // 5. Insert group items (exercises)
              for (const item of group.items) {
                await tx.insert(programExercises).values({
                  id: item.id,
                  sessionId: session.id,
                  exerciseId: item.exerciseId,
                  orderIndex: item.orderIndex,
                  groupId: group.id,
                  orderWithinGroup: item.orderIndex,
                  setTypeLabel: null,
                  notes: null,
                  restSeconds: null,
                  createdAt: updatedAt,
                  updatedAt,
                })

                // 6. Insert prescriptions (series per exercise per week)
                if (item.series.length > 0) {
                  await tx.insert(prescriptions).values({
                    id: `rx-${crypto.randomUUID()}`,
                    programExerciseId: item.id,
                    weekId: week.id,
                    series: item.series.map((s, i) => ({
                      orderIndex: i,
                      reps: s.reps,
                      repsMax: s.repsMax,
                      isAmrap: s.isAmrap,
                      intensityType: s.intensityType,
                      intensityValue: s.intensityValue,
                      intensityUnit: mapIntensityUnit(s.intensityType),
                      tempo: s.tempo,
                      restSeconds: s.restSeconds,
                    })),
                    createdAt: updatedAt,
                    updatedAt,
                  })
                }
              }
            }
          }
        }

        // 7. Update program metadata
        await tx.update(programs).set({
          name: program.name,
          description: program.description,
          athleteId: program.athleteId,
          isTemplate: program.isTemplate,
          status: program.status,
          updatedAt,
        }).where(eq(programs.id, program.id))
      })

      return { updatedAt }
    })(),
    wrapDbError,
  )
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Prescription with `sets` number | Series array per cell | Phase 3.2 | Enables set-by-set variation |
| Supersets as separate concept | ExerciseGroups with size | Phase 3.2 | Unified model |
| Per-change API calls | Client-side editing + save | Phase 3.2 | Better UX |
| Delta-based persistence | Replace-on-save | This phase | Simpler, more reliable |

**Deprecated/outdated (to be removed):**
- `packages/core/src/domain/entities/prescription.ts` - Old entity with `sets` number, replaced by series arrays
- `packages/core/src/domain/entities/prescription.test.ts` - Tests for old entity
- Any references to `createPrescription()` that aren't for backward compatibility
- Unused types in `program-repository.port.ts` that won't be needed with aggregate pattern

## Open Questions

Things that couldn't be fully resolved:

1. **Prescriptions per GroupItem vs per Exercise per Week**
   - What we know: Current DB stores prescriptions keyed by (programExerciseId, weekId)
   - What's unclear: The new domain model nests series under GroupItem, but should each week have its own series? (Yes - per user decision "Series stored per exercise-per-week")
   - Recommendation: Keep the current DB structure. In the domain model, GroupItem.series is for a specific week. The aggregate contains weeks, each with sessions, each with groups, each with items that have series FOR THAT WEEK.

2. **Session-Week Relationship**
   - What we know: Current schema has sessions linked to programs, not weeks. Weeks are columns.
   - What's unclear: Should sessions exist independently of weeks or be nested under weeks in domain?
   - Recommendation: Keep sessions at program level (all weeks share the same session structure). The week->session->group->item->series nesting in domain is for the data grid view where you're looking at one week's prescriptions at a time.

3. **Migration of Existing Data**
   - What we know: There's existing program data in the database
   - What's unclear: How much data exists, migration complexity
   - Recommendation: Plan should include a migration task. Since this is dev environment, can likely do a clean reset if data volume is small.

## Sources

### Primary (HIGH confidence)
- Project codebase analysis:
  - `packages/core/src/domain/entities/` - Current entity patterns
  - `packages/backend/src/infrastructure/repositories/program.repository.ts` - Current persistence patterns
  - `packages/database/src/schema/` - Database schema
  - `docs/domain-research-strength-training.md` - Domain model research
  - `.planning/ROADMAP.md` - Phase requirements and user decisions

### Secondary (MEDIUM confidence)
- [Khalil Stemmler - DDD Aggregates](https://khalilstemmler.com/articles/typescript-domain-driven-design/aggregate-design-persistence/) - TypeScript aggregate patterns
- [Drizzle ORM Transactions](https://orm.drizzle.team/docs/transactions) - Transaction API
- [Drizzle ORM Bulk Insert](https://orm.drizzle.team/docs/insert) - Batch operations

### Tertiary (LOW confidence)
- General DDD aggregate patterns from web search - validated against project conventions

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using existing project dependencies
- Architecture: HIGH - Based on DDD aggregate patterns + project conventions
- Pitfalls: HIGH - Derived from codebase analysis and domain understanding

**Research date:** 2026-01-26
**Valid until:** 2026-02-26 (30 days - stable domain, no external dependency changes expected)
