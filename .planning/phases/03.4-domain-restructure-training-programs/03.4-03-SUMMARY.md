---
# Execution Metadata
phase: "03.4"
plan: "03"
subsystem: "backend"
tags: ["repository", "aggregate", "transaction", "persistence"]

# Dependency Graph
dependency_graph:
  requires: ["03.4-01"]
  provides: ["aggregate-persistence-methods"]
  affects: ["03.4-04", "03.4-05"]

# Tech Tracking
tech_stack:
  added: []
  patterns: ["delete-insert-replace-on-save", "aggregate-reconstitution", "lookup-maps-for-efficient-load"]

# File Tracking
key_files:
  created: []
  modified:
    - "packages/core/src/ports/program-repository.port.ts"
    - "packages/backend/src/infrastructure/repositories/program.repository.ts"

# Decisions
decisions:
  - id: "aggregate-methods-in-port"
    title: "Add aggregate methods alongside legacy CRUD"
    context: "Need new aggregate-based persistence without breaking existing code"
    choice: "Add loadProgramAggregate/saveProgramAggregate, mark existing methods @deprecated"
    rationale: "Backward compatible transition path"

  - id: "delete-insert-transaction"
    title: "DELETE + INSERT replace strategy"
    context: "Need atomic updates of nested program hierarchy"
    choice: "Delete all children, then insert full hierarchy in single transaction"
    rationale: "Simpler than change tracking, guarantees consistency"

  - id: "synthetic-groups-for-ungrouped"
    title: "Ungrouped exercises become synthetic single-item groups"
    context: "Domain model requires all items to be in groups"
    choice: "Create synthetic groups with id prefix 'eg-synthetic-' for ungrouped exercises on load"
    rationale: "Maintains domain invariant that all items belong to a group"

  - id: "prescription-per-week"
    title: "Prescriptions keyed by (exerciseId, weekId)"
    context: "Same exercise structure appears in each week with different series"
    choice: "Store prescriptions with weekId, load via lookup map"
    rationale: "Matches domain aggregate structure where weeks contain different series for same exercises"

# Metrics
metrics:
  duration: "3 min"
  completed: "2026-01-26"
---

# Phase 03.4 Plan 03: Aggregate Repository Methods Summary

Aggregate-based persistence for Program: saveProgramAggregate (DELETE+INSERT transaction) and loadProgramAggregate (full hierarchy reconstitution with lookup maps)

## Completed Tasks

| # | Task | Commit | Files Changed |
|---|------|--------|---------------|
| 1 | Update Repository Port with Aggregate Methods | c48070e | `program-repository.port.ts` |
| 2 | Implement saveProgramAggregate in Repository | 4f6cadb | `program.repository.ts` |
| 3 | Implement loadProgramAggregate in Repository | 4f6cadb | `program.repository.ts` |

## What Was Built

### Port Updates (`packages/core/src/ports/program-repository.port.ts`)
- Added `loadProgramAggregate(ctx, programId)` - returns full `ProgramAggregate`
- Added `saveProgramAggregate(ctx, program)` - returns `{ updatedAt: Date }`
- Imported `Program as ProgramAggregate` from new domain location
- Marked existing CRUD methods with `@deprecated` JSDoc comments

### Repository Implementation (`packages/backend/src/infrastructure/repositories/program.repository.ts`)

**saveProgramAggregate:**
1. Verifies program ownership
2. Deletes all children in reverse dependency order:
   - prescriptions (by weekId)
   - programExercises (by sessionId)
   - exerciseGroups (by sessionId)
   - programSessions (by programId)
   - programWeeks (by programId)
3. Inserts weeks with new orderIndex values
4. Inserts sessions ONCE at program level (from first week)
5. Inserts exercise groups and items for each session
6. Inserts prescriptions for each (item, week) combination
7. Updates program metadata

**loadProgramAggregate:**
1. Loads program row with organization filter
2. Loads weeks, sessions, groups, exercises, prescriptions in parallel queries
3. Builds lookup maps:
   - `groupsBySession: Map<sessionId, ExerciseGroupRow[]>`
   - `exercisesByGroup: Map<groupId, ExerciseRowDb[]>`
   - `prescriptionsByKey: Map<"exerciseId:weekId", PrescriptionRow>`
4. Reconstructs Week[] with Session[] with ExerciseGroup[] with GroupItem[] with Series[]
5. Handles ungrouped exercises as synthetic single-item groups
6. Uses `reconstituteProgram()` from domain layer

**Helper Functions:**
- `mapIntensityTypeToUnit()` - converts domain IntensityType to DB unit
- `mapDbIntensityType()` - converts DB intensityType to domain type

## Deviations from Plan

None - plan executed exactly as written.

## Dependencies Met

- 03.4-01: Program aggregate with `createProgram()` and `reconstituteProgram()` - **USED**

## Next Phase Readiness

Ready for:
- 03.4-04: New use cases that leverage aggregate persistence
- 03.4-05: Migration of existing use cases to aggregate pattern
