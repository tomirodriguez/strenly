---
phase: 03.4-domain-restructure-training-programs
plan: 03
type: execute
wave: 2
depends_on: ["03.4-01"]
files_modified:
  - packages/core/src/ports/program-repository.port.ts
  - packages/backend/src/infrastructure/repositories/program.repository.ts
autonomous: true

must_haves:
  truths:
    - "saveProgramAggregate() replaces entire program hierarchy atomically"
    - "DELETE + INSERT strategy in single transaction"
    - "loadProgramAggregate() returns full Program with nested hierarchy"
    - "Repository uses reconstitute for DB loads"
  artifacts:
    - path: "packages/core/src/ports/program-repository.port.ts"
      provides: "Aggregate-based repository port with saveProgramAggregate and loadProgramAggregate"
      exports: ["ProgramRepositoryPort", "saveProgramAggregate", "loadProgramAggregate"]
    - path: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      provides: "Implementation of aggregate persistence"
      contains: "db.transaction"
  key_links:
    - from: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      to: "packages/core/src/domain/entities/program/program.ts"
      via: "reconstitute on load"
      pattern: "reconstituteProgram"
---

<objective>
Add aggregate-based persistence methods to the repository: saveProgramAggregate() and loadProgramAggregate(). These implement the DELETE + INSERT replace-on-save strategy.

Purpose: Enable saving the entire Program aggregate in one atomic transaction. The save operation deletes all existing children and re-inserts the full hierarchy. This is simpler than tracking changes and guarantees data consistency.

Output: Updated repository port with aggregate methods and implementation with transaction support.
</objective>

<db_schema_clarification>
**CRITICAL: Understanding the DB schema structure**

The domain aggregate nests sessions under weeks for convenience:
```
Program -> weeks[] -> sessions[] -> groups[] -> items[] -> series[]
```

But the DATABASE stores sessions at the PROGRAM level, not the week level:
```sql
program_sessions: (id, programId, name, orderIndex)  -- linked to program, NOT to week
prescriptions: (id, programExerciseId, weekId, series)  -- series varies PER WEEK
```

**Why this works:**
1. Sessions represent training DAYS (Monday, Tuesday, etc.)
2. Sessions are SHARED across all weeks - same structure, different prescriptions
3. What varies per week is the PRESCRIPTION for each exercise (the series array)
4. Key: prescriptions table has (programExerciseId, weekId) as unique constraint

**On SAVE:**
1. Delete all children (sessions, groups, exercises, prescriptions)
2. Insert sessions once (linked to program)
3. For each week, insert prescriptions for each exercise
   - Same session structure, but prescription.weekId varies

**On LOAD:**
1. Load sessions (program level)
2. Load prescriptions grouped by weekId
3. Reconstitute: for each week, attach sessions with that week's prescriptions
</db_schema_clarification>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-01-SUMMARY.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-RESEARCH.md

# Current repository implementation
@packages/backend/src/infrastructure/repositories/program.repository.ts
@packages/core/src/ports/program-repository.port.ts

# Database schema
@packages/database/src/schema/programs.ts
@packages/database/src/schema/program-weeks.ts
@packages/database/src/schema/program-sessions.ts
@packages/database/src/schema/exercise-groups.ts
@packages/database/src/schema/program-exercises.ts
@packages/database/src/schema/prescriptions.ts

# New aggregate types
@packages/core/src/domain/entities/program/program.ts
@packages/core/src/domain/entities/program/types.ts
</context>

<skills>
/repository - Repository implementation patterns with Drizzle ORM
/port - Repository interface definition patterns
</skills>

<tasks>

<task type="auto">
  <name>Task 1: Update Repository Port with Aggregate Methods</name>
  <files>packages/core/src/ports/program-repository.port.ts</files>
  <action>
    Update the repository port to add aggregate-based methods while keeping existing methods for backward compatibility (they'll be deprecated later).

    Add these NEW methods to ProgramRepositoryPort:

    ```typescript
    // ---------------------------------------------------------------------------
    // Aggregate Operations (NEW - Primary Interface)
    // ---------------------------------------------------------------------------

    /**
     * Load a complete program aggregate with full hierarchy
     * Used for editing - returns Program with weeks/sessions/groups/items/series
     */
    loadProgramAggregate(
      ctx: OrganizationContext,
      programId: string,
    ): ResultAsync<Program, ProgramRepositoryError>

    /**
     * Save a complete program aggregate (replace-on-save)
     * Deletes all children and re-inserts the entire hierarchy atomically
     * Used after client edits to persist the complete state
     */
    saveProgramAggregate(
      ctx: OrganizationContext,
      program: Program,
    ): ResultAsync<{ updatedAt: Date }, ProgramRepositoryError>
    ```

    Also update imports:
    - Import Program from '../domain/entities/program/program'
    - Import ProgramStatus from '../domain/entities/program/types'

    Keep existing methods (findById, list, create, etc.) for backward compatibility with existing use cases. Mark them with @deprecated JSDoc comments noting they'll be removed in future.

    Note: Existing saveDraft method will remain temporarily but the new saveProgramAggregate is the preferred approach.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/core
    ```
  </verify>
  <done>
    Repository port has loadProgramAggregate and saveProgramAggregate methods defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement saveProgramAggregate in Repository</name>
  <files>packages/backend/src/infrastructure/repositories/program.repository.ts</files>
  <action>
    Implement saveProgramAggregate using DELETE + INSERT strategy in a db.transaction.

    **Approach (reference db_schema_clarification above):**

    1. **Verify ownership:** Check program exists and belongs to organization
    2. **Delete all children in order:** prescriptions (by weekId) -> programExercises (by sessionId) -> exerciseGroups (by sessionId) -> programSessions (by programId) -> programWeeks (by programId)
    3. **Insert weeks:** Insert all weeks from program.weeks array
    4. **Insert sessions ONCE:** Sessions are stored at program level. Take sessions from first week (all weeks have same structure) and insert with programId
    5. **Insert groups and exercises:** For each session, insert its exerciseGroups and their items (programExercises)
    6. **Insert prescriptions per week:** For each week, for each exercise item, insert a prescription row with that weekId and the item's series array
    7. **Update program metadata:** Update name, description, athleteId, isTemplate, status, updatedAt

    **Key details:**
    - Use db.transaction(async (tx) => {...}) for atomicity
    - Generate prescription IDs with crypto.randomUUID()
    - Map IntensityType to intensityUnit ('absolute' -> 'kg', 'percentage' -> '%', 'rpe' -> 'rpe', 'rir' -> 'rir')
    - Return { updatedAt: Date } on success
    - Wrap errors with wrapDbError helper

    Reference the existing repository patterns for delete/insert syntax with Drizzle.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    saveProgramAggregate implemented with DELETE + INSERT transaction strategy.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement loadProgramAggregate in Repository</name>
  <files>packages/backend/src/infrastructure/repositories/program.repository.ts</files>
  <action>
    Implement loadProgramAggregate to fetch the complete hierarchy and reconstitute the domain aggregate.

    **Approach (reference db_schema_clarification above):**

    1. **Load program row:** Query programs table with programId and organizationId filter
    2. **Load weeks:** Query programWeeks by programId, ordered by orderIndex
    3. **Load sessions:** Query programSessions by programId, ordered by orderIndex (sessions are at program level)
    4. **Load groups:** Query exerciseGroups by sessionIds, ordered by orderIndex
    5. **Load exercises:** Query programExercises by sessionIds, ordered by orderIndex
    6. **Load prescriptions:** Query prescriptions by weekIds AND programExerciseIds
    7. **Build lookup maps:** Create prescriptionsByKey Map with key `${exerciseId}:${weekId}`, groupsBySession, exercisesByGroup
    8. **Reconstitute hierarchy:** For each week, clone the session structure and attach that week's prescriptions to each item
    9. **Call reconstituteProgram:** Pass the assembled data to the domain's reconstitute function

    **Key details:**
    - Use efficient queries (inArray for batch lookups)
    - Map series data from prescriptions to Series[] type, casting intensityType appropriately
    - Each week gets the SAME session/group/item structure but with DIFFERENT series (from prescriptions)
    - Return the reconstructed Program domain aggregate
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    loadProgramAggregate implemented, fetches full hierarchy and reconstitutes domain aggregate.
  </done>
</task>

</tasks>

<verification>
```bash
# Type check both packages
cd /Users/tomiardz/Projects/treino && pnpm typecheck

# Verify the methods exist in port
grep -q "loadProgramAggregate" packages/core/src/ports/program-repository.port.ts
grep -q "saveProgramAggregate" packages/core/src/ports/program-repository.port.ts

# Verify implementation exists in repository
grep -q "loadProgramAggregate" packages/backend/src/infrastructure/repositories/program.repository.ts
grep -q "saveProgramAggregate" packages/backend/src/infrastructure/repositories/program.repository.ts
grep -q "db.transaction" packages/backend/src/infrastructure/repositories/program.repository.ts
```
</verification>

<success_criteria>
- Port defines loadProgramAggregate and saveProgramAggregate
- Repository implements both methods
- saveProgramAggregate uses DELETE + INSERT in transaction
- loadProgramAggregate returns full Program aggregate with nested data
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-domain-restructure-training-programs/03.4-03-SUMMARY.md`
</output>
