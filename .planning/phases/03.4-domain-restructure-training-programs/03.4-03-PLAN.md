---
phase: 03.4-domain-restructure-training-programs
plan: 03
type: execute
wave: 2
depends_on: ["03.4-01"]
files_modified:
  - packages/core/src/ports/program-repository.port.ts
  - packages/backend/src/infrastructure/repositories/program.repository.ts
autonomous: true

must_haves:
  truths:
    - "saveProgramAggregate() replaces entire program hierarchy atomically"
    - "DELETE + INSERT strategy in single transaction"
    - "loadProgramAggregate() returns full Program with nested hierarchy"
    - "Repository uses reconstitute for DB loads"
  artifacts:
    - path: "packages/core/src/ports/program-repository.port.ts"
      provides: "Aggregate-based repository port with saveProgramAggregate and loadProgramAggregate"
      exports: ["ProgramRepositoryPort", "saveProgramAggregate", "loadProgramAggregate"]
    - path: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      provides: "Implementation of aggregate persistence"
      contains: "db.transaction"
  key_links:
    - from: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      to: "packages/core/src/domain/entities/program/program.ts"
      via: "reconstitute on load"
      pattern: "reconstituteProgram"
---

<objective>
Add aggregate-based persistence methods to the repository: saveProgramAggregate() and loadProgramAggregate(). These implement the DELETE + INSERT replace-on-save strategy.

Purpose: Enable saving the entire Program aggregate in one atomic transaction. The save operation deletes all existing children and re-inserts the full hierarchy. This is simpler than tracking changes and guarantees data consistency.

Output: Updated repository port with aggregate methods and implementation with transaction support.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-01-SUMMARY.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-RESEARCH.md

# Current repository implementation
@packages/backend/src/infrastructure/repositories/program.repository.ts
@packages/core/src/ports/program-repository.port.ts

# Database schema
@packages/database/src/schema/programs.ts
@packages/database/src/schema/program-weeks.ts
@packages/database/src/schema/program-sessions.ts
@packages/database/src/schema/exercise-groups.ts
@packages/database/src/schema/program-exercises.ts
@packages/database/src/schema/prescriptions.ts

# New aggregate types
@packages/core/src/domain/entities/program/program.ts
@packages/core/src/domain/entities/program/types.ts
</context>

<skills>
/repository - Repository implementation patterns with Drizzle ORM
/port - Repository interface definition patterns
</skills>

<tasks>

<task type="auto">
  <name>Task 1: Update Repository Port with Aggregate Methods</name>
  <files>packages/core/src/ports/program-repository.port.ts</files>
  <action>
    Update the repository port to add aggregate-based methods while keeping existing methods for backward compatibility (they'll be deprecated later).

    Add these NEW methods to ProgramRepositoryPort:

    ```typescript
    // ---------------------------------------------------------------------------
    // Aggregate Operations (NEW - Primary Interface)
    // ---------------------------------------------------------------------------

    /**
     * Load a complete program aggregate with full hierarchy
     * Used for editing - returns Program with weeks/sessions/groups/items/series
     */
    loadProgramAggregate(
      ctx: OrganizationContext,
      programId: string,
    ): ResultAsync<Program, ProgramRepositoryError>

    /**
     * Save a complete program aggregate (replace-on-save)
     * Deletes all children and re-inserts the entire hierarchy atomically
     * Used after client edits to persist the complete state
     */
    saveProgramAggregate(
      ctx: OrganizationContext,
      program: Program,
    ): ResultAsync<{ updatedAt: Date }, ProgramRepositoryError>
    ```

    Also update imports:
    - Import Program from '../domain/entities/program/program'
    - Import ProgramStatus from '../domain/entities/program/types'

    Keep existing methods (findById, list, create, etc.) for backward compatibility with existing use cases. Mark them with @deprecated JSDoc comments noting they'll be removed in future.

    Note: Existing saveDraft method will remain temporarily but the new saveProgramAggregate is the preferred approach.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/core
    ```
  </verify>
  <done>
    Repository port has loadProgramAggregate and saveProgramAggregate methods defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement saveProgramAggregate in Repository</name>
  <files>packages/backend/src/infrastructure/repositories/program.repository.ts</files>
  <action>
    Implement the saveProgramAggregate method using DELETE + INSERT strategy in a transaction.

    Implementation outline:

    ```typescript
    saveProgramAggregate(
      ctx: OrganizationContext,
      program: Program,
    ): ResultAsync<{ updatedAt: Date }, ProgramRepositoryError> {
      return RA.fromPromise(
        (async () => {
          const updatedAt = new Date()

          await db.transaction(async (tx) => {
            // 1. Verify program belongs to organization
            const existing = await tx.select({ id: programs.id })
              .from(programs)
              .where(and(
                eq(programs.id, program.id),
                eq(programs.organizationId, ctx.organizationId)
              ))
              .limit(1)

            if (existing.length === 0) {
              throw new Error('NOT_FOUND')
            }

            // 2. Delete all children (CASCADE handles prescriptions)
            // Delete program_exercises first (references sessions)
            await tx.delete(programExercises).where(
              inArray(programExercises.sessionId,
                tx.select({ id: programSessions.id })
                  .from(programSessions)
                  .where(eq(programSessions.programId, program.id))
              )
            )

            // Delete exercise_groups
            await tx.delete(exerciseGroups).where(
              inArray(exerciseGroups.sessionId,
                tx.select({ id: programSessions.id })
                  .from(programSessions)
                  .where(eq(programSessions.programId, program.id))
              )
            )

            // Delete prescriptions (by week)
            await tx.delete(prescriptions).where(
              inArray(prescriptions.weekId,
                tx.select({ id: programWeeks.id })
                  .from(programWeeks)
                  .where(eq(programWeeks.programId, program.id))
              )
            )

            // Delete sessions
            await tx.delete(programSessions).where(
              eq(programSessions.programId, program.id)
            )

            // Delete weeks
            await tx.delete(programWeeks).where(
              eq(programWeeks.programId, program.id)
            )

            // 3. Insert weeks
            for (const week of program.weeks) {
              await tx.insert(programWeeks).values({
                id: week.id,
                programId: program.id,
                name: week.name,
                orderIndex: week.orderIndex,
                createdAt: updatedAt,
                updatedAt,
              })
            }

            // 4. Insert sessions (linked to program, not week)
            // Note: Current schema has sessions linked to program
            for (const week of program.weeks) {
              for (const session of week.sessions) {
                await tx.insert(programSessions).values({
                  id: session.id,
                  programId: program.id,
                  name: session.name,
                  orderIndex: session.orderIndex,
                  createdAt: updatedAt,
                  updatedAt,
                })

                // 5. Insert exercise groups
                for (const group of session.exerciseGroups) {
                  await tx.insert(exerciseGroups).values({
                    id: group.id,
                    sessionId: session.id,
                    orderIndex: group.orderIndex,
                    name: group.name,
                    createdAt: updatedAt,
                    updatedAt,
                  })

                  // 6. Insert group items (program_exercises)
                  for (const item of group.items) {
                    await tx.insert(programExercises).values({
                      id: item.id,
                      sessionId: session.id,
                      exerciseId: item.exerciseId,
                      orderIndex: item.orderIndex,
                      groupId: group.id,
                      orderWithinGroup: item.orderIndex,
                      setTypeLabel: null,
                      notes: null,
                      restSeconds: null,
                      createdAt: updatedAt,
                      updatedAt,
                    })

                    // 7. Insert prescriptions (series per exercise per week)
                    if (item.series.length > 0) {
                      await tx.insert(prescriptions).values({
                        id: `rx-${crypto.randomUUID()}`,
                        programExerciseId: item.id,
                        weekId: week.id,
                        series: item.series.map((s, i) => ({
                          orderIndex: i,
                          reps: s.reps,
                          repsMax: s.repsMax,
                          isAmrap: s.isAmrap,
                          intensityType: s.intensityType,
                          intensityValue: s.intensityValue,
                          intensityUnit: mapIntensityTypeToUnit(s.intensityType),
                          tempo: s.tempo,
                          restSeconds: s.restSeconds,
                        })),
                        createdAt: updatedAt,
                        updatedAt,
                      })
                    }
                  }
                }
              }
            }

            // 8. Update program metadata
            await tx.update(programs).set({
              name: program.name,
              description: program.description,
              athleteId: program.athleteId,
              isTemplate: program.isTemplate,
              status: program.status,
              updatedAt,
            }).where(eq(programs.id, program.id))
          })

          return { updatedAt }
        })(),
        (e) => wrapDbError(e),
      )
    }
    ```

    Helper function for intensity unit mapping:
    ```typescript
    function mapIntensityTypeToUnit(type: IntensityType | null): 'kg' | 'lb' | '%' | 'rpe' | 'rir' | null {
      if (!type) return null
      switch (type) {
        case 'absolute': return 'kg' // Default to kg
        case 'percentage': return '%'
        case 'rpe': return 'rpe'
        case 'rir': return 'rir'
      }
    }
    ```
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    saveProgramAggregate implemented with DELETE + INSERT transaction strategy.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement loadProgramAggregate in Repository</name>
  <files>packages/backend/src/infrastructure/repositories/program.repository.ts</files>
  <action>
    Implement loadProgramAggregate to fetch complete program hierarchy and reconstruct domain aggregate.

    Implementation outline:

    ```typescript
    loadProgramAggregate(
      ctx: OrganizationContext,
      programId: string,
    ): ResultAsync<Program, ProgramRepositoryError> {
      return RA.fromPromise(
        (async () => {
          // 1. Load program
          const programRow = await db.select()
            .from(programs)
            .where(and(
              eq(programs.id, programId),
              eq(programs.organizationId, ctx.organizationId)
            ))
            .limit(1)

          if (programRow.length === 0) {
            throw { type: 'NOT_FOUND', entityType: 'program', id: programId }
          }

          const prog = programRow[0]

          // 2. Load weeks
          const weeksRows = await db.select()
            .from(programWeeks)
            .where(eq(programWeeks.programId, programId))
            .orderBy(asc(programWeeks.orderIndex))

          // 3. Load sessions
          const sessionsRows = await db.select()
            .from(programSessions)
            .where(eq(programSessions.programId, programId))
            .orderBy(asc(programSessions.orderIndex))

          // 4. Load groups
          const sessionIds = sessionsRows.map(s => s.id)
          const groupsRows = sessionIds.length > 0
            ? await db.select()
                .from(exerciseGroups)
                .where(inArray(exerciseGroups.sessionId, sessionIds))
                .orderBy(asc(exerciseGroups.orderIndex))
            : []

          // 5. Load exercise rows
          const exercisesRows = sessionIds.length > 0
            ? await db.select({
                id: programExercises.id,
                sessionId: programExercises.sessionId,
                exerciseId: programExercises.exerciseId,
                orderIndex: programExercises.orderIndex,
                groupId: programExercises.groupId,
                orderWithinGroup: programExercises.orderWithinGroup,
              })
              .from(programExercises)
              .where(inArray(programExercises.sessionId, sessionIds))
              .orderBy(asc(programExercises.orderIndex))
            : []

          // 6. Load prescriptions
          const weekIds = weeksRows.map(w => w.id)
          const exerciseIds = exercisesRows.map(e => e.id)
          const prescriptionsRows = (weekIds.length > 0 && exerciseIds.length > 0)
            ? await db.select()
                .from(prescriptions)
                .where(and(
                  inArray(prescriptions.weekId, weekIds),
                  inArray(prescriptions.programExerciseId, exerciseIds)
                ))
            : []

          // 7. Build hierarchy and reconstitute
          // Group data by parent IDs for efficient lookup
          const prescriptionsByKey = new Map<string, typeof prescriptionsRows[0]>()
          for (const rx of prescriptionsRows) {
            prescriptionsByKey.set(`${rx.programExerciseId}:${rx.weekId}`, rx)
          }

          const exercisesBySession = groupBy(exercisesRows, 'sessionId')
          const groupsBySession = groupBy(groupsRows, 'sessionId')

          // Build weeks with nested hierarchy
          const weeks = weeksRows.map(weekRow => {
            // For this week, build sessions
            const sessions = sessionsRows.map(sessionRow => {
              const sessionGroups = groupsBySession[sessionRow.id] ?? []
              const sessionExercises = exercisesBySession[sessionRow.id] ?? []

              // Group exercises by groupId
              const exercisesByGroup = groupBy(sessionExercises, 'groupId')

              const exerciseGroups = sessionGroups.map(groupRow => {
                const groupExercises = exercisesByGroup[groupRow.id] ?? []

                const items = groupExercises.map(exRow => {
                  // Get prescription for this exercise in this week
                  const rx = prescriptionsByKey.get(`${exRow.id}:${weekRow.id}`)
                  const series = rx?.series ?? []

                  return {
                    id: exRow.id,
                    exerciseId: exRow.exerciseId,
                    orderIndex: exRow.orderWithinGroup ?? exRow.orderIndex,
                    series: series.map(s => ({
                      orderIndex: s.orderIndex,
                      reps: s.reps,
                      repsMax: s.repsMax,
                      isAmrap: s.isAmrap,
                      intensityType: mapUnitToIntensityType(s.intensityType, s.intensityUnit),
                      intensityValue: s.intensityValue,
                      tempo: s.tempo,
                      restSeconds: s.restSeconds,
                    })),
                  }
                })

                return {
                  id: groupRow.id,
                  name: groupRow.name,
                  orderIndex: groupRow.orderIndex,
                  items,
                }
              })

              return {
                id: sessionRow.id,
                name: sessionRow.name,
                orderIndex: sessionRow.orderIndex,
                exerciseGroups,
              }
            })

            return {
              id: weekRow.id,
              name: weekRow.name,
              orderIndex: weekRow.orderIndex,
              sessions,
            }
          })

          // 8. Reconstitute aggregate
          return reconstituteProgram({
            id: prog.id,
            organizationId: prog.organizationId,
            name: prog.name,
            description: prog.description,
            athleteId: prog.athleteId,
            isTemplate: prog.isTemplate,
            status: prog.status as ProgramStatus,
            weeks,
            createdAt: prog.createdAt,
            updatedAt: prog.updatedAt,
          })
        })(),
        (e) => wrapDbError(e),
      )
    }
    ```

    Add helper function for grouping:
    ```typescript
    function groupBy<T>(arr: T[], key: keyof T): Record<string, T[]> {
      return arr.reduce((acc, item) => {
        const k = String(item[key])
        if (!acc[k]) acc[k] = []
        acc[k].push(item)
        return acc
      }, {} as Record<string, T[]>)
    }
    ```

    Add helper for intensity type mapping from DB:
    ```typescript
    function mapUnitToIntensityType(
      type: string | null,
      unit: string | null
    ): IntensityType | null {
      if (!type) return null
      return type as IntensityType
    }
    ```
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    loadProgramAggregate implemented, fetches full hierarchy and reconstitutes domain aggregate.
  </done>
</task>

</tasks>

<verification>
```bash
# Type check both packages
cd /Users/tomiardz/Projects/treino && pnpm typecheck

# Verify the methods exist in port
grep -q "loadProgramAggregate" packages/core/src/ports/program-repository.port.ts
grep -q "saveProgramAggregate" packages/core/src/ports/program-repository.port.ts

# Verify implementation exists in repository
grep -q "loadProgramAggregate" packages/backend/src/infrastructure/repositories/program.repository.ts
grep -q "saveProgramAggregate" packages/backend/src/infrastructure/repositories/program.repository.ts
grep -q "db.transaction" packages/backend/src/infrastructure/repositories/program.repository.ts
```
</verification>

<success_criteria>
- Port defines loadProgramAggregate and saveProgramAggregate
- Repository implements both methods
- saveProgramAggregate uses DELETE + INSERT in transaction
- loadProgramAggregate returns full Program aggregate with nested data
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-domain-restructure-training-programs/03.4-03-SUMMARY.md`
</output>
