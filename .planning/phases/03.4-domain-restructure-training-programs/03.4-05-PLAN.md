---
phase: 03.4-domain-restructure-training-programs
plan: 05
type: execute
wave: 3
depends_on: ["03.4-02", "03.4-03"]
files_modified:
  - packages/contracts/src/programs/save-draft.ts
  - packages/contracts/src/programs/program.ts
  - packages/backend/src/procedures/programs/save-draft.ts
  - packages/backend/src/procedures/programs/get-program.ts
autonomous: true

must_haves:
  truths:
    - "saveDraft contract accepts full program aggregate input"
    - "getProgram contract returns full program aggregate output"
    - "Procedures wire to updated use cases"
    - "API validation uses Zod schemas matching aggregate structure"
  artifacts:
    - path: "packages/contracts/src/programs/save-draft.ts"
      provides: "Updated schema for aggregate input"
      exports: ["saveDraftInputSchema", "saveDraftOutputSchema"]
    - path: "packages/contracts/src/programs/program.ts"
      provides: "Program aggregate schema for API"
      exports: ["programSchema", "programOutputSchema"]
  key_links:
    - from: "packages/backend/src/procedures/programs/save-draft.ts"
      to: "packages/contracts/src/programs/save-draft.ts"
      via: "input validation"
      pattern: "saveDraftInputSchema"
---

<objective>
Update API contracts and procedures to accept/return the full Program aggregate structure. The saveDraft endpoint now receives the complete program, not delta changes.

Purpose: Align the API layer with the aggregate pattern. The frontend will send the complete program on save, and receive the complete program on load.

Output: Updated Zod schemas for aggregate structure and procedures wired to use cases.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-03-SUMMARY.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-04-SUMMARY.md

# Current contracts
@packages/contracts/src/programs/save-draft.ts
@packages/contracts/src/programs/program.ts
@packages/contracts/src/programs/prescription.ts

# Current procedures
@packages/backend/src/procedures/programs/save-draft.ts

# New aggregate types
@packages/core/src/domain/entities/program/types.ts
</context>

<skills>
/contracts - Zod schema patterns
/procedure - oRPC procedure patterns
</skills>

<tasks>

<task type="auto">
  <name>Task 1: Create Aggregate Zod Schemas</name>
  <files>
    packages/contracts/src/programs/program.ts
    packages/contracts/src/programs/save-draft.ts
  </files>
  <action>
    Create Zod schemas that match the Program aggregate structure.

    **Update packages/contracts/src/programs/program.ts:**

    ```typescript
    import { z } from 'zod'

    // Status enum
    export const programStatusSchema = z.enum(['draft', 'active', 'archived'])
    export type ProgramStatus = z.infer<typeof programStatusSchema>

    // Intensity type enum
    export const intensityTypeSchema = z.enum(['absolute', 'percentage', 'rpe', 'rir'])
    export type IntensityType = z.infer<typeof intensityTypeSchema>

    // Series schema (individual set)
    export const seriesSchema = z.object({
      orderIndex: z.number().int().min(0),
      reps: z.number().int().min(0).nullable(),
      repsMax: z.number().int().min(0).nullable(),
      isAmrap: z.boolean(),
      intensityType: intensityTypeSchema.nullable(),
      intensityValue: z.number().nullable(),
      tempo: z.string().regex(/^[\dXx]{4}$/).nullable().optional(),
      restSeconds: z.number().int().min(0).nullable(),
    })
    export type Series = z.infer<typeof seriesSchema>

    // Group item schema (exercise in a group)
    export const groupItemSchema = z.object({
      id: z.string(),
      exerciseId: z.string(),
      orderIndex: z.number().int().min(0),
      series: z.array(seriesSchema),
    })
    export type GroupItem = z.infer<typeof groupItemSchema>

    // Exercise group schema
    export const exerciseGroupSchema = z.object({
      id: z.string(),
      name: z.string().nullable(),
      orderIndex: z.number().int().min(0),
      items: z.array(groupItemSchema),
    })
    export type ExerciseGroup = z.infer<typeof exerciseGroupSchema>

    // Session schema
    export const sessionSchema = z.object({
      id: z.string(),
      name: z.string().min(1),
      orderIndex: z.number().int().min(0),
      exerciseGroups: z.array(exerciseGroupSchema),
    })
    export type Session = z.infer<typeof sessionSchema>

    // Week schema
    export const weekSchema = z.object({
      id: z.string(),
      name: z.string(),
      orderIndex: z.number().int().min(0),
      sessions: z.array(sessionSchema),
    })
    export type Week = z.infer<typeof weekSchema>

    // Full program aggregate schema (for output)
    export const programSchema = z.object({
      id: z.string(),
      organizationId: z.string(),
      name: z.string().min(3).max(100),
      description: z.string().nullable(),
      athleteId: z.string().nullable(),
      isTemplate: z.boolean(),
      status: programStatusSchema,
      weeks: z.array(weekSchema),
      createdAt: z.coerce.date(),
      updatedAt: z.coerce.date(),
    })
    export type Program = z.infer<typeof programSchema>

    // Program input (for create/update - without id, organizationId, timestamps)
    export const programInputSchema = z.object({
      name: z.string().min(3).max(100),
      description: z.string().nullable().optional(),
      athleteId: z.string().nullable().optional(),
      isTemplate: z.boolean().optional(),
      status: programStatusSchema.optional(),
      weeks: z.array(weekSchema).optional(),
    })
    export type ProgramInput = z.infer<typeof programInputSchema>

    // Existing list/create schemas - keep for backward compatibility
    export const listProgramsInputSchema = z.object({
      status: programStatusSchema.optional(),
      athleteId: z.string().nullable().optional(),
      isTemplate: z.boolean().optional(),
      search: z.string().optional(),
      limit: z.number().int().min(1).max(100).optional(),
      offset: z.number().int().min(0).optional(),
    })

    export const createProgramInputSchema = z.object({
      name: z.string().min(3, { message: 'El nombre debe tener al menos 3 caracteres' })
        .max(100, { message: 'El nombre no puede exceder 100 caracteres' }),
      description: z.string().nullable().optional(),
      athleteId: z.string().nullable().optional(),
      isTemplate: z.boolean().optional(),
      weeksCount: z.number().int().min(1).max(12).optional(),
      sessionsCount: z.number().int().min(1).max(7).optional(),
    })
    ```

    **Update packages/contracts/src/programs/save-draft.ts:**

    ```typescript
    import { z } from 'zod'
    import { weekSchema } from './program'

    // Save draft now accepts the complete program aggregate
    export const saveDraftInputSchema = z.object({
      programId: z.string(),
      program: z.object({
        name: z.string().min(3).max(100),
        description: z.string().nullable().optional(),
        athleteId: z.string().nullable().optional(),
        isTemplate: z.boolean().optional(),
        status: z.enum(['draft', 'active', 'archived']).optional(),
        weeks: z.array(weekSchema),
      }),
    })
    export type SaveDraftInput = z.infer<typeof saveDraftInputSchema>

    export const saveDraftOutputSchema = z.object({
      updatedAt: z.coerce.date(),
    })
    export type SaveDraftOutput = z.infer<typeof saveDraftOutputSchema>
    ```

    Keep the existing prescription.ts schemas for backward compatibility with any components that still use them.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/contracts
    ```
  </verify>
  <done>
    Zod schemas for Program aggregate created in contracts package.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update saveDraft Procedure</name>
  <files>packages/backend/src/procedures/programs/save-draft.ts</files>
  <action>
    Update the saveDraft procedure to use the new schema and use case.

    ```typescript
    import { saveDraftInputSchema, saveDraftOutputSchema } from '@strenly/contracts/programs/save-draft'
    import { protectedProcedure } from '../../lib/procedure'
    import { saveDraftUseCase } from '../../use-cases/programs/save-draft'
    import { createProgramRepository } from '../../infrastructure/repositories/program.repository'

    export const saveDraft = protectedProcedure
      .input(saveDraftInputSchema)
      .output(saveDraftOutputSchema)
      .mutation(async ({ input, ctx }) => {
        const repository = createProgramRepository()

        const result = await saveDraftUseCase(ctx, input, {
          programRepository: repository,
        })

        if (result.isErr()) {
          const error = result.error
          switch (error.type) {
            case 'UNAUTHORIZED':
              throw new Error('No tienes permiso para editar este programa')
            case 'VALIDATION_ERROR':
              throw new Error(error.message)
            case 'NOT_FOUND':
              throw new Error('Programa no encontrado')
            case 'DATABASE_ERROR':
              throw new Error('Error al guardar el programa')
          }
        }

        return result.value
      })
    ```

    The procedure is now simpler - it receives the full aggregate and passes it to the use case.
    No more complex delta tracking or tempId resolution in the procedure layer.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    saveDraft procedure uses new aggregate schema and use case.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update getProgram Procedure</name>
  <files>packages/backend/src/procedures/programs/get-program.ts</files>
  <action>
    Update getProgram procedure to return full aggregate using programSchema.

    Check the existing procedure location (might be in different file like index.ts or a sub-router).
    Look for the procedure that handles GET /programs/:id or similar.

    ```typescript
    import { z } from 'zod'
    import { programSchema } from '@strenly/contracts/programs/program'
    import { protectedProcedure } from '../../lib/procedure'
    import { getProgramUseCase } from '../../use-cases/programs/get-program'
    import { createProgramRepository } from '../../infrastructure/repositories/program.repository'

    export const getProgram = protectedProcedure
      .input(z.object({ programId: z.string() }))
      .output(programSchema)
      .query(async ({ input, ctx }) => {
        const repository = createProgramRepository()

        const result = await getProgramUseCase(ctx, input, {
          programRepository: repository,
        })

        if (result.isErr()) {
          const error = result.error
          switch (error.type) {
            case 'UNAUTHORIZED':
              throw new Error('No tienes permiso para ver este programa')
            case 'NOT_FOUND':
              throw new Error('Programa no encontrado')
            case 'DATABASE_ERROR':
              throw new Error('Error al cargar el programa')
          }
        }

        return result.value
      })
    ```

    If there's a separate `getProgramForGrid` or `findWithDetails` procedure, either:
    1. Update it to use loadProgramAggregate and return programSchema
    2. Or deprecate it in favor of the standard getProgram

    The aggregate now contains all the data needed for the grid.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    getProgram procedure returns full Program aggregate.
  </done>
</task>

</tasks>

<verification>
```bash
# Type check all affected packages
cd /Users/tomiardz/Projects/treino && pnpm typecheck

# Verify schemas exist
grep -q "programSchema" packages/contracts/src/programs/program.ts
grep -q "weekSchema" packages/contracts/src/programs/program.ts
grep -q "saveDraftInputSchema" packages/contracts/src/programs/save-draft.ts

# Verify procedures use new schemas
grep -q "saveDraftInputSchema" packages/backend/src/procedures/programs/save-draft.ts
```
</verification>

<success_criteria>
- programSchema defines full aggregate structure with weeks/sessions/groups/items/series
- saveDraftInputSchema accepts complete program
- Procedures use updated schemas
- TypeScript compiles without errors
- API contract matches domain aggregate structure
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-domain-restructure-training-programs/03.4-05-SUMMARY.md`
</output>
