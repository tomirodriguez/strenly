---
phase: 03.4-domain-restructure-training-programs
plan: 04
type: execute
wave: 3
depends_on: ["03.4-03"]
files_modified:
  - packages/backend/src/use-cases/programs/save-draft.ts
  - packages/backend/src/use-cases/programs/get-program.ts
  - packages/backend/src/use-cases/programs/create-program.ts
  - packages/backend/src/use-cases/programs/duplicate-program.ts
autonomous: true

must_haves:
  truths:
    - "saveDraft use case receives aggregate and validates via createProgram()"
    - "getProgram use case returns full aggregate from loadProgramAggregate()"
    - "createProgram use case validates via domain entity factory"
    - "duplicateProgram use case works with aggregate structure"
  artifacts:
    - path: "packages/backend/src/use-cases/programs/save-draft.ts"
      provides: "Updated use case that validates and saves aggregate"
      contains: "createProgram"
    - path: "packages/backend/src/use-cases/programs/get-program.ts"
      provides: "Use case returning full aggregate"
      contains: "loadProgramAggregate"
  key_links:
    - from: "packages/backend/src/use-cases/programs/save-draft.ts"
      to: "packages/core/src/domain/entities/program/program.ts"
      via: "createProgram validation"
      pattern: "createProgram"
    - from: "packages/backend/src/use-cases/programs/get-program.ts"
      to: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      via: "loadProgramAggregate call"
      pattern: "loadProgramAggregate"
---

<objective>
Update use cases to work with the Program aggregate. The saveDraft use case validates the complete aggregate via createProgram() before saving. The getProgram use case returns the full aggregate.

Purpose: Ensure business logic layer uses the aggregate pattern correctly. Validation happens through the domain entity factory, persistence through the aggregate repository methods.

Output: Updated use cases that validate and persist using aggregate pattern.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-01-SUMMARY.md
@.planning/phases/03.4-domain-restructure-training-programs/03.4-03-SUMMARY.md

# Current use cases
@packages/backend/src/use-cases/programs/save-draft.ts
@packages/backend/src/use-cases/programs/get-program.ts
@packages/backend/src/use-cases/programs/create-program.ts

# New aggregate
@packages/core/src/domain/entities/program/program.ts
@packages/core/src/domain/entities/program/types.ts
</context>

<skills>
/use-case - Use case implementation patterns
/authorization - Permission checking patterns
</skills>

<tasks>

<task type="auto">
  <name>Task 1: Update saveDraft Use Case for Aggregate</name>
  <files>packages/backend/src/use-cases/programs/save-draft.ts</files>
  <action>
    Refactor the saveDraft use case to:

    1. Receive complete program aggregate input (not delta changes)
    2. Validate via createProgram() domain factory
    3. Save via saveProgramAggregate() repository method

    The new flow:

    ```typescript
    import { createProgram, type Program } from '@strenly/core/domain/entities/program/program'
    import type { CreateProgramInput } from '@strenly/core/domain/entities/program/types'

    export type SaveDraftInput = {
      programId: string
      program: CreateProgramInput // Full program aggregate input
    }

    export type SaveDraftOutput = {
      updatedAt: Date
    }

    export function saveDraftUseCase(
      ctx: AuthorizedContext,
      input: SaveDraftInput,
      deps: { programRepository: ProgramRepositoryPort },
    ): ResultAsync<SaveDraftOutput, SaveDraftError> {
      // 1. Check authorization (program:update)
      const authCheck = checkAuthorization(ctx, 'program:update')
      if (authCheck.isErr()) {
        return errAsync({ type: 'UNAUTHORIZED', message: authCheck.error.message })
      }

      // 2. Validate aggregate via domain factory
      const programResult = createProgram({
        ...input.program,
        id: input.programId,
        organizationId: ctx.organizationId,
      })

      if (programResult.isErr()) {
        return errAsync({
          type: 'VALIDATION_ERROR',
          message: programResult.error.message,
          details: programResult.error,
        })
      }

      const program = programResult.value

      // 3. Save aggregate (replace-on-save)
      return deps.programRepository
        .saveProgramAggregate(ctx, program)
        .mapErr(mapRepoError)
        .map(result => ({ updatedAt: result.updatedAt }))
    }
    ```

    Error types to support:
    ```typescript
    export type SaveDraftError =
      | { type: 'UNAUTHORIZED'; message: string }
      | { type: 'VALIDATION_ERROR'; message: string; details?: unknown }
      | { type: 'NOT_FOUND'; message: string }
      | { type: 'DATABASE_ERROR'; message: string }
    ```

    Note: The old saveDraft took delta changes (changedPrescriptions, newWeeks, etc.).
    The new version takes the complete program. The frontend will need to send the full aggregate.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    saveDraft use case validates via createProgram() and saves via saveProgramAggregate().
  </done>
</task>

<task type="auto">
  <name>Task 2: Update getProgram Use Case for Aggregate</name>
  <files>packages/backend/src/use-cases/programs/get-program.ts</files>
  <action>
    Update getProgram to return the full aggregate using loadProgramAggregate.

    ```typescript
    import type { Program } from '@strenly/core/domain/entities/program/program'

    export type GetProgramOutput = Program // Full aggregate

    export function getProgramUseCase(
      ctx: AuthorizedContext,
      input: { programId: string },
      deps: { programRepository: ProgramRepositoryPort },
    ): ResultAsync<GetProgramOutput, GetProgramError> {
      // 1. Check authorization
      const authCheck = checkAuthorization(ctx, 'program:read')
      if (authCheck.isErr()) {
        return errAsync({ type: 'UNAUTHORIZED', message: authCheck.error.message })
      }

      // 2. Load full aggregate
      return deps.programRepository
        .loadProgramAggregate(ctx, input.programId)
        .mapErr(mapRepoError)
    }
    ```

    If there's an existing getProgram that returns ProgramWithDetails (the old flat structure),
    either update it to use loadProgramAggregate or create a new use case and deprecate the old one.

    Check if there's a separate `getProgramForGrid` or similar - if so, update that one too
    to use loadProgramAggregate, as the aggregate now contains the full grid data.
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    getProgram returns full Program aggregate via loadProgramAggregate.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update createProgram and duplicateProgram Use Cases</name>
  <files>
    packages/backend/src/use-cases/programs/create-program.ts
    packages/backend/src/use-cases/programs/duplicate-program.ts
  </files>
  <action>
    Update create and duplicate use cases to use the new aggregate pattern.

    **createProgram:**
    ```typescript
    import { createProgram as createProgramEntity } from '@strenly/core/domain/entities/program/program'

    export function createProgramUseCase(
      ctx: AuthorizedContext,
      input: CreateProgramInput,
      deps: { programRepository: ProgramRepositoryPort },
    ): ResultAsync<Program, CreateProgramError> {
      // 1. Authorization
      const authCheck = checkAuthorization(ctx, 'program:create')
      if (authCheck.isErr()) {
        return errAsync({ type: 'UNAUTHORIZED', message: authCheck.error.message })
      }

      // 2. Create aggregate via domain factory
      const id = `prg-${crypto.randomUUID()}`
      const programResult = createProgramEntity({
        id,
        organizationId: ctx.organizationId,
        name: input.name,
        description: input.description,
        athleteId: input.athleteId,
        isTemplate: input.isTemplate ?? false,
        weeks: input.weeks ?? generateDefaultWeeks(input.weeksCount ?? 4),
      })

      if (programResult.isErr()) {
        return errAsync({
          type: 'VALIDATION_ERROR',
          message: programResult.error.message,
        })
      }

      // 3. Save new program (for new programs, just use create method)
      // Or use saveProgramAggregate - depends on whether create needs to handle structure
      return deps.programRepository
        .create(ctx, programResult.value)
        .mapErr(mapRepoError)
    }

    function generateDefaultWeeks(count: number): WeekInput[] {
      return Array.from({ length: count }, (_, i) => ({
        id: `wk-${crypto.randomUUID()}`,
        name: `Semana ${i + 1}`,
        orderIndex: i,
        sessions: [], // Empty sessions - user adds them
      }))
    }
    ```

    **duplicateProgram:**
    Update to load source aggregate, modify IDs, and save as new.

    ```typescript
    export function duplicateProgramUseCase(
      ctx: AuthorizedContext,
      input: { programId: string; newName: string },
      deps: { programRepository: ProgramRepositoryPort },
    ): ResultAsync<Program, DuplicateProgramError> {
      // 1. Authorization
      const authCheck = checkAuthorization(ctx, 'program:create')
      if (authCheck.isErr()) {
        return errAsync({ type: 'UNAUTHORIZED', message: authCheck.error.message })
      }

      // 2. Load source aggregate
      return deps.programRepository
        .loadProgramAggregate(ctx, input.programId)
        .mapErr(mapRepoError)
        .andThen(sourceProgram => {
          // 3. Clone with new IDs
          const newId = `prg-${crypto.randomUUID()}`
          const clonedProgram = cloneProgramWithNewIds(sourceProgram, newId, input.newName)

          // 4. Validate clone
          const validated = createProgramEntity({
            ...clonedProgram,
            organizationId: ctx.organizationId,
          })

          if (validated.isErr()) {
            return errAsync({
              type: 'VALIDATION_ERROR',
              message: validated.error.message,
            })
          }

          // 5. Save clone
          return deps.programRepository.create(ctx, validated.value)
        })
    }

    function cloneProgramWithNewIds(
      source: Program,
      newId: string,
      newName: string
    ): CreateProgramInput {
      return {
        id: newId,
        name: newName,
        description: source.description,
        athleteId: source.athleteId,
        isTemplate: false,
        status: 'draft',
        weeks: source.weeks.map(week => ({
          id: `wk-${crypto.randomUUID()}`,
          name: week.name,
          orderIndex: week.orderIndex,
          sessions: week.sessions.map(session => ({
            id: `sess-${crypto.randomUUID()}`,
            name: session.name,
            orderIndex: session.orderIndex,
            exerciseGroups: session.exerciseGroups.map(group => ({
              id: `eg-${crypto.randomUUID()}`,
              name: group.name,
              orderIndex: group.orderIndex,
              items: group.items.map(item => ({
                id: `pex-${crypto.randomUUID()}`,
                exerciseId: item.exerciseId,
                orderIndex: item.orderIndex,
                series: [...item.series], // Copy series data
              })),
            })),
          })),
        })),
      }
    }
    ```
  </action>
  <verify>
    ```bash
    cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend
    ```
  </verify>
  <done>
    createProgram and duplicateProgram use cases work with aggregate pattern.
  </done>
</task>

</tasks>

<verification>
```bash
# Type check backend package
cd /Users/tomiardz/Projects/treino && pnpm typecheck --filter @strenly/backend

# Verify use cases compile
grep -q "createProgram" packages/backend/src/use-cases/programs/save-draft.ts
grep -q "loadProgramAggregate" packages/backend/src/use-cases/programs/get-program.ts

# Run backend tests if they exist
cd /Users/tomiardz/Projects/treino && pnpm test --filter @strenly/backend 2>/dev/null || echo "No tests yet"
```
</verification>

<success_criteria>
- saveDraft validates via createProgram() domain factory
- saveDraft persists via saveProgramAggregate()
- getProgram returns full Program aggregate
- createProgram validates via domain factory
- duplicateProgram clones with new IDs and validates
- All use cases pass authorization checks
- Backend typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-domain-restructure-training-programs/03.4-04-SUMMARY.md`
</output>
