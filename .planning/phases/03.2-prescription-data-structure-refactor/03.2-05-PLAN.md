---
phase: 03.2-prescription-data-structure-refactor
plan: 05
type: execute
wave: 5
depends_on: ["03.2-04"]
files_modified:
  - packages/backend/src/use-cases/programs/save-draft.ts
  - packages/backend/src/procedures/programs/save-draft.ts
  - packages/contracts/src/programs/save-draft.ts
autonomous: true

must_haves:
  truths:
    - "saveDraft use case accepts full program state and persists atomically"
    - "saveDraft procedure exposes the API endpoint"
    - "Contract defines input schema for bulk save"
    - "Existing per-change mutations still work (updatePrescription, updateExerciseRow)"
  artifacts:
    - path: "packages/backend/src/use-cases/programs/save-draft.ts"
      provides: "Bulk save use case"
      exports: ["saveDraftUseCase"]
    - path: "packages/backend/src/procedures/programs/save-draft.ts"
      provides: "saveDraft procedure"
      exports: ["saveDraftProcedure"]
    - path: "packages/contracts/src/programs/save-draft.ts"
      provides: "saveDraft input schema"
      exports: ["saveDraftInputSchema", "SaveDraftInput"]
  key_links:
    - from: "packages/backend/src/procedures/programs/save-draft.ts"
      to: "packages/backend/src/use-cases/programs/save-draft.ts"
      via: "use case invocation"
      pattern: "saveDraftUseCase"
---

<objective>
Create saveDraft use case and procedure for bulk program saving.

Purpose: Enable the client-side editing model where all changes are accumulated locally and saved in a single API call. This replaces the per-change mutation pattern for prescription editing.

Output:
- saveDraft use case that persists program state atomically
- saveDraft procedure exposing the API
- Contract with input schema
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-RESEARCH.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-04-SUMMARY.md

@packages/backend/src/use-cases/programs/update-program.ts
@packages/backend/src/use-cases/programs/update-prescription.ts
@packages/backend/src/procedures/programs/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create saveDraft contract</name>
  <skills>/contracts</skills>
  <files>packages/contracts/src/programs/save-draft.ts</files>
  <action>
Create contract for bulk save operation:

```typescript
import { z } from 'zod'
import { prescriptionSeriesInputSchema } from './prescription'

/**
 * Single prescription update in the bulk save
 */
const prescriptionUpdateSchema = z.object({
  exerciseRowId: z.string(),
  weekId: z.string(),
  series: z.array(prescriptionSeriesInputSchema), // Can be empty array for cleared cell
  notes: z.string().nullable().optional(),
})

/**
 * Exercise row update (exercise selection change)
 */
const exerciseRowUpdateSchema = z.object({
  rowId: z.string(),
  exerciseId: z.string(),
})

/**
 * Group update (for superset changes)
 */
const groupUpdateSchema = z.object({
  groupId: z.string(),
  name: z.string().nullable().optional(),
  exerciseRowIds: z.array(z.string()), // Ordered list of rows in this group
})

/**
 * Save draft input - bulk program state update
 * Accepts all changes made client-side and persists atomically
 */
export const saveDraftInputSchema = z.object({
  programId: z.string(),
  // Prescription changes (most common)
  prescriptions: z.array(prescriptionUpdateSchema).default([]),
  // Exercise selection changes
  exerciseRows: z.array(exerciseRowUpdateSchema).default([]),
  // Group membership changes
  groups: z.array(groupUpdateSchema).default([]),
  // Timestamp for conflict detection (optional)
  lastLoadedAt: z.coerce.date().optional(),
})

export type SaveDraftInput = z.infer<typeof saveDraftInputSchema>

/**
 * Save draft output
 */
export const saveDraftOutputSchema = z.object({
  success: z.boolean(),
  updatedAt: z.date(),
  // Warning if server data was newer (potential conflict)
  conflictWarning: z.string().nullable(),
})

export type SaveDraftOutput = z.infer<typeof saveDraftOutputSchema>
```
  </action>
  <verify>pnpm typecheck --filter @strenly/contracts</verify>
  <done>save-draft.ts exists with input and output schemas</done>
</task>

<task type="auto">
  <name>Task 2: Create saveDraft use case</name>
  <skills>/use-case, /authorization</skills>
  <files>packages/backend/src/use-cases/programs/save-draft.ts</files>
  <action>
Create use case for bulk saving:

```typescript
import { ResultAsync, errAsync, okAsync } from 'neverthrow'
import type { OrganizationContext } from '@strenly/core/types'
import type { ProgramRepository } from '@strenly/core/ports/program-repository.port'
import type { SaveDraftInput } from '@strenly/contracts/programs/save-draft'
import { hasPermission } from '@strenly/core/services/authorization'

export type SaveDraftError =
  | { type: 'UNAUTHORIZED'; message: string }
  | { type: 'PROGRAM_NOT_FOUND'; message: string }
  | { type: 'CONFLICT'; message: string; serverUpdatedAt: Date }
  | { type: 'REPOSITORY_ERROR'; message: string }

export function createSaveDraftUseCase(programRepository: ProgramRepository) {
  return function saveDraft(
    ctx: OrganizationContext,
    input: SaveDraftInput
  ): ResultAsync<{ updatedAt: Date; conflictWarning: string | null }, SaveDraftError> {
    // 1. Authorization check
    if (!hasPermission(ctx.userRole, 'program:update')) {
      return errAsync({
        type: 'UNAUTHORIZED',
        message: 'No tienes permiso para editar programas',
      })
    }

    // 2. Verify program exists and belongs to org
    return programRepository
      .findById(ctx, input.programId)
      .mapErr((e) => ({ type: 'REPOSITORY_ERROR' as const, message: e.message }))
      .andThen((program) => {
        if (!program) {
          return errAsync({
            type: 'PROGRAM_NOT_FOUND' as const,
            message: 'Programa no encontrado',
          })
        }

        // 3. Optional conflict check
        let conflictWarning: string | null = null
        if (input.lastLoadedAt && program.updatedAt > input.lastLoadedAt) {
          conflictWarning = 'El programa fue modificado por otro usuario. Tus cambios se guardaron pero podrian sobrescribir cambios recientes.'
        }

        // 4. Apply all updates in transaction (repository handles atomicity)
        return programRepository
          .saveDraft(ctx, input)
          .map((result) => ({
            updatedAt: result.updatedAt,
            conflictWarning,
          }))
          .mapErr((e) => ({ type: 'REPOSITORY_ERROR' as const, message: e.message }))
      })
  }
}
```

The saveDraft method on the repository was added in Plan 04 (Task 3). It handles:
- Update prescriptions with series arrays
- Update exercise row selections
- Update group memberships
- Use database transaction for atomicity
  </action>
  <verify>pnpm typecheck --filter @strenly/backend</verify>
  <done>save-draft.ts use case exists with authorization and bulk save logic</done>
</task>

<task type="auto">
  <name>Task 3: Create saveDraft procedure, wire up, and verify backward compatibility</name>
  <skills>/procedure</skills>
  <files>packages/backend/src/procedures/programs/save-draft.ts, packages/backend/src/procedures/programs/index.ts</files>
  <action>
Create the procedure and add to router:

1. Create save-draft.ts:
```typescript
import { authedProcedure } from '../trpc'
import { saveDraftInputSchema, saveDraftOutputSchema } from '@strenly/contracts/programs/save-draft'
import { createSaveDraftUseCase } from '../../use-cases/programs/save-draft'
import { createProgramRepository } from '../../infrastructure/repositories/program.repository'

export const saveDraftProcedure = authedProcedure
  .input(saveDraftInputSchema)
  .output(saveDraftOutputSchema)
  .mutation(async ({ ctx, input }) => {
    const repository = createProgramRepository(ctx.db)
    const saveDraft = createSaveDraftUseCase(repository)

    const result = await saveDraft(ctx.organizationContext, input)

    if (result.isErr()) {
      const error = result.error
      switch (error.type) {
        case 'UNAUTHORIZED':
          throw new TRPCError({ code: 'FORBIDDEN', message: error.message })
        case 'PROGRAM_NOT_FOUND':
          throw new TRPCError({ code: 'NOT_FOUND', message: error.message })
        case 'CONFLICT':
        case 'REPOSITORY_ERROR':
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message })
      }
    }

    return {
      success: true,
      updatedAt: result.value.updatedAt,
      conflictWarning: result.value.conflictWarning,
    }
  })
```

2. Update programs/index.ts router to include the new procedure:
```typescript
// Add to router
saveDraft: saveDraftProcedure,
```

3. Verify existing mutations still compile and work:
- DO NOT remove or modify updatePrescription procedure
- DO NOT remove or modify updateExerciseRow procedure
- Both old and new patterns should work in parallel during transition
  </action>
  <verify>
```bash
# Verify new procedure compiles
pnpm typecheck --filter @strenly/backend

# Verify existing mutations still compile (backward compatibility)
# Look for updatePrescription and updateExerciseRow in router output
pnpm typecheck --filter @strenly/backend 2>&1 | grep -E "(updatePrescription|updateExerciseRow|saveDraft)"

# If grep returns nothing, manually verify router still exports all three procedures
```
  </verify>
  <done>saveDraft procedure exists, wired into programs router, existing updatePrescription/updateExerciseRow procedures unchanged</done>
</task>

</tasks>

<verification>
Run from repository root:
```bash
pnpm typecheck --filter @strenly/contracts
pnpm typecheck --filter @strenly/backend
```

All packages should compile without errors.

Verify backward compatibility:
- Open packages/backend/src/procedures/programs/index.ts
- Confirm updatePrescription, updateExerciseRow, AND saveDraft are all exported
- Existing per-change mutations are NOT removed
</verification>

<success_criteria>
- [ ] save-draft.ts contract exists with input/output schemas
- [ ] save-draft.ts use case exists with authorization check
- [ ] save-draft.ts procedure exists and added to router
- [ ] Repository saveDraft method handles bulk updates (added in Plan 04)
- [ ] All packages typecheck
- [ ] Existing updatePrescription procedure still exists and compiles
- [ ] Existing updateExerciseRow procedure still exists and compiles
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-prescription-data-structure-refactor/03.2-05-SUMMARY.md`
</output>
