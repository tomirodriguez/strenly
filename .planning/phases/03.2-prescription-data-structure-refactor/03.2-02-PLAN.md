---
phase: 03.2-prescription-data-structure-refactor
plan: 02
type: tdd
wave: 2
depends_on: ["03.2-01"]
files_modified:
  - packages/core/src/domain/entities/prescription-series.ts
  - packages/core/src/domain/entities/prescription-series.test.ts
  - packages/core/src/domain/entities/exercise-group.ts
  - packages/core/src/domain/entities/exercise-group.test.ts
autonomous: true

must_haves:
  truths:
    - "PrescriptionSeries entity validates single set parameters"
    - "ExerciseGroup entity validates group with exercises"
    - "Factory functions return Result types"
    - "All business rules from existing Prescription are preserved"
  artifacts:
    - path: "packages/core/src/domain/entities/prescription-series.ts"
      provides: "Single set domain entity"
      exports: ["createPrescriptionSeries", "PrescriptionSeries", "PrescriptionSeriesError"]
    - path: "packages/core/src/domain/entities/prescription-series.test.ts"
      provides: "Series validation tests"
      min_lines: 80
    - path: "packages/core/src/domain/entities/exercise-group.ts"
      provides: "Group container entity"
      exports: ["createExerciseGroup", "ExerciseGroup", "ExerciseGroupError"]
    - path: "packages/core/src/domain/entities/exercise-group.test.ts"
      provides: "Group validation tests"
      min_lines: 50
  key_links:
    - from: "packages/core/src/domain/entities/prescription-series.ts"
      to: "packages/core/src/domain/entities/prescription.ts"
      via: "reuses IntensityType"
      pattern: "import.*INTENSITY_TYPES"
---

<objective>
Create domain entities for PrescriptionSeries and ExerciseGroup using TDD.

Purpose: Establish the domain layer for the new data model. PrescriptionSeries represents a single set (instead of the current sets: number approach), and ExerciseGroup unifies standalone/superset/circuit under one model.

Output:
- PrescriptionSeries entity with factory function and validation
- ExerciseGroup entity with factory function
- Comprehensive tests for both entities (90%+ coverage)
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-RESEARCH.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-01-SUMMARY.md

@packages/core/src/domain/entities/prescription.ts
</context>

<feature>
  <name>PrescriptionSeries Domain Entity</name>
  <files>
    packages/core/src/domain/entities/prescription-series.ts
    packages/core/src/domain/entities/prescription-series.test.ts
  </files>
  <behavior>
A PrescriptionSeries represents a single set in a prescription:
- Has orderIndex (0-based position in the series array)
- Has reps (number or null for AMRAP)
- Has repsMax (for rep ranges, must be >= reps when both present)
- Has isAmrap flag (when true, reps must be null or 0)
- Has optional intensity (type + value + unit)
- Has optional tempo (4-char ECCC format)
- Has optional restSeconds (for intra-set rest in clusters)

Test cases:
- createPrescriptionSeries({reps: 8, isAmrap: false}, 0) -> ok({orderIndex: 0, reps: 8, ...})
- createPrescriptionSeries({reps: null, isAmrap: true}, 0) -> ok (AMRAP valid)
- createPrescriptionSeries({reps: 8, isAmrap: true}, 0) -> err (AMRAP with reps)
- createPrescriptionSeries({reps: -1, isAmrap: false}, 0) -> err (negative reps)
- createPrescriptionSeries({reps: 8, repsMax: 6}, 0) -> err (max < min)
- createPrescriptionSeries({reps: 8, intensityType: 'rpe', intensityValue: null}, 0) -> err (type without value)
- createPrescriptionSeries({reps: 8, intensityType: 'percentage', intensityValue: 150}, 0) -> err (percentage > 100)
- createPrescriptionSeries({reps: 8, tempo: 'ABC'}, 0) -> err (invalid tempo format)
- createPrescriptionSeries({reps: 8, tempo: '31X0'}, 0) -> ok (valid tempo)
- reconstitute(...) -> returns series without validation (for DB reads)
  </behavior>
  <implementation>
Create factory function following existing Prescription pattern:
1. Import INTENSITY_TYPES from prescription.ts to reuse validation
2. Create PrescriptionSeriesProps interface (all readonly)
3. Create PrescriptionSeriesError discriminated union
4. Create createPrescriptionSeries(input, index) -> Result<PrescriptionSeries, Error>
5. Create reconstitute(props) -> PrescriptionSeries for database loads
6. Validate same intensity bounds as current Prescription entity
  </implementation>
</feature>

<feature>
  <name>ExerciseGroup Domain Entity</name>
  <files>
    packages/core/src/domain/entities/exercise-group.ts
    packages/core/src/domain/entities/exercise-group.test.ts
  </files>
  <behavior>
An ExerciseGroup represents a collection of exercises within a session:
- Has id (string, prefixed 'eg-')
- Has sessionId (reference to session)
- Has orderIndex (position within session, 0-based)
- Has optional name (label like "Heavy Block", null for auto-generated A/B/C)

Test cases:
- createExerciseGroup({id: 'eg-1', sessionId: 's-1', orderIndex: 0}) -> ok
- createExerciseGroup({id: 'eg-1', sessionId: 's-1', orderIndex: -1}) -> err (negative order)
- createExerciseGroup({id: 'eg-1', sessionId: 's-1', orderIndex: 0, name: ''}) -> ok (empty name normalized to null)
- createExerciseGroup({id: 'eg-1', sessionId: 's-1', orderIndex: 0, name: 'Heavy'}) -> ok
- reconstitute(...) -> returns group without validation
  </behavior>
  <implementation>
1. Create ExerciseGroupProps interface (all readonly)
2. Create ExerciseGroupError discriminated union
3. Create createExerciseGroup(input) -> Result<ExerciseGroup, Error>
4. Create reconstitute(props) -> ExerciseGroup
5. Simple validation: orderIndex >= 0, normalize empty name to null
  </implementation>
</feature>

<verification>
Run TDD cycle:
```bash
# RED: Write tests first, they should fail
pnpm test --filter @strenly/core -- prescription-series.test.ts --watch

# GREEN: Implement to pass tests
# Verify all tests pass

# Full test run
pnpm test --filter @strenly/core
pnpm typecheck --filter @strenly/core
```
</verification>

<success_criteria>
- [ ] prescription-series.ts exists with factory function returning Result
- [ ] prescription-series.test.ts has tests for all validation cases
- [ ] exercise-group.ts exists with factory function returning Result
- [ ] exercise-group.test.ts has tests for all validation cases
- [ ] All tests pass
- [ ] No type errors in packages/core
- [ ] Reuses INTENSITY_TYPES from existing prescription.ts
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-prescription-data-structure-refactor/03.2-02-SUMMARY.md`
</output>
