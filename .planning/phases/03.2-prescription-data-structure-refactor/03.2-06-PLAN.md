---
phase: 03.2-prescription-data-structure-refactor
plan: 06
type: execute
wave: 6
depends_on: ["03.2-04"]
files_modified:
  - apps/coach-web/src/stores/grid-store.ts
  - apps/coach-web/src/hooks/use-unsaved-changes.ts
autonomous: true

must_haves:
  truths:
    - "Grid state is managed with Zustand store"
    - "All edits update local state without API calls"
    - "isDirty flag tracks unsaved changes"
    - "Navigation blocked when dirty"
  artifacts:
    - path: "apps/coach-web/src/stores/grid-store.ts"
      provides: "Zustand store for grid state"
      exports: ["useGridStore", "createGridStore"]
    - path: "apps/coach-web/src/hooks/use-unsaved-changes.ts"
      provides: "Navigation guard hook"
      exports: ["useUnsavedChanges"]
  key_links:
    - from: "apps/coach-web/src/stores/grid-store.ts"
      to: "apps/coach-web/src/components/programs/program-grid/program-grid.tsx"
      via: "store usage"
      pattern: "useGridStore"
    - from: "apps/coach-web/src/stores/grid-store.ts"
      to: "@strenly/contracts/programs/prescription"
      via: "import formatSeriesToNotation"
      pattern: "import.*formatSeriesToNotation.*from.*@strenly/contracts"
---

<objective>
Create client-side grid state management with Zustand.

Purpose: Enable 100% client-side editing where changes accumulate in local state and are saved with a single "Guardar" action. This removes the lag of per-change API calls and provides a faster editing experience.

Output:
- Zustand store for grid state (useGridStore)
- useUnsavedChanges hook for navigation guards
- No new dependencies (Zustand already in project)
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-RESEARCH.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-04-SUMMARY.md

@apps/coach-web/src/components/programs/program-grid/types.ts
@apps/coach-web/src/components/programs/program-grid/transform-program.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify Zustand is available</name>
  <files>apps/coach-web/package.json</files>
  <action>
Check that Zustand is already installed in the project. It should be since it's the project standard for client-side state.

```bash
grep -q "zustand" apps/coach-web/package.json && echo "Zustand found" || echo "Zustand NOT found - install it"
```

If not found, install it:
```bash
cd apps/coach-web
pnpm add zustand
```

No need to install immer or use-immer - we use plain Zustand with immutable updates.
  </action>
  <verify>grep -q "zustand" apps/coach-web/package.json</verify>
  <done>Zustand confirmed available in package.json</done>
</task>

<task type="auto">
  <name>Task 2: Create Zustand grid store</name>
  <files>apps/coach-web/src/stores/grid-store.ts</files>
  <action>
Create the grid state management using a Zustand store:

```typescript
import { create } from 'zustand'
import type { GridData, GridRow } from '@/components/programs/program-grid/types'
import type { PrescriptionSeriesInput } from '@strenly/contracts/programs/prescription'
import { formatSeriesToNotation } from '@strenly/contracts/programs/prescription'

/**
 * Tracked prescription change for bulk save
 */
interface PrescriptionChange {
  exerciseRowId: string
  weekId: string
  series: PrescriptionSeriesInput[]
}

/**
 * Tracked exercise row change for bulk save
 */
interface ExerciseRowChange {
  rowId: string
  exerciseId: string
}

/**
 * Grid state interface
 */
interface GridState {
  // Data
  data: GridData | null
  programId: string | null

  // Dirty tracking
  isDirty: boolean
  lastLoadedAt: Date | null

  // Change tracking for efficient save
  changedPrescriptions: Map<string, PrescriptionChange>
  changedExerciseRows: Map<string, ExerciseRowChange>
}

/**
 * Grid actions interface
 */
interface GridActions {
  // Initialize store with program data
  initialize: (programId: string, data: GridData) => void

  // Update a prescription (series array)
  updatePrescription: (exerciseRowId: string, weekId: string, series: PrescriptionSeriesInput[]) => void

  // Update an exercise selection
  updateExercise: (rowId: string, exerciseId: string, exerciseName: string) => void

  // Reset to server state (e.g., after refetch)
  reset: (data: GridData) => void

  // Mark as saved (clear dirty flag and changes)
  markSaved: () => void

  // Get accumulated changes for save operation
  getChanges: () => {
    prescriptions: PrescriptionChange[]
    exerciseRows: ExerciseRowChange[]
    lastLoadedAt: Date | null
  }
}

type GridStore = GridState & GridActions

/**
 * Zustand store for program grid state
 *
 * Enables 100% client-side editing with explicit "Guardar" save action.
 * All prescription edits update local state without API calls.
 */
export const useGridStore = create<GridStore>((set, get) => ({
  // Initial state
  data: null,
  programId: null,
  isDirty: false,
  lastLoadedAt: null,
  changedPrescriptions: new Map(),
  changedExerciseRows: new Map(),

  // Actions
  initialize: (programId, data) => set({
    programId,
    data,
    isDirty: false,
    lastLoadedAt: new Date(),
    changedPrescriptions: new Map(),
    changedExerciseRows: new Map(),
  }),

  updatePrescription: (exerciseRowId, weekId, series) => set((state) => {
    if (!state.data) return state

    // Find and update the row immutably
    const updatedRows = state.data.rows.map((row) => {
      if (row.type === 'exercise' && row.id === exerciseRowId) {
        const notationDisplay = formatSeriesToNotation(series)
        return {
          ...row,
          prescriptions: {
            ...row.prescriptions,
            [weekId]: notationDisplay,
          },
        }
      }
      return row
    })

    // Track the change
    const key = `${exerciseRowId}:${weekId}`
    const newChangedPrescriptions = new Map(state.changedPrescriptions)
    newChangedPrescriptions.set(key, { exerciseRowId, weekId, series })

    return {
      data: { ...state.data, rows: updatedRows },
      isDirty: true,
      changedPrescriptions: newChangedPrescriptions,
    }
  }),

  updateExercise: (rowId, exerciseId, exerciseName) => set((state) => {
    if (!state.data) return state

    // Find and update the row immutably
    const updatedRows = state.data.rows.map((row) => {
      if (row.type === 'exercise' && row.id === rowId && row.exercise) {
        return {
          ...row,
          exercise: {
            ...row.exercise,
            exerciseId,
            exerciseName,
          },
        }
      }
      return row
    })

    // Track the change
    const newChangedExerciseRows = new Map(state.changedExerciseRows)
    newChangedExerciseRows.set(rowId, { rowId, exerciseId })

    return {
      data: { ...state.data, rows: updatedRows },
      isDirty: true,
      changedExerciseRows: newChangedExerciseRows,
    }
  }),

  reset: (data) => set((state) => ({
    data,
    isDirty: false,
    lastLoadedAt: new Date(),
    changedPrescriptions: new Map(),
    changedExerciseRows: new Map(),
  })),

  markSaved: () => set({
    isDirty: false,
    changedPrescriptions: new Map(),
    changedExerciseRows: new Map(),
  }),

  getChanges: () => {
    const state = get()
    return {
      prescriptions: Array.from(state.changedPrescriptions.values()),
      exerciseRows: Array.from(state.changedExerciseRows.values()),
      lastLoadedAt: state.lastLoadedAt,
    }
  },
}))

/**
 * Selector hooks for common patterns
 */
export const useGridData = () => useGridStore((state) => state.data)
export const useGridIsDirty = () => useGridStore((state) => state.isDirty)
export const useGridActions = () => useGridStore((state) => ({
  initialize: state.initialize,
  updatePrescription: state.updatePrescription,
  updateExercise: state.updateExercise,
  reset: state.reset,
  markSaved: state.markSaved,
  getChanges: state.getChanges,
}))
```

IMPORTANT: Import formatSeriesToNotation from the contracts package for display formatting.
The import statement MUST be: `import { formatSeriesToNotation } from '@strenly/contracts/programs/prescription'`

Benefits of Zustand over useReducer:
1. State accessible anywhere (not tied to component tree)
2. Built-in selectors for performance
3. Project standard - consistent with other stores
4. Less boilerplate
5. DevTools support
  </action>
  <verify>pnpm typecheck --filter coach-web</verify>
  <done>grid-store.ts exists with Zustand store, includes formatSeriesToNotation import from @strenly/contracts</done>
</task>

<task type="auto">
  <name>Task 3: Create useUnsavedChanges hook</name>
  <files>apps/coach-web/src/hooks/use-unsaved-changes.ts</files>
  <action>
Create hook for navigation guards:

```typescript
import { useEffect, useCallback } from 'react'
import { useBlocker } from '@tanstack/react-router'

/**
 * Hook to warn about unsaved changes on navigation
 * Uses TanStack Router's useBlocker for in-app navigation
 * and beforeunload for browser navigation
 */
export function useUnsavedChanges(isDirty: boolean, message?: string) {
  const defaultMessage = 'Tienes cambios sin guardar. Estas seguro de que quieres salir?'
  const warningMessage = message ?? defaultMessage

  // Block in-app navigation with TanStack Router
  const { proceed, reset, status } = useBlocker({
    condition: isDirty,
  })

  // Block browser navigation (refresh, close tab)
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (isDirty) {
        e.preventDefault()
        e.returnValue = warningMessage
        return warningMessage
      }
    }

    window.addEventListener('beforeunload', handleBeforeUnload)
    return () => window.removeEventListener('beforeunload', handleBeforeUnload)
  }, [isDirty, warningMessage])

  // Confirmation dialog handler
  const confirmNavigation = useCallback(() => {
    if (status === 'blocked') {
      const confirmed = window.confirm(warningMessage)
      if (confirmed) {
        proceed()
      } else {
        reset()
      }
    }
  }, [status, warningMessage, proceed, reset])

  // Auto-show confirmation when blocked
  useEffect(() => {
    if (status === 'blocked') {
      confirmNavigation()
    }
  }, [status, confirmNavigation])

  return {
    isBlocked: status === 'blocked',
    proceed,
    reset,
  }
}
```

This hook:
1. Uses TanStack Router's useBlocker to intercept in-app navigation
2. Adds beforeunload listener for browser navigation
3. Shows confirmation dialog when navigation is attempted with unsaved changes
  </action>
  <verify>pnpm typecheck --filter coach-web</verify>
  <done>use-unsaved-changes.ts exists with navigation blocking</done>
</task>

<task type="auto">
  <name>Task 4: Create stores directory index (if needed)</name>
  <files>apps/coach-web/src/stores/index.ts</files>
  <action>
If the stores directory doesn't exist or doesn't have an index, create one:

```typescript
// Re-export grid store
export {
  useGridStore,
  useGridData,
  useGridIsDirty,
  useGridActions,
} from './grid-store'
```

This allows clean imports:
```typescript
import { useGridStore, useGridData } from '@/stores'
```
  </action>
  <verify>ls apps/coach-web/src/stores/</verify>
  <done>stores/index.ts exports grid store</done>
</task>

</tasks>

<verification>
Run from repository root:
```bash
pnpm typecheck --filter coach-web
```

Verify:
- Zustand in package.json (should already exist)
- stores/grid-store.ts exports useGridStore
- grid-store.ts imports formatSeriesToNotation from @strenly/contracts/programs/prescription
- hooks/use-unsaved-changes.ts exports useUnsavedChanges
</verification>

<success_criteria>
- [ ] Zustand available (no new dependencies needed if already in project)
- [ ] useGridStore manages grid data with Zustand
- [ ] Store imports formatSeriesToNotation from @strenly/contracts
- [ ] isDirty flag tracks unsaved changes
- [ ] getChanges returns accumulated changes for save
- [ ] useUnsavedChanges blocks navigation when dirty
- [ ] beforeunload event handled for browser navigation
- [ ] Selector hooks exported (useGridData, useGridIsDirty, useGridActions)
- [ ] All types compile
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-prescription-data-structure-refactor/03.2-06-SUMMARY.md`
</output>
