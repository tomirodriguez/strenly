---
phase: 03.2-prescription-data-structure-refactor
plan: 08
type: execute
wave: 8
depends_on: ["03.2-07"]
files_modified:
  - packages/database/drizzle/migrations/XXXX_prescription_refactor.sql
  - packages/database/src/seed/programs.ts
autonomous: false

must_haves:
  truths:
    - "Database migration runs successfully"
    - "Existing data is transformed to new structure"
    - "Grid displays correctly with migrated data"
    - "New programs use series array structure"
  artifacts:
    - path: "packages/database/drizzle/migrations/XXXX_prescription_refactor.sql"
      provides: "Database migration"
      contains: "exercise_groups"
  key_links:
    - from: "packages/database/drizzle/migrations/XXXX_prescription_refactor.sql"
      to: "packages/database/src/schema/exercise-groups.ts"
      via: "creates table"
      pattern: "CREATE TABLE exercise_groups"
---

<objective>
Create and run the database migration, transform existing data to new structure, and verify everything works.

Purpose: This is the final step that actually applies the schema changes and migrates existing data. Includes a human verification checkpoint to confirm the migration succeeded and the application works correctly.

Output:
- Generated and executed database migration
- Existing prescriptions transformed to series arrays
- Existing superset groups transformed to exercise_groups
- Working application with migrated data
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-RESEARCH.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-07-SUMMARY.md

@packages/database/src/schema/exercise-groups.ts
@packages/database/src/schema/program-exercises.ts
@packages/database/src/schema/prescriptions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate and execute database migration</name>
  <files>packages/database/drizzle/migrations/</files>
  <action>
**WARNING: BACKUP YOUR DATABASE BEFORE RUNNING THIS MIGRATION**

Before proceeding, ensure you have a database backup:
```bash
# For local dev, consider dumping the database first
pg_dump -h localhost -U postgres strenly > backup_before_migration.sql
```

Generate the migration for all schema changes:

```bash
cd packages/database
pnpm db:generate
```

This will create a migration file that:
1. Creates the exercise_groups table
2. Adds groupId and orderWithinGroup to program_exercises
3. Adds series column to prescriptions

Review the generated migration file to ensure it matches expectations.

Then apply the migration:

```bash
pnpm db:push  # For development
# OR
pnpm db:migrate  # For production-like apply
```

Verify tables exist:
```bash
pnpm db:studio
# Check that exercise_groups table exists
# Check that program_exercises has new columns
# Check that prescriptions has series column
```
  </action>
  <verify>pnpm db:studio shows new tables and columns</verify>
  <done>Migration generated and applied, new columns visible in database</done>
</task>

<task type="auto">
  <name>Task 2: Create data transformation script</name>
  <files>packages/database/src/seed/migrate-to-series.ts</files>
  <action>
**WARNING: BACKUP YOUR DATABASE BEFORE RUNNING THIS SCRIPT**

This script modifies existing data. Ensure backup exists before proceeding.

Create a script to transform existing data to the new structure:

```typescript
import { db } from '../client'
import { programExercises, exerciseGroups, prescriptions } from '../schema'
import { eq, isNull } from 'drizzle-orm'

/**
 * Migration script to transform existing data to new structure
 *
 * 1. For each program_exercise with supersetGroup, create/find exerciseGroup
 * 2. Update program_exercises.groupId to point to the group
 * 3. For each prescription, transform flat structure to series array
 *
 * **RUN BACKUP BEFORE EXECUTING THIS SCRIPT**
 */
export async function migrateToSeriesStructure() {
  console.log('=== WARNING ===')
  console.log('This script will modify existing data.')
  console.log('Ensure you have a database backup before proceeding.')
  console.log('================')
  console.log('')
  console.log('Starting data migration...')

  // Get all sessions that have exercises with superset groups
  const sessionsWithSupersets = await db
    .selectDistinct({ sessionId: programExercises.sessionId })
    .from(programExercises)
    .where(isNull(programExercises.groupId))

  for (const { sessionId } of sessionsWithSupersets) {
    // Get all exercises in this session
    const exercises = await db
      .select()
      .from(programExercises)
      .where(eq(programExercises.sessionId, sessionId))
      .orderBy(programExercises.orderIndex)

    // Group by supersetGroup (or create individual groups for standalone)
    const groups = new Map<string, typeof exercises>()
    for (const ex of exercises) {
      const key = ex.supersetGroup ?? `standalone-${ex.id}`
      if (!groups.has(key)) {
        groups.set(key, [])
      }
      groups.get(key)!.push(ex)
    }

    // Create exercise_groups and update exercises
    let groupOrderIndex = 0
    for (const [groupKey, groupExercises] of groups) {
      // Create the group
      const groupId = `eg-${crypto.randomUUID().slice(0, 8)}`
      await db.insert(exerciseGroups).values({
        id: groupId,
        sessionId,
        orderIndex: groupOrderIndex++,
        name: null, // Auto-generated letter
      })

      // Update exercises to point to the group
      for (let i = 0; i < groupExercises.length; i++) {
        const ex = groupExercises[i]
        await db
          .update(programExercises)
          .set({
            groupId,
            orderWithinGroup: i,
          })
          .where(eq(programExercises.id, ex.id))
      }
    }
  }

  console.log('Groups created, migrating prescriptions...')

  // Migrate prescriptions to series array
  const allPrescriptions = await db
    .select()
    .from(prescriptions)
    .where(isNull(prescriptions.series))

  for (const rx of allPrescriptions) {
    const oldData = rx.prescription as {
      sets: number
      repsMin: number
      repsMax: number | null
      isAmrap: boolean
      isUnilateral: boolean
      unilateralUnit: string | null
      intensityType: string | null
      intensityValue: number | null
      intensityUnit: string | null
      tempo: string | null
    }

    // Expand sets to series array
    const series = []
    for (let i = 0; i < oldData.sets; i++) {
      series.push({
        orderIndex: i,
        reps: oldData.isAmrap ? null : oldData.repsMin,
        repsMax: oldData.repsMax,
        isAmrap: oldData.isAmrap,
        intensityType: oldData.intensityType,
        intensityValue: oldData.intensityValue,
        intensityUnit: oldData.intensityUnit,
        tempo: oldData.tempo,
        restSeconds: null,
      })
    }

    await db
      .update(prescriptions)
      .set({ series })
      .where(eq(prescriptions.id, rx.id))
  }

  console.log('Migration complete!')
}

// Run if called directly
if (require.main === module) {
  migrateToSeriesStructure()
    .then(() => process.exit(0))
    .catch((e) => {
      console.error(e)
      process.exit(1)
    })
}
```

Run the migration:
```bash
cd packages/database
npx tsx src/seed/migrate-to-series.ts
```

Verify data transformed:
```bash
pnpm db:studio
# Check exercise_groups has entries
# Check program_exercises.groupId is populated
# Check prescriptions.series has arrays
```
  </action>
  <verify>Data migration script runs without errors, data visible in db:studio</verify>
  <done>Existing data transformed to new structure</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete prescription data structure refactor:
1. New exercise_groups table
2. Updated program_exercises with group references
3. Prescriptions with series arrays
4. Client-side grid state with explicit save
5. Multi-series cell display
6. Data migration completed
  </what-built>
  <how-to-verify>
1. Start the application:
   ```bash
   pnpm dev
   ```

2. Navigate to an existing program (one that was migrated)

3. Verify grid displays correctly:
   - Exercises show in proper order
   - Superset grouping preserved (A1/A2 labels)
   - Prescription values display correctly

4. Test editing:
   - Click on a prescription cell
   - Edit the value (e.g., change "3x8" to "4x10")
   - Notice the "Guardar" button becomes enabled
   - Click elsewhere - edit should be saved to local state

5. Test multi-part notation:
   - Enter "3x8@120kg + 1x1@130kg" in a cell
   - Should display as multi-line:
     3x8@120kg
     1x1@130kg

6. Test save:
   - Make a few edits
   - Click "Guardar"
   - Should see loading state then "Programa guardado" toast
   - Refresh page - changes should persist

7. Test navigation guard:
   - Make an edit (don't save)
   - Try to navigate away
   - Should see unsaved changes warning

8. Test new program:
   - Create a new program
   - Add exercises and prescriptions
   - Save and verify it works correctly
  </how-to-verify>
  <resume-signal>Type "approved" if everything works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After human verification approves, the phase is complete.

Final checks:
```bash
pnpm typecheck
pnpm lint
pnpm test
```
</verification>

<success_criteria>
- [ ] Database backup created before migration
- [ ] Database migration applied successfully
- [ ] exercise_groups table populated
- [ ] program_exercises.groupId populated
- [ ] prescriptions.series populated
- [ ] Existing programs display correctly
- [ ] Editing works with local state
- [ ] Multi-series notation parses and displays
- [ ] Save persists changes
- [ ] Navigation guard works
- [ ] New programs work with new structure
- [ ] Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-prescription-data-structure-refactor/03.2-08-SUMMARY.md`
</output>
