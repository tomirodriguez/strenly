# Phase 3.2: Prescription Data Structure Refactor - Research

**Researched:** 2026-01-25
**Domain:** Data model refactoring, client-side state management, PostgreSQL JSONB migrations
**Confidence:** HIGH

## Summary

This phase restructures the program/prescription data model to represent sets as individual series (prescriptions) in an ordered array rather than a single `sets: number` field. This enables flexible prescription variations like "3x8@120kg + 1x1@130kg" as `[8@120, 8@120, 8@120, 1@130]` - each set is its own prescription object. The phase also introduces exercise groups to unify standalone, superset, and circuit patterns under one model (group size determines type), and transitions from per-change auto-save to client-side editing with explicit manual save.

Key transformations:
1. **Prescription series array**: Replace `sets: 3, reps: 8` with array of series `[{reps: 8, ...}, {reps: 8, ...}, {reps: 8, ...}]`
2. **Exercise groups**: Replace `supersetGroup/supersetOrder` with `exerciseGroupId` where group size determines type (1=standalone, 2=bi-series, N=circuit)
3. **Client-side state**: Move from per-cell mutations to local state management with single "Guardar" save action
4. **Multi-series display**: Multiple prescriptions per cell render as multiple lines within same cell (not separate rows)

**Primary recommendation:** Use Zustand for client-side grid state (project standard), store series as JSONB array with ordered index, implement exercise groups table for unified grouping model.

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| zustand | 4.x | Client-side state management | Project standard; global store accessible anywhere, built-in selectors |
| zod | 3.x | Schema validation | Already in stack; validates new prescription array structure |
| drizzle-orm | Current | Database ORM | Already in stack; handles JSONB array operations |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| neverthrow | 8.x | Error handling | Already in stack; domain entity factory functions |
| @tanstack/react-query | 5.x | Server state | Already in stack; single mutation for save action |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| zustand | immer + useReducer | useReducer is component-scoped; zustand is project standard and accessible globally |
| zustand | useState with spread | Spread syntax for deeply nested updates is error-prone and verbose |
| JSONB array | Normalized series table | Normalized table adds complexity; JSONB keeps prescription atomic |

**Installation:**
```bash
# Zustand should already be installed (project standard)
# No new dependencies needed
```

## Architecture Patterns

### Recommended Project Structure

```
packages/core/src/domain/entities/
  prescription-series.ts     # NEW: Single set/series in a prescription
  exercise-group.ts          # NEW: Group container entity
  prescription.ts            # UPDATED: Uses series array
  program-exercise.ts        # NEW: Exercise in group (replaces program-exercises concept)

packages/database/src/schema/
  exercise-groups.ts         # NEW: Groups table
  program-exercises.ts       # UPDATED: References group, not superset fields
  prescriptions.ts           # UPDATED: Series array in JSONB

packages/contracts/src/programs/
  prescription.ts            # UPDATED: Series array schemas
  exercise-group.ts          # NEW: Group schemas

apps/coach-web/src/
  hooks/use-grid-state.ts    # NEW: immer reducer for client-side grid state
  components/programs/
    program-grid/
      use-grid-mutations.ts  # UPDATED: Single saveDraft mutation
      save-button.tsx        # NEW: "Guardar" button component
```

### Pattern 1: Prescription Series Array Model

**What:** Each prescription contains an ordered array of series (sets), where each series has its own parameters.

**When to use:** Always - this is the new core model.

**Structure:**
```typescript
// Source: Derived from domain research docs/domain-research-strength-training.md

// A single set/series in a prescription
interface PrescriptionSeries {
  readonly orderIndex: number  // Position in array: 0, 1, 2...
  readonly reps: number | null  // null for AMRAP
  readonly isAmrap: boolean
  readonly intensityType: IntensityType | null
  readonly intensityValue: number | null
  readonly tempo: string | null
  // restSeconds at series level for intra-set rest (clusters)
  readonly restSeconds: number | null
}

// The prescription for an exercise in a week
interface Prescription {
  readonly id: string
  readonly exerciseId: string  // NEW: Direct reference, not via row
  readonly weekId: string
  readonly series: readonly PrescriptionSeries[]  // Array of sets
  readonly notes: string | null
}

// Display logic:
// - series.length === 0: Empty cell (em dash)
// - series.length === 1: Single line "3x8@120kg" (use repeating notation)
// - series with identical params: "3x8@120kg" (compact)
// - series with variations: Multi-line display
//   Line 1: "3x8@120kg"
//   Line 2: "1x1@130kg"
```

### Pattern 2: Exercise Groups Model

**What:** Groups unify standalone, superset, and circuit under one abstraction. Group size determines display behavior.

**When to use:** All exercise organization in sessions.

**Structure:**
```typescript
// Source: Domain decision from context - "everything is a group"

interface ExerciseGroup {
  readonly id: string
  readonly sessionId: string
  readonly orderIndex: number  // Position within session
  readonly name: string | null  // Optional label: "Heavy Block", null for auto-letter
}

interface ProgramExercise {
  readonly id: string
  readonly groupId: string  // Every exercise belongs to a group
  readonly exerciseId: string
  readonly orderWithinGroup: number  // Position: 0, 1, 2 for A1, A2, A3
  readonly setTypeLabel: string | null  // "HEAVY SINGLES", "BACK-OFF"
  readonly notes: string | null
  readonly restSeconds: number | null  // Rest AFTER this exercise (between exercises)
}

// Display logic derived from group size:
// - Group with 1 exercise: Standalone (A1 only, no line)
// - Group with 2 exercises: Bi-series/Superset (A1, A2, connected line)
// - Group with 3+ exercises: Circuit (A1, A2, A3..., connected line)
// - Letter advances per group: A, B, C, D...
```

### Pattern 3: Client-Side Grid State with Zustand

**What:** All grid edits happen locally via Zustand store; single mutation saves all changes.

**When to use:** Program grid editing with "Guardar" button.

**Structure:**
```typescript
// Source: Project standard - Zustand for client-side state

import { create } from 'zustand'
import type { GridData } from '@/components/programs/program-grid/types'
import type { PrescriptionSeriesInput } from '@strenly/contracts/programs/prescription'
import { formatSeriesToNotation } from '@strenly/contracts/programs/prescription'

interface GridState {
  data: GridData | null
  programId: string | null
  isDirty: boolean
  lastLoadedAt: Date | null
  changedPrescriptions: Map<string, { exerciseRowId: string; weekId: string; series: PrescriptionSeriesInput[] }>
}

interface GridActions {
  initialize: (programId: string, data: GridData) => void
  updatePrescription: (exerciseRowId: string, weekId: string, series: PrescriptionSeriesInput[]) => void
  reset: (data: GridData) => void
  markSaved: () => void
  getChanges: () => { prescriptions: any[]; lastLoadedAt: Date | null }
}

export const useGridStore = create<GridState & GridActions>((set, get) => ({
  data: null,
  programId: null,
  isDirty: false,
  lastLoadedAt: null,
  changedPrescriptions: new Map(),

  initialize: (programId, data) => set({
    programId,
    data,
    isDirty: false,
    lastLoadedAt: new Date(),
    changedPrescriptions: new Map(),
  }),

  updatePrescription: (exerciseRowId, weekId, series) => set((state) => {
    if (!state.data) return state
    // Update row immutably and track change
    const updatedRows = state.data.rows.map((row) => {
      if (row.type === 'exercise' && row.id === exerciseRowId) {
        return { ...row, prescriptions: { ...row.prescriptions, [weekId]: formatSeriesToNotation(series) } }
      }
      return row
    })
    const newChanged = new Map(state.changedPrescriptions)
    newChanged.set(`${exerciseRowId}:${weekId}`, { exerciseRowId, weekId, series })
    return { data: { ...state.data, rows: updatedRows }, isDirty: true, changedPrescriptions: newChanged }
  }),

  reset: (data) => set({ data, isDirty: false, lastLoadedAt: new Date(), changedPrescriptions: new Map() }),
  markSaved: () => set({ isDirty: false, changedPrescriptions: new Map() }),
  getChanges: () => ({ prescriptions: Array.from(get().changedPrescriptions.values()), lastLoadedAt: get().lastLoadedAt }),
}))

// Selectors for performance
export const useGridData = () => useGridStore((s) => s.data)
export const useGridIsDirty = () => useGridStore((s) => s.isDirty)
```

### Pattern 4: Prescription Notation Parsing to Series Array

**What:** Parse notation like "3x8@120kg + 1x1@130kg" into array of series.

**When to use:** When user types prescription notation.

**Structure:**
```typescript
// Extended from packages/contracts/src/programs/prescription.ts

// Parse input that may contain multiple prescription parts
function parsePrescriptionNotationToSeries(input: string): PrescriptionSeries[] | null {
  const trimmed = input.trim()
  if (trimmed === '' || trimmed === '-' || trimmed === '\u2014') {
    return []  // Empty/skip returns empty array
  }

  // Check for multi-part notation: "3x8@120kg + 1x1@130kg"
  const parts = trimmed.split(/\s*\+\s*/)

  const allSeries: PrescriptionSeries[] = []
  let orderIndex = 0

  for (const part of parts) {
    const parsed = parseSinglePrescription(part)  // Existing parser
    if (!parsed) return null  // Invalid part fails entire parse

    // Expand sets to series array
    for (let i = 0; i < parsed.sets; i++) {
      allSeries.push({
        orderIndex: orderIndex++,
        reps: parsed.isAmrap ? null : parsed.repsMin,
        repsMax: parsed.repsMax,  // For ranges
        isAmrap: parsed.isAmrap,
        intensityType: parsed.intensityType,
        intensityValue: parsed.intensityValue,
        tempo: parsed.tempo,
        restSeconds: null,
      })
    }
  }

  return allSeries
}

// Inverse: Format series array back to compact notation
function formatSeriesToNotation(series: PrescriptionSeries[]): string {
  if (series.length === 0) return '\u2014'  // Em dash for empty

  // Group consecutive identical series
  const groups = groupConsecutiveIdentical(series)

  return groups
    .map(group => formatGroup(group.count, group.template))
    .join(' + ')
}
```

### Pattern 5: Database Migration Strategy

**What:** Migrate from current structure to new series-based model with data transformation.

**When to use:** Database schema migration.

**Structure:**
```sql
-- Migration pseudo-code (executed via Drizzle migration)

-- Step 1: Create new tables
CREATE TABLE exercise_groups (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL REFERENCES program_sessions(id) ON DELETE CASCADE,
  order_index INTEGER NOT NULL,
  name TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Step 2: Add new columns to program_exercises
ALTER TABLE program_exercises
  ADD COLUMN group_id TEXT REFERENCES exercise_groups(id) ON DELETE CASCADE,
  ADD COLUMN order_within_group INTEGER;

-- Step 3: Migrate existing data
-- For each existing program_exercise:
--   1. Create exercise_group (or reuse if same supersetGroup)
--   2. Set group_id and order_within_group
--   3. Transform prescriptions.prescription JSONB to series array format

-- Step 4: Update prescriptions JSONB structure
-- Transform { sets: 3, repsMin: 8, ... }
-- to { series: [{orderIndex: 0, reps: 8, ...}, {orderIndex: 1, ...}, {orderIndex: 2, ...}] }

-- Step 5: Drop deprecated columns
ALTER TABLE program_exercises
  DROP COLUMN superset_group,
  DROP COLUMN superset_order,
  DROP COLUMN is_sub_row,
  DROP COLUMN parent_row_id;
```

### Anti-Patterns to Avoid

- **Storing series count separately**: The array length IS the count; no need for redundant `sets` field
- **Modifying server state directly in components**: Use local state with explicit save, not per-change mutations
- **Deep spread for nested updates**: Use immer to avoid `{...state, sessions: state.sessions.map(s => s.id === id ? {...s, groups: s.groups.map(...))}}`
- **Mixing old and new models**: Complete migration in one phase; don't leave hybrid state

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Immutable nested state updates | Manual spread operations | immer/use-immer | Error-prone, verbose for deeply nested program structure |
| Series equality comparison | Custom deep equals | JSON.stringify or lodash isEqual | Edge cases in object comparison |
| Optimistic update rollback | Manual cache manipulation | TanStack Query onMutate/onError pattern | Built-in rollback support |
| Prescription notation parsing | Regex from scratch | Extend existing parser | Already handles edge cases |
| JSONB migration | Raw SQL | Drizzle migration with custom SQL | Type-safe, reversible |

**Key insight:** The series array model is data structure, not UI complexity. The existing grid UI remains largely unchanged; only the data binding layer adapts to arrays.

## Common Pitfalls

### Pitfall 1: Over-Normalizing Series

**What goes wrong:** Creating a separate `prescription_series` table with foreign keys to prescriptions, requiring joins and complex queries.

**Why it happens:** Instinct to normalize everything relationally.

**How to avoid:** Keep series as JSONB array. Prescriptions are always fetched/updated atomically. The series array is the prescription; it's never queried independently.

**Warning signs:** Planning a `prescription_series` table, thinking about series foreign keys.

### Pitfall 2: Forgetting Dirty State Tracking

**What goes wrong:** User makes changes, navigates away, loses work with no warning.

**Why it happens:** Client-side state management added without navigation guards.

**How to avoid:**
- Track `isDirty` in reducer state
- Add `beforeunload` event listener when dirty
- Use router blocker (TanStack Router's `useBlocker`) for in-app navigation
- Show confirmation dialog on unsaved changes

**Warning signs:** No `isDirty` flag in state, no navigation warnings planned.

### Pitfall 3: Migration Data Loss

**What goes wrong:** Existing prescriptions don't convert correctly to new format.

**Why it happens:** Edge cases in current data not handled (AMRAP, ranges, null values).

**How to avoid:**
- Write reversible migration (up/down)
- Test migration on production data snapshot first
- Handle all edge cases: AMRAP (sets with reps: 0), rep ranges (repsMin/repsMax), null intensity
- Log any prescriptions that can't be migrated

**Warning signs:** Migration only tested on seed data, no production data audit.

### Pitfall 4: Display Collision in Multi-Series Cells

**What goes wrong:** Multiple series render overlapping or unclear in same cell.

**Why it happens:** Cell height fixed, no design for multi-line prescription display.

**How to avoid:**
- Design multi-line cell rendering upfront
- Each series on own line within cell
- Consider max-height with scroll for extreme cases (5+ series)
- Compact notation for identical series: "3x8@120kg" not "8@120 / 8@120 / 8@120"

**Warning signs:** Cell height discussions deferred, no mockup for multi-series display.

### Pitfall 5: Performance with Large Programs

**What goes wrong:** Grid becomes sluggish with many sessions/exercises/weeks.

**Why it happens:** Re-rendering entire grid on any state change.

**How to avoid:**
- Memoize row components with React.memo
- Use shallow equality checks on props
- Consider virtualization for very large programs (react-virtual)
- Profile with React DevTools Profiler

**Warning signs:** No React.memo on row components, no performance testing plan.

## Code Examples

### Example 1: Prescription Series Domain Entity

```typescript
// Source: Clean Architecture pattern from packages/core

import { err, ok, type Result } from 'neverthrow'

export interface PrescriptionSeriesProps {
  readonly orderIndex: number
  readonly reps: number | null
  readonly isAmrap: boolean
  readonly intensityType: IntensityType | null
  readonly intensityValue: number | null
  readonly tempo: string | null
  readonly restSeconds: number | null
}

export type PrescriptionSeriesError =
  | { type: 'REPS_INVALID'; message: string }
  | { type: 'AMRAP_WITH_REPS'; message: string }
  | { type: 'INTENSITY_VALUE_REQUIRED'; message: string }
  // ... other errors

type CreateSeriesInput = Omit<PrescriptionSeriesProps, 'orderIndex'> & {
  orderIndex?: number
}

export function createPrescriptionSeries(
  input: CreateSeriesInput,
  index: number
): Result<PrescriptionSeriesProps, PrescriptionSeriesError> {
  // AMRAP validation
  if (input.isAmrap && input.reps !== null && input.reps > 0) {
    return err({ type: 'AMRAP_WITH_REPS', message: 'AMRAP series should not have fixed reps' })
  }

  // Non-AMRAP needs reps
  if (!input.isAmrap && (input.reps === null || input.reps < 1)) {
    return err({ type: 'REPS_INVALID', message: 'Reps required for non-AMRAP series' })
  }

  // Intensity validation (same as current)
  if (input.intensityType && input.intensityValue === null) {
    return err({ type: 'INTENSITY_VALUE_REQUIRED', message: 'Intensity value required' })
  }

  return ok({
    orderIndex: input.orderIndex ?? index,
    reps: input.reps,
    isAmrap: input.isAmrap,
    intensityType: input.intensityType ?? null,
    intensityValue: input.intensityValue ?? null,
    tempo: input.tempo ?? null,
    restSeconds: input.restSeconds ?? null,
  })
}
```

### Example 2: Grid State Store with Zustand

```typescript
// Source: Project standard - Zustand for client-side state

import { create } from 'zustand'
import type { GridData } from '@/components/programs/program-grid/types'
import type { PrescriptionSeriesInput } from '@strenly/contracts/programs/prescription'
import { formatSeriesToNotation } from '@strenly/contracts/programs/prescription'

interface GridState {
  data: GridData | null
  programId: string | null
  isDirty: boolean
  changedPrescriptions: Map<string, { exerciseRowId: string; weekId: string; series: PrescriptionSeriesInput[] }>
}

interface GridActions {
  initialize: (programId: string, data: GridData) => void
  updatePrescription: (exerciseRowId: string, weekId: string, series: PrescriptionSeriesInput[]) => void
  markSaved: () => void
  getChanges: () => { prescriptions: any[] }
}

export const useGridStore = create<GridState & GridActions>((set, get) => ({
  data: null,
  programId: null,
  isDirty: false,
  changedPrescriptions: new Map(),

  initialize: (programId, data) => set({
    programId,
    data,
    isDirty: false,
    changedPrescriptions: new Map(),
  }),

  updatePrescription: (exerciseRowId, weekId, series) => set((state) => {
    if (!state.data) return state
    const updatedRows = state.data.rows.map((row) => {
      if (row.type === 'exercise' && row.id === exerciseRowId) {
        return { ...row, prescriptions: { ...row.prescriptions, [weekId]: formatSeriesToNotation(series) } }
      }
      return row
    })
    const newChanged = new Map(state.changedPrescriptions)
    newChanged.set(`${exerciseRowId}:${weekId}`, { exerciseRowId, weekId, series })
    return { data: { ...state.data, rows: updatedRows }, isDirty: true, changedPrescriptions: newChanged }
  }),

  markSaved: () => set({ isDirty: false, changedPrescriptions: new Map() }),
  getChanges: () => ({ prescriptions: Array.from(get().changedPrescriptions.values()) }),
}))

// Selector hooks
export const useGridData = () => useGridStore((s) => s.data)
export const useGridIsDirty = () => useGridStore((s) => s.isDirty)
```

### Example 3: Save Button with Dirty State

```typescript
// Source: TanStack Query mutation pattern

import { useMutation, useQueryClient } from '@tanstack/react-query'
import { Button } from '@/components/ui/button'
import { orpc } from '@/lib/api-client'

interface SaveButtonProps {
  programId: string
  isDirty: boolean
  state: GridState
  onSaved: () => void
}

export function SaveButton({ programId, isDirty, state, onSaved }: SaveButtonProps) {
  const queryClient = useQueryClient()

  const saveMutation = useMutation({
    mutationFn: (data: SaveProgramInput) =>
      orpc.programs.saveDraft.mutate(data),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: orpc.programs.get.queryOptions({ input: { programId } }).queryKey,
      })
      onSaved()
    },
  })

  const handleSave = () => {
    // Transform state to API input format
    const input = transformStateToSaveInput(state)
    saveMutation.mutate(input)
  }

  return (
    <Button
      onClick={handleSave}
      disabled={!isDirty || saveMutation.isPending}
    >
      {saveMutation.isPending ? 'Guardando...' : 'Guardar'}
    </Button>
  )
}
```

### Example 4: JSONB Series Schema with Drizzle

```typescript
// Source: https://orm.drizzle.team/docs/column-types/pg

import { jsonb, pgTable, text, timestamp, integer } from 'drizzle-orm/pg-core'

// Series structure for JSONB
interface PrescriptionSeriesData {
  orderIndex: number
  reps: number | null
  isAmrap: boolean
  intensityType: 'absolute' | 'percentage' | 'rpe' | 'rir' | null
  intensityValue: number | null
  tempo: string | null
  restSeconds: number | null
}

// Updated prescriptions table
export const prescriptions = pgTable('prescriptions', {
  id: text('id').primaryKey(),
  programExerciseId: text('program_exercise_id')
    .notNull()
    .references(() => programExercises.id, { onDelete: 'cascade' }),
  weekId: text('week_id')
    .notNull()
    .references(() => programWeeks.id, { onDelete: 'cascade' }),
  // NEW: Series array instead of flat prescription
  series: jsonb('series').$type<PrescriptionSeriesData[]>().notNull().default([]),
  notes: text('notes'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().$onUpdate(() => new Date()).notNull(),
})

// Exercise groups table
export const exerciseGroups = pgTable('exercise_groups', {
  id: text('id').primaryKey(),
  sessionId: text('session_id')
    .notNull()
    .references(() => programSessions.id, { onDelete: 'cascade' }),
  orderIndex: integer('order_index').notNull(),
  name: text('name'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().$onUpdate(() => new Date()).notNull(),
})
```

### Example 5: Multi-Line Prescription Cell Display

```typescript
// Source: UI pattern for multi-series display

interface PrescriptionCellProps {
  series: PrescriptionSeries[]
  // ... other props
}

export function PrescriptionCell({ series, ...props }: PrescriptionCellProps) {
  // Group consecutive identical series for compact notation
  const displayLines = useMemo(() => formatSeriesForDisplay(series), [series])

  return (
    <td className="...">
      <div className="flex flex-col justify-center min-h-10 py-1">
        {displayLines.length === 0 ? (
          <span className="text-muted-foreground">{'\u2014'}</span>
        ) : displayLines.length === 1 ? (
          <span>{displayLines[0]}</span>
        ) : (
          // Multi-line: each series group on its own line
          displayLines.map((line, i) => (
            <span key={i} className="text-xs leading-tight">
              {line}
            </span>
          ))
        )}
      </div>
    </td>
  )
}

// Format series array to display lines
function formatSeriesForDisplay(series: PrescriptionSeries[]): string[] {
  if (series.length === 0) return []

  const groups = groupConsecutiveIdentical(series)

  // If all identical, single line with count
  if (groups.length === 1) {
    return [formatGroupNotation(groups[0])]
  }

  // Multiple different groups: one line each
  return groups.map(formatGroupNotation)
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `sets: 3` as single number | Series array `[{...}, {...}, {...}]` | This phase | Enables per-set variations (top sets, drop sets, wave loading) |
| `supersetGroup`/`supersetOrder` columns | Exercise groups table | This phase | Unified model for standalone/superset/circuit |
| Per-change auto-save mutations | Client-side state + explicit save | This phase | Faster UX, reduced API calls, simpler conflict handling |
| Split rows for variations | Multi-series in single cell | This phase | Cleaner grid, no row proliferation |

**Deprecated/outdated:**
- `program_exercises.superset_group/superset_order`: Replaced by `exercise_groups` table
- `program_exercises.is_sub_row/parent_row_id`: Split rows eliminated; use multi-series array
- `ParsedPrescription.sets`: No longer needed; `series.length` is the count
- `useUpdatePrescription` per-cell mutation: Replaced by single `useSaveDraft` mutation

## Open Questions

1. **Maximum series count per cell**
   - What we know: UI needs to handle variable series counts
   - What's unclear: Is there a practical maximum? 10 sets? 20?
   - Recommendation: Soft limit of 10 series per cell in UI (warn but allow), domain allows 1-20

2. **Rest period granularity**
   - What we know: Rest can be per-exercise (after exercise in group) or per-series (intra-set)
   - What's unclear: How to display/edit intra-set rest for clusters?
   - Recommendation: Start with per-exercise rest only; add per-series rest in future phase

3. **Undo/redo support**
   - What we know: Client-side state enables undo; immer produces patches
   - What's unclear: Is undo/redo MVP for this phase?
   - Recommendation: Defer to future phase; basic reset-to-saved is sufficient

4. **Conflict handling for concurrent edits**
   - What we know: Multiple browser tabs or coach/athlete simultaneous edits possible
   - What's unclear: How aggressive should conflict detection be?
   - Recommendation: Simple "last write wins" with timestamp check; warn if server newer

## Sources

### Primary (HIGH confidence)
- `/Users/tomiardz/Projects/treino/docs/domain-research-strength-training.md` - Domain concepts, prescription structure
- `/Users/tomiardz/Projects/treino/packages/core/src/domain/entities/prescription.ts` - Current entity structure
- `/Users/tomiardz/Projects/treino/packages/database/src/schema/prescriptions.ts` - Current database schema
- [immer documentation](https://immerjs.github.io/immer/) - Immutable state updates
- [use-immer GitHub](https://github.com/immerjs/use-immer) - React hooks for immer
- [TanStack Query optimistic updates](https://tanstack.com/query/v5/docs/framework/react/guides/optimistic-updates) - Mutation patterns
- [Drizzle ORM JSONB types](https://orm.drizzle.team/docs/column-types/pg) - JSONB column definitions

### Secondary (MEDIUM confidence)
- [Simple Table: In-Cell vs Form-Based Editing](https://www.simple-table.com/blog/editable-react-data-grids-in-cell-vs-form-editing) - Grid editing patterns
- [React useReducer](https://react.dev/reference/react/useReducer) - Reducer hook usage
- [TkDodo: Concurrent Optimistic Updates](https://tkdodo.eu/blog/concurrent-optimistic-updates-in-react-query) - Advanced mutation patterns

### Tertiary (LOW confidence)
- Web search results on 2026 state management patterns - General ecosystem direction

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - immer/use-immer are established; existing stack continues
- Architecture: HIGH - Pattern derived from domain research and current codebase analysis
- Pitfalls: MEDIUM - Based on similar migrations and client-side state patterns
- Migration: MEDIUM - JSONB structure changes tested conceptually, not on production data

**Research date:** 2026-01-25
**Valid until:** 2026-02-25 (30 days - stable domain, known stack)
