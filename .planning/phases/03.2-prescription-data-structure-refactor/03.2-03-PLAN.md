---
phase: 03.2-prescription-data-structure-refactor
plan: 03
type: tdd
wave: 3
depends_on: ["03.2-02"]
files_modified:
  - packages/contracts/src/programs/prescription.ts
  - packages/contracts/src/programs/prescription.test.ts
autonomous: true

must_haves:
  truths:
    - "Parser handles multi-part notation like '3x8@120kg + 1x1@130kg'"
    - "Parser expands notation to series array"
    - "Formatter compacts series array back to notation"
    - "All existing single-notation patterns still work"
  artifacts:
    - path: "packages/contracts/src/programs/prescription.ts"
      provides: "Updated parser with series array support"
      exports: ["parsePrescriptionToSeries", "formatSeriesToNotation", "PrescriptionSeriesInput"]
    - path: "packages/contracts/src/programs/prescription.test.ts"
      provides: "Parser tests for multi-notation"
      min_lines: 100
  key_links:
    - from: "packages/contracts/src/programs/prescription.ts"
      to: "apps/coach-web/src/components/programs/program-grid/prescription-cell.tsx"
      via: "import parser"
      pattern: "parsePrescriptionToSeries"
---

<objective>
Update prescription notation parser to support multi-part notation and series array output using TDD.

Purpose: Enable parsing of flexible prescriptions like "3x8@120kg + 1x1@130kg" into an array of series objects. This is the bridge between user input notation and the new series array data model.

Output:
- New parsePrescriptionToSeries() function that returns array of series
- New formatSeriesToNotation() function for display
- Updated schemas for series input
- Comprehensive tests
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-RESEARCH.md
@.planning/phases/03.2-prescription-data-structure-refactor/03.2-02-SUMMARY.md

@packages/contracts/src/programs/prescription.ts
</context>

<feature>
  <name>Multi-Part Prescription Notation Parser</name>
  <files>
    packages/contracts/src/programs/prescription.ts
    packages/contracts/src/programs/prescription.test.ts
  </files>
  <behavior>
The parser expands notation to a series array where each element represents one set:

Input: "3x8@120kg"
Output: [
  {orderIndex: 0, reps: 8, isAmrap: false, intensityType: 'absolute', intensityValue: 120, intensityUnit: 'kg', ...},
  {orderIndex: 1, reps: 8, isAmrap: false, intensityType: 'absolute', intensityValue: 120, intensityUnit: 'kg', ...},
  {orderIndex: 2, reps: 8, isAmrap: false, intensityType: 'absolute', intensityValue: 120, intensityUnit: 'kg', ...}
]

Input: "3x8@120kg + 1x1@130kg"
Output: [
  {orderIndex: 0, reps: 8, ...intensityValue: 120...},
  {orderIndex: 1, reps: 8, ...intensityValue: 120...},
  {orderIndex: 2, reps: 8, ...intensityValue: 120...},
  {orderIndex: 3, reps: 1, ...intensityValue: 130...}
]

Test cases:
- parsePrescriptionToSeries("") -> [] (empty)
- parsePrescriptionToSeries("—") -> [] (skip)
- parsePrescriptionToSeries("-") -> [] (skip)
- parsePrescriptionToSeries("3x8") -> 3 series with reps: 8
- parsePrescriptionToSeries("3x8@120kg") -> 3 series with intensity
- parsePrescriptionToSeries("3x8-12") -> 3 series with rep range
- parsePrescriptionToSeries("3xAMRAP") -> 3 series with isAmrap: true
- parsePrescriptionToSeries("3x8@120kg + 1x1@130kg") -> 4 series (3+1)
- parsePrescriptionToSeries("2x8@120 + 2x8@100 + 1x10@80") -> 5 series
- parsePrescriptionToSeries("invalid") -> null (unparseable)
- parsePrescriptionToSeries("3x8 + invalid") -> null (partial invalid fails all)

Formatter (inverse):
- formatSeriesToNotation([]) -> "—"
- formatSeriesToNotation([{reps: 8}x3]) -> "3x8" (compact identical)
- formatSeriesToNotation([{reps: 8, intensity: 120}x3, {reps: 1, intensity: 130}x1]) -> "3x8@120kg + 1x1@130kg"
  </behavior>
  <implementation>
1. Add PrescriptionSeriesInput schema (for validated input)
2. Keep existing parsePrescriptionNotation() for backward compatibility
3. Create parsePrescriptionToSeries(input: string): PrescriptionSeriesInput[] | null
   - Split on " + " to get parts
   - Parse each part with existing parsePrescriptionNotation()
   - Expand each part's sets into individual series objects
   - Assign sequential orderIndex
4. Create formatSeriesToNotation(series: PrescriptionSeriesInput[]): string
   - Group consecutive identical series
   - Format each group with count prefix
   - Join groups with " + "
5. Helper: groupConsecutiveIdentical(series) -> groups with count and template
  </implementation>
</feature>

<verification>
Run TDD cycle:
```bash
# Create or update test file first
pnpm test --filter @strenly/contracts -- prescription.test.ts --watch

# Implement to pass tests

# Full test run
pnpm test --filter @strenly/contracts
pnpm typecheck --filter @strenly/contracts
```
</verification>

<success_criteria>
- [ ] parsePrescriptionToSeries() function exists and returns series array
- [ ] formatSeriesToNotation() function exists and returns compact notation
- [ ] PrescriptionSeriesInput schema defined
- [ ] All existing single-notation tests still pass
- [ ] New multi-notation tests pass
- [ ] Round-trip: parse -> format -> parse yields equivalent result
- [ ] No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-prescription-data-structure-refactor/03.2-03-SUMMARY.md`
</output>
