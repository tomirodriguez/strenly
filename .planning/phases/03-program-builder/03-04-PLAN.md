---
phase: 03-program-builder
plan: 04
type: execute
wave: 2
depends_on: ["03-01", "03-03"]
files_modified:
  - packages/core/src/ports/program-repository.port.ts
  - packages/backend/src/infrastructure/repositories/program.repository.ts
autonomous: true

must_haves:
  truths:
    - "Program repository port defines all required operations"
    - "Repository implementation uses Drizzle ORM for database access"
    - "All queries filter by organizationId for multi-tenancy"
    - "Nested data (weeks, sessions, exercises, prescriptions) can be fetched efficiently"
  artifacts:
    - path: "packages/core/src/ports/program-repository.port.ts"
      provides: "Program repository interface"
      exports: ["ProgramRepositoryPort"]
    - path: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      provides: "Program repository implementation"
      exports: ["createProgramRepository"]
  key_links:
    - from: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      to: "packages/database/src/schema/programs.ts"
      via: "Drizzle query"
      pattern: "programsTable"
---

<objective>
Create the program repository port and implementation following Clean Architecture patterns.

Purpose: Establish data access layer for programs with proper multi-tenancy isolation.
Output: Repository port in core package, Drizzle implementation in backend package.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-program-builder/03-01-SUMMARY.md
@.planning/phases/03-program-builder/03-03-SUMMARY.md
@packages/core/src/ports/exercise-repository.port.ts
@packages/backend/src/infrastructure/repositories/exercise.repository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create program repository port</name>
  <files>packages/core/src/ports/program-repository.port.ts</files>
  <action>
Create the ProgramRepositoryPort interface with methods:

```typescript
export interface ProgramRepositoryPort {
  // Basic CRUD
  create(program: Program, context: OrganizationContext): Promise<Program>
  findById(id: string, context: OrganizationContext): Promise<Program | null>
  update(program: Program, context: OrganizationContext): Promise<Program>

  // Listing with filters
  list(filters: ProgramFilters, context: OrganizationContext): Promise<{ items: Program[], totalCount: number }>

  // Full program with nested data for grid view
  findWithDetails(id: string, context: OrganizationContext): Promise<ProgramWithDetails | null>

  // Template operations
  listTemplates(context: OrganizationContext): Promise<Program[]>

  // Week operations
  createWeek(programId: string, week: ProgramWeek, context: OrganizationContext): Promise<ProgramWeek>
  updateWeek(week: ProgramWeek, context: OrganizationContext): Promise<ProgramWeek>
  deleteWeek(weekId: string, context: OrganizationContext): Promise<void>

  // Session operations
  createSession(programId: string, session: ProgramSession, context: OrganizationContext): Promise<ProgramSession>
  updateSession(session: ProgramSession, context: OrganizationContext): Promise<ProgramSession>
  deleteSession(sessionId: string, context: OrganizationContext): Promise<void>

  // Exercise row operations
  createExerciseRow(sessionId: string, row: ProgramExerciseRow, context: OrganizationContext): Promise<ProgramExerciseRow>
  updateExerciseRow(row: ProgramExerciseRow, context: OrganizationContext): Promise<ProgramExerciseRow>
  deleteExerciseRow(rowId: string, context: OrganizationContext): Promise<void>

  // Prescription operations (cell values)
  upsertPrescription(exerciseRowId: string, weekId: string, prescription: Prescription | null, context: OrganizationContext): Promise<void>

  // Bulk operations for performance
  reorderExerciseRows(sessionId: string, rowIds: string[], context: OrganizationContext): Promise<void>
  duplicateWeek(weekId: string, newName: string, context: OrganizationContext): Promise<ProgramWeek>
}
```

Define supporting types: ProgramFilters, ProgramWithDetails, ProgramWeek, ProgramSession, ProgramExerciseRow.
Follow patterns from exercise-repository.port.ts.
  </action>
  <verify>pnpm typecheck in packages/core</verify>
  <done>ProgramRepositoryPort interface exists with all required methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement program repository</name>
  <files>packages/backend/src/infrastructure/repositories/program.repository.ts</files>
  <action>
Implement createProgramRepository factory function that returns ProgramRepositoryPort.

Key implementation details:
1. All queries MUST filter by organizationId from context
2. Use Drizzle's `with` clause for eager loading nested data in findWithDetails
3. Use transactions for operations that touch multiple tables
4. Handle JSONB prescription data correctly (parse on read, stringify on write)
5. Implement upsertPrescription with ON CONFLICT for efficient updates

For findWithDetails, fetch in order to build the grid structure:
- Program with weeks (ordered by orderIndex)
- Sessions (ordered by orderIndex)
- Exercise rows per session (ordered by orderIndex)
- Prescriptions per exercise row (keyed by weekId)

Follow patterns from exercise.repository.ts for:
- Database connection from `getDb()`
- Error handling
- mapToDomain/mapToDb helper functions
  </action>
  <verify>pnpm typecheck in packages/backend</verify>
  <done>Program repository implementation complete with all methods</done>
</task>

</tasks>

<verification>
1. Run `pnpm typecheck` - both packages type-check correctly
2. Verify all port methods are implemented
3. Verify organizationId filtering in all queries
4. Verify transaction usage for multi-table operations
</verification>

<success_criteria>
- Port defines complete interface for program operations
- Repository implements all port methods
- All queries enforce multi-tenancy via organizationId
- Nested data loading is efficient (minimal N+1 queries)
- JSONB prescription data handled correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-program-builder/03-04-SUMMARY.md`
</output>
