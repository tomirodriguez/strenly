---
phase: 03-program-builder
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/contracts/src/programs/prescription.ts
  - packages/contracts/src/programs/prescription.test.ts
autonomous: true

must_haves:
  truths:
    - "Prescription notation parser handles all supported formats"
    - "Parser returns null for skip notation (em dash)"
    - "Parser returns structured data for valid prescriptions"
    - "Formatter converts structured data back to notation string"
  artifacts:
    - path: "packages/contracts/src/programs/prescription.ts"
      provides: "Prescription notation parser and formatter"
      exports: ["parsePrescriptionNotation", "formatPrescription", "parsedPrescriptionSchema"]
    - path: "packages/contracts/src/programs/prescription.test.ts"
      provides: "Tests for prescription notation parser"
      min_lines: 100
  key_links:
    - from: "packages/contracts/src/programs/prescription.ts"
      to: "prescription notation patterns"
      via: "regex parsing"
      pattern: "parsePrescriptionNotation"
---

<objective>
Implement the prescription notation parser using TDD - parse natural notation like "3x8@120kg" into structured data.

Purpose: Enable Excel-like data entry where coaches type natural notation that converts to structured prescription data.
Output: Type-safe prescription parser with comprehensive test coverage.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-program-builder/03-RESEARCH.md
@packages/contracts/src/athletes/athlete.ts
</context>

<feature>
  <name>Prescription Notation Parser</name>
  <files>
    packages/contracts/src/programs/prescription.ts
    packages/contracts/src/programs/prescription.test.ts
  </files>
  <behavior>
Parse prescription notation strings into structured data. Supported patterns:

| Input | Expected Output |
|-------|-----------------|
| `â€”` or `-` | null (skip) |
| `3x8` | { sets: 3, repsMin: 8, repsMax: null, isAmrap: false, ... } |
| `3x8-12` | { sets: 3, repsMin: 8, repsMax: 12, ... } |
| `3xAMRAP` | { sets: 3, repsMin: 0, repsMax: null, isAmrap: true, ... } |
| `3x12/leg` | { sets: 3, repsMin: 12, isUnilateral: true, unilateralUnit: 'leg', ... } |
| `3x8@120kg` | { ..., intensityType: 'absolute', intensityValue: 120, intensityUnit: 'kg' } |
| `3x8@75%` | { ..., intensityType: 'percentage', intensityValue: 75, intensityUnit: '%' } |
| `3x8@RIR2` | { ..., intensityType: 'rir', intensityValue: 2, intensityUnit: 'rir' } |
| `3x8@RPE8` | { ..., intensityType: 'rpe', intensityValue: 8, intensityUnit: 'rpe' } |
| `3x8@120kg (3110)` | { ..., tempo: '3110' } |
| `3x8@120kg (31X0)` | { ..., tempo: '31X0' } |

Formatter should round-trip: formatPrescription(parsePrescriptionNotation(input)) === input (normalized)
  </behavior>
  <implementation>
1. Create Zod schema for ParsedPrescription type
2. Implement parsePrescriptionNotation function with regex patterns
3. Implement formatPrescription function for display
4. Handle case-insensitivity (3X8, 3x8, RIR2, rir2, RPE8, rpe8)
5. Normalize output (uppercase X in tempo, lowercase units)

Reference the regex patterns from 03-RESEARCH.md code examples.
  </implementation>
</feature>

<verification>
1. Run `pnpm test` in packages/contracts - all parser tests pass
2. Test edge cases: whitespace variations, case variations
3. Round-trip test: parse then format returns equivalent notation
</verification>

<success_criteria>
- All supported notation patterns parse correctly (12+ test cases)
- Invalid notation returns null (unparseable)
- Formatter produces canonical notation from parsed data
- 100% test coverage on parser functions
</success_criteria>

<output>
After completion, create `.planning/phases/03-program-builder/03-02-SUMMARY.md`
</output>
