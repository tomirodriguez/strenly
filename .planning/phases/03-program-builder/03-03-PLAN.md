---
phase: 03-program-builder
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/core/src/domain/entities/program.ts
  - packages/core/src/domain/entities/program.test.ts
  - packages/core/src/domain/entities/prescription.ts
  - packages/core/src/domain/entities/prescription.test.ts
autonomous: true

must_haves:
  truths:
    - "Program entity validates name and status transitions"
    - "Prescription entity validates sets, reps, and intensity bounds"
    - "Domain entities are immutable with factory functions returning Result"
    - "Test coverage meets 90%+ requirement for core package"
  artifacts:
    - path: "packages/core/src/domain/entities/program.ts"
      provides: "Program domain entity with createProgram factory"
      exports: ["Program", "createProgram", "ProgramStatus", "isProgramStatus"]
    - path: "packages/core/src/domain/entities/program.test.ts"
      provides: "Program entity tests"
      min_lines: 80
    - path: "packages/core/src/domain/entities/prescription.ts"
      provides: "Prescription domain entity with validation"
      exports: ["Prescription", "createPrescription"]
    - path: "packages/core/src/domain/entities/prescription.test.ts"
      provides: "Prescription entity tests"
      min_lines: 60
  key_links:
    - from: "packages/core/src/domain/entities/program.ts"
      to: "neverthrow Result"
      via: "factory function"
      pattern: "Result<Program,"
---

<objective>
Create Program and Prescription domain entities with validation rules using TDD.

Purpose: Establish domain invariants for programs and prescriptions following Clean Architecture.
Output: Immutable domain entities with comprehensive test coverage.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-program-builder/03-RESEARCH.md
@packages/core/src/domain/entities/exercise.ts
@packages/core/src/domain/entities/athlete.ts
</context>

<feature>
  <name>Program Domain Entity</name>
  <files>
    packages/core/src/domain/entities/program.ts
    packages/core/src/domain/entities/program.test.ts
  </files>
  <behavior>
Program entity with validation:

| Test Case | Input | Expected |
|-----------|-------|----------|
| Valid program | { name: "Hypertrophy Block", organizationId: "org-1" } | Ok(Program) |
| Empty name | { name: "", ... } | Err("name_required") |
| Name too short | { name: "AB", ... } | Err("name_too_short") |
| Name too long | { name: "A".repeat(101), ... } | Err("name_too_long") |
| Valid status transition | draft -> active | Ok(Program) |
| Invalid status transition | archived -> draft | Err("invalid_status_transition") |
| Template without athlete | { isTemplate: true, athleteId: null } | Ok(Program) |
| Non-template with athlete | { isTemplate: false, athleteId: "ath-1" } | Ok(Program) |

Status enum: 'draft' | 'active' | 'archived'
Status transitions: draft -> active -> archived (no going back)
  </behavior>
  <implementation>
Follow the pattern from athlete.ts:
1. Define ProgramStatus const array and isProgramStatus type guard
2. Define Program type with readonly properties
3. Implement createProgram factory returning Result<Program, ProgramError>
4. Implement activate() and archive() methods for status transitions
5. Use neverthrow ok/err for Result type
  </implementation>
</feature>

<feature>
  <name>Prescription Domain Entity</name>
  <files>
    packages/core/src/domain/entities/prescription.ts
    packages/core/src/domain/entities/prescription.test.ts
  </files>
  <behavior>
Prescription entity with validation:

| Test Case | Input | Expected |
|-----------|-------|----------|
| Valid prescription | { sets: 3, repsMin: 8, ... } | Ok(Prescription) |
| Sets < 1 | { sets: 0, ... } | Err("sets_invalid") |
| Sets > 20 | { sets: 21, ... } | Err("sets_invalid") |
| Reps negative | { repsMin: -1, ... } | Err("reps_invalid") |
| Reps max < min | { repsMin: 12, repsMax: 8, ... } | Err("reps_range_invalid") |
| AMRAP with reps | { isAmrap: true, repsMin: 8, ... } | Err("amrap_with_reps") |
| Percentage > 100 | { intensityType: 'percentage', intensityValue: 150, ... } | Err("percentage_invalid") |
| RPE > 10 | { intensityType: 'rpe', intensityValue: 11, ... } | Err("rpe_invalid") |
| RIR > 10 | { intensityType: 'rir', intensityValue: 11, ... } | Err("rir_invalid") |
| Invalid tempo | { tempo: "123", ... } | Err("tempo_invalid") |
| Valid tempo with X | { tempo: "31X0", ... } | Ok(Prescription) |
  </behavior>
  <implementation>
1. Define Prescription type matching ParsedPrescription from contracts
2. Implement createPrescription factory with comprehensive validation
3. Validate intensity value bounds based on intensityType
4. Validate tempo format (4 characters, digits or X)
5. Handle null/optional fields correctly
  </implementation>
</feature>

<verification>
1. Run `pnpm test` in packages/core - all entity tests pass
2. Check test coverage meets 90%+ threshold
3. Verify immutability (no setters, factory functions only)
</verification>

<success_criteria>
- Program entity validates name length (3-100 chars)
- Program entity enforces status transition rules
- Prescription entity validates all bounds (sets, reps, intensity)
- All domain errors have descriptive codes
- Test coverage >= 90%
</success_criteria>

<output>
After completion, create `.planning/phases/03-program-builder/03-03-SUMMARY.md`
</output>
