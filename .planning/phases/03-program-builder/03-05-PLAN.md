---
phase: 03-program-builder
plan: 05
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - packages/backend/src/use-cases/programs/create-program.ts
  - packages/backend/src/use-cases/programs/get-program.ts
  - packages/backend/src/use-cases/programs/list-programs.ts
  - packages/backend/src/use-cases/programs/update-program.ts
  - packages/backend/src/use-cases/programs/archive-program.ts
  - packages/backend/src/use-cases/programs/duplicate-program.ts
autonomous: true

must_haves:
  truths:
    - "Use cases check authorization before any business logic"
    - "Use cases return ResultAsync with discriminated union errors"
    - "Programs can be created for specific athletes or as templates"
    - "Duplicate creates deep copy with new IDs for all nested entities"
  artifacts:
    - path: "packages/backend/src/use-cases/programs/create-program.ts"
      provides: "Create program use case"
      exports: ["createProgramUseCase"]
    - path: "packages/backend/src/use-cases/programs/get-program.ts"
      provides: "Get program with full details for grid"
      exports: ["getProgramUseCase"]
    - path: "packages/backend/src/use-cases/programs/list-programs.ts"
      provides: "List programs with pagination"
      exports: ["listProgramsUseCase"]
    - path: "packages/backend/src/use-cases/programs/duplicate-program.ts"
      provides: "Deep copy program with new IDs"
      exports: ["duplicateProgramUseCase"]
  key_links:
    - from: "packages/backend/src/use-cases/programs/create-program.ts"
      to: "packages/core/src/domain/entities/program.ts"
      via: "createProgram factory"
      pattern: "createProgram"
---

<objective>
Implement program CRUD use cases following Clean Architecture patterns.

Purpose: Orchestrate business logic for program management with proper authorization.
Output: Use cases for create, read, update, list, archive, and duplicate programs.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-program-builder/03-03-SUMMARY.md
@.planning/phases/03-program-builder/03-04-SUMMARY.md
@packages/backend/src/use-cases/exercises/create-exercise.ts
@packages/backend/src/use-cases/athletes/list-athletes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create program CRUD use cases</name>
  <files>
    packages/backend/src/use-cases/programs/create-program.ts
    packages/backend/src/use-cases/programs/get-program.ts
    packages/backend/src/use-cases/programs/list-programs.ts
    packages/backend/src/use-cases/programs/update-program.ts
    packages/backend/src/use-cases/programs/archive-program.ts
  </files>
  <action>
Create use cases following the established patterns:

**createProgramUseCase:**
- Authorization: Check hasPermission('program:create')
- Validate input via createProgram domain factory
- If athleteId provided, verify athlete exists in organization
- Save via repository.create()
- Create default week ("Semana 1") and session ("D√çA 1")
- Return created program

**getProgramUseCase:**
- Authorization: Check hasPermission('program:read')
- Use repository.findWithDetails() for full nested data
- Return ProgramWithDetails for grid rendering
- Return not_found error if program doesn't exist

**listProgramsUseCase:**
- Authorization: Check hasPermission('program:read')
- Support filters: athleteId, isTemplate, status, search (name)
- Return { items: Program[], totalCount: number }
- Support pagination (page, pageSize)

**updateProgramUseCase:**
- Authorization: Check hasPermission('program:update')
- Merge input with existing program
- Validate via domain entity
- Save via repository.update()

**archiveProgramUseCase:**
- Authorization: Check hasPermission('program:delete')
- Use program.archive() method for status transition
- Save via repository.update()
  </action>
  <verify>pnpm typecheck in packages/backend</verify>
  <done>Program CRUD use cases implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create duplicate program use case</name>
  <files>packages/backend/src/use-cases/programs/duplicate-program.ts</files>
  <action>
Implement duplicateProgramUseCase for deep copying programs:

1. Authorization: Check hasPermission('program:create')
2. Fetch source program with full details
3. Generate new IDs for ALL nested entities:
   - New program ID
   - New week IDs (preserve order)
   - New session IDs (preserve order)
   - New exercise row IDs (preserve order)
   - New prescription IDs
4. Preserve all data except:
   - IDs (generate new)
   - athleteId (set to input.athleteId or null)
   - isTemplate (set to input.isTemplate or false)
   - status (reset to 'draft')
   - timestamps (set to now)
5. Use transaction for atomicity
6. Return new program with details

This is critical for:
- Creating program from template (TPL-02)
- Duplicating entire programs (PRG-08)
  </action>
  <verify>pnpm typecheck in packages/backend</verify>
  <done>Duplicate program use case creates deep copy with new IDs</done>
</task>

</tasks>

<verification>
1. Run `pnpm typecheck` - all use cases type-check correctly
2. Verify authorization check is FIRST in every use case
3. Verify error types follow discriminated union pattern
4. Verify duplicate creates completely independent copy
</verification>

<success_criteria>
- All CRUD operations have corresponding use cases
- Authorization checked before any business logic
- Duplicate creates deep copy with all nested entities
- Error handling uses ResultAsync with typed errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-program-builder/03-05-SUMMARY.md`
</output>
