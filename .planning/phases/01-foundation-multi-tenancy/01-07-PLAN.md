---
phase: 01-foundation-multi-tenancy
plan: 07
type: execute
wave: 4
depends_on: ["01-06"]
gap_closure: true
files_modified:
  - packages/core/src/services/authorization.ts
  - packages/core/src/services/authorization.test.ts
  - packages/backend/src/infrastructure/repositories/plan.repository.ts
  - packages/backend/src/infrastructure/repositories/subscription.repository.ts
  - packages/backend/src/use-cases/subscriptions/check-athlete-limit.ts
  - packages/backend/src/use-cases/subscriptions/check-feature-access.ts
  - packages/backend/src/use-cases/subscriptions/get-subscription.ts
  - packages/backend/src/procedures/subscriptions/get-subscription.ts
  - packages/backend/src/procedures/subscriptions/list-plans.ts
autonomous: true

must_haves:
  truths:
    - "Authorization service with hasPermission, getPermissions, hasHigherOrEqualRole"
    - "Repositories implement port interfaces with OrganizationContext"
    - "Use cases check authorization FIRST, then validate via domain entity"
    - "Procedures only orchestrate (no business logic)"
    - "All error types mapped exhaustively in procedures"
  artifacts:
    - path: "packages/core/src/services/authorization.ts"
      provides: "RBAC authorization functions"
      exports: ["hasPermission", "getPermissions", "hasHigherOrEqualRole"]
    - path: "packages/backend/src/infrastructure/repositories/plan.repository.ts"
      provides: "Plan repository implementation"
      exports: ["createPlanRepository"]
    - path: "packages/backend/src/infrastructure/repositories/subscription.repository.ts"
      provides: "Subscription repository implementation"
      exports: ["createSubscriptionRepository"]
    - path: "packages/backend/src/use-cases/subscriptions/check-athlete-limit.ts"
      provides: "Refactored use case with repository + domain"
      exports: ["makeCheckAthleteLimit"]
---

<objective>
Create repositories implementing ports, refactor use cases to use repositories and domain entities, add authorization service.

Purpose: Complete gap closure for Phase 1 - proper Clean Architecture with authorization-first use cases.
Output: Repositories, authorization service, and refactored use cases following architecture skill.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@.claude/skills/architecture/SKILL.md
@.claude/skills/repository/SKILL.md
@.claude/skills/use-case/SKILL.md
@.claude/skills/authorization/SKILL.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-multi-tenancy/01-06-PLAN.md
@packages/core/src/ports/plan-repository.port.ts
@packages/core/src/ports/subscription-repository.port.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Authorization Service with Tests</name>
  <files>
    packages/core/src/services/authorization.ts
    packages/core/src/services/authorization.test.ts
  </files>
  <action>
Create authorization service following /authorization skill:

1. **packages/core/src/services/authorization.ts**:
   ```typescript
   export type Role = 'owner' | 'admin' | 'member'

   export type Permission =
     // Organization management
     | 'organization:read'
     | 'organization:manage'
     | 'organization:delete'
     // Members
     | 'members:read'
     | 'members:invite'
     | 'members:remove'
     | 'members:update-role'
     // Billing/Subscription
     | 'billing:read'
     | 'billing:manage'
     // Athletes
     | 'athletes:read'
     | 'athletes:write'
     | 'athletes:delete'
     // Programs
     | 'programs:read'
     | 'programs:write'
     | 'programs:delete'
     // Exercises
     | 'exercises:read'
     | 'exercises:write'

   const ROLE_HIERARCHY: Record<Role, number> = {
     owner: 100,
     admin: 80,
     member: 40,
   }

   const ROLE_PERMISSIONS: Record<Role, readonly Permission[]> = {
     owner: [
       // Organization
       'organization:read',
       'organization:manage',
       'organization:delete',
       // Members
       'members:read',
       'members:invite',
       'members:remove',
       'members:update-role',
       // Billing
       'billing:read',
       'billing:manage',
       // Athletes
       'athletes:read',
       'athletes:write',
       'athletes:delete',
       // Programs
       'programs:read',
       'programs:write',
       'programs:delete',
       // Exercises
       'exercises:read',
       'exercises:write',
     ],
     admin: [
       // Organization (no delete)
       'organization:read',
       'organization:manage',
       // Members (can invite/remove but not change roles)
       'members:read',
       'members:invite',
       'members:remove',
       // Billing (read only)
       'billing:read',
       // Athletes
       'athletes:read',
       'athletes:write',
       'athletes:delete',
       // Programs
       'programs:read',
       'programs:write',
       'programs:delete',
       // Exercises
       'exercises:read',
       'exercises:write',
     ],
     member: [
       // Organization (read only)
       'organization:read',
       // Members (read only)
       'members:read',
       // Athletes
       'athletes:read',
       'athletes:write',
       // Programs
       'programs:read',
       'programs:write',
       // Exercises
       'exercises:read',
       'exercises:write',
     ],
   }

   export function hasPermission(role: Role, permission: Permission): boolean {
     const permissions = ROLE_PERMISSIONS[role]
     return permissions?.includes(permission) ?? false
   }

   export function getPermissions(role: Role): readonly Permission[] {
     return ROLE_PERMISSIONS[role] ?? []
   }

   export function hasHigherOrEqualRole(role: Role, targetRole: Role): boolean {
     const roleLevel = ROLE_HIERARCHY[role] ?? 0
     const targetLevel = ROLE_HIERARCHY[targetRole] ?? 0
     return roleLevel >= targetLevel
   }

   export function isValidRole(role: string): role is Role {
     return role === 'owner' || role === 'admin' || role === 'member'
   }
   ```

2. **packages/core/src/services/authorization.test.ts**:
   ```typescript
   import { describe, it, expect } from 'vitest'
   import {
     hasPermission,
     getPermissions,
     hasHigherOrEqualRole,
     isValidRole,
     type Role,
   } from './authorization'

   describe('hasPermission', () => {
     describe('owner role', () => {
       it('has all permissions', () => {
         expect(hasPermission('owner', 'organization:delete')).toBe(true)
         expect(hasPermission('owner', 'billing:manage')).toBe(true)
         expect(hasPermission('owner', 'members:update-role')).toBe(true)
       })
     })

     describe('admin role', () => {
       it('has organization manage but not delete', () => {
         expect(hasPermission('admin', 'organization:manage')).toBe(true)
         expect(hasPermission('admin', 'organization:delete')).toBe(false)
       })

       it('has billing read but not manage', () => {
         expect(hasPermission('admin', 'billing:read')).toBe(true)
         expect(hasPermission('admin', 'billing:manage')).toBe(false)
       })

       it('can invite/remove members but not change roles', () => {
         expect(hasPermission('admin', 'members:invite')).toBe(true)
         expect(hasPermission('admin', 'members:remove')).toBe(true)
         expect(hasPermission('admin', 'members:update-role')).toBe(false)
       })

       it('has full athlete/program access', () => {
         expect(hasPermission('admin', 'athletes:write')).toBe(true)
         expect(hasPermission('admin', 'athletes:delete')).toBe(true)
         expect(hasPermission('admin', 'programs:write')).toBe(true)
       })
     })

     describe('member role', () => {
       it('has organization read only', () => {
         expect(hasPermission('member', 'organization:read')).toBe(true)
         expect(hasPermission('member', 'organization:manage')).toBe(false)
         expect(hasPermission('member', 'organization:delete')).toBe(false)
       })

       it('cannot manage billing', () => {
         expect(hasPermission('member', 'billing:read')).toBe(false)
         expect(hasPermission('member', 'billing:manage')).toBe(false)
       })

       it('cannot invite or remove members', () => {
         expect(hasPermission('member', 'members:read')).toBe(true)
         expect(hasPermission('member', 'members:invite')).toBe(false)
         expect(hasPermission('member', 'members:remove')).toBe(false)
       })

       it('cannot delete athletes', () => {
         expect(hasPermission('member', 'athletes:read')).toBe(true)
         expect(hasPermission('member', 'athletes:write')).toBe(true)
         expect(hasPermission('member', 'athletes:delete')).toBe(false)
       })
     })
   })

   describe('getPermissions', () => {
     it('returns owner permissions', () => {
       const perms = getPermissions('owner')
       expect(perms).toContain('organization:delete')
       expect(perms).toContain('billing:manage')
     })

     it('returns admin permissions', () => {
       const perms = getPermissions('admin')
       expect(perms).toContain('organization:manage')
       expect(perms).not.toContain('organization:delete')
     })

     it('returns member permissions', () => {
       const perms = getPermissions('member')
       expect(perms).toContain('athletes:write')
       expect(perms).not.toContain('athletes:delete')
     })
   })

   describe('hasHigherOrEqualRole', () => {
     it('owner is higher than admin', () => {
       expect(hasHigherOrEqualRole('owner', 'admin')).toBe(true)
       expect(hasHigherOrEqualRole('admin', 'owner')).toBe(false)
     })

     it('admin is higher than member', () => {
       expect(hasHigherOrEqualRole('admin', 'member')).toBe(true)
       expect(hasHigherOrEqualRole('member', 'admin')).toBe(false)
     })

     it('same role returns true', () => {
       expect(hasHigherOrEqualRole('owner', 'owner')).toBe(true)
       expect(hasHigherOrEqualRole('admin', 'admin')).toBe(true)
       expect(hasHigherOrEqualRole('member', 'member')).toBe(true)
     })
   })

   describe('isValidRole', () => {
     it('returns true for valid roles', () => {
       expect(isValidRole('owner')).toBe(true)
       expect(isValidRole('admin')).toBe(true)
       expect(isValidRole('member')).toBe(true)
     })

     it('returns false for invalid roles', () => {
       expect(isValidRole('superadmin')).toBe(false)
       expect(isValidRole('viewer')).toBe(false)
       expect(isValidRole('')).toBe(false)
     })
   })
   ```

Update packages/core/src/index.ts to export authorization:
```typescript
// Services
export * from './services/authorization'
```
  </action>
  <verify>
`pnpm --filter @strenly/core test` passes.
`pnpm --filter @strenly/core test:coverage` shows 90%+ on authorization.ts.
  </verify>
  <done>
Authorization service created with RBAC, role hierarchy, and comprehensive tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Plan Repository</name>
  <files>
    packages/backend/src/infrastructure/repositories/plan.repository.ts
  </files>
  <action>
Create Plan repository implementing port:

**packages/backend/src/infrastructure/repositories/plan.repository.ts**:
```typescript
import { ResultAsync, ok, err } from 'neverthrow'
import { eq, and, count } from 'drizzle-orm'
import { plans } from '@strenly/database/schema'
import {
  createPlan,
  type Plan,
  type OrganizationType,
} from '@strenly/core'
import type {
  PlanRepositoryPort,
  PlanRepositoryError,
  ListPlansOptions,
} from '@strenly/core'
import type { DB } from '@strenly/database'

function wrapDbError(error: unknown): PlanRepositoryError {
  console.error('Plan repository error:', error)
  return { type: 'DATABASE_ERROR', message: 'Database operation failed' }
}

function mapToDomain(row: typeof plans.$inferSelect): Plan | null {
  const result = createPlan({
    id: row.id,
    name: row.name,
    slug: row.slug,
    organizationType: row.organizationType as OrganizationType,
    athleteLimit: row.athleteLimit,
    coachLimit: row.coachLimit,
    features: row.features as Plan['features'],
    priceMonthly: row.priceMonthly,
    priceYearly: row.priceYearly,
    isActive: row.isActive,
  })

  return result.isOk() ? result.value : null
}

export function createPlanRepository(db: DB): PlanRepositoryPort {
  return {
    findById(id: string): ResultAsync<Plan, PlanRepositoryError> {
      return ResultAsync.fromPromise(
        db.select().from(plans).where(eq(plans.id, id)).then((rows) => rows[0]),
        wrapDbError
      ).andThen((row) => {
        if (!row) {
          return err({ type: 'NOT_FOUND', planId: id } as const)
        }
        const plan = mapToDomain(row)
        if (!plan) {
          return err({ type: 'DATABASE_ERROR', message: 'Invalid plan data' } as const)
        }
        return ok(plan)
      })
    },

    findBySlug(slug: string): ResultAsync<Plan, PlanRepositoryError> {
      return ResultAsync.fromPromise(
        db.select().from(plans).where(eq(plans.slug, slug)).then((rows) => rows[0]),
        wrapDbError
      ).andThen((row) => {
        if (!row) {
          return err({ type: 'NOT_FOUND', planId: slug } as const)
        }
        const plan = mapToDomain(row)
        if (!plan) {
          return err({ type: 'DATABASE_ERROR', message: 'Invalid plan data' } as const)
        }
        return ok(plan)
      })
    },

    findAll(options?: ListPlansOptions): ResultAsync<{ items: Plan[]; totalCount: number }, PlanRepositoryError> {
      return ResultAsync.fromPromise(
        (async () => {
          const conditions = []

          if (options?.activeOnly !== false) {
            conditions.push(eq(plans.isActive, true))
          }

          if (options?.organizationType) {
            conditions.push(eq(plans.organizationType, options.organizationType))
          }

          const whereClause = conditions.length > 0 ? and(...conditions) : undefined

          const [countResult, rows] = await Promise.all([
            db.select({ count: count() }).from(plans).where(whereClause),
            db.select().from(plans).where(whereClause).orderBy(plans.priceMonthly),
          ])

          const items = rows
            .map(mapToDomain)
            .filter((p): p is Plan => p !== null)

          return {
            items,
            totalCount: countResult[0]?.count ?? 0,
          }
        })(),
        wrapDbError
      )
    },
  }
}
```
  </action>
  <verify>
`pnpm typecheck` passes.
Repository implements all methods from PlanRepositoryPort.
  </verify>
  <done>
Plan repository created with findById, findBySlug, findAll (with totalCount for pagination).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Subscription Repository</name>
  <files>
    packages/backend/src/infrastructure/repositories/subscription.repository.ts
  </files>
  <action>
Create Subscription repository implementing port:

**packages/backend/src/infrastructure/repositories/subscription.repository.ts**:
```typescript
import { ResultAsync, ok, err } from 'neverthrow'
import { eq } from 'drizzle-orm'
import { subscriptions } from '@strenly/database/schema'
import {
  createSubscription,
  type Subscription,
  type SubscriptionStatus,
  type OrganizationContext,
} from '@strenly/core'
import type {
  SubscriptionRepositoryPort,
  SubscriptionRepositoryError,
} from '@strenly/core'
import type { DB } from '@strenly/database'

function wrapDbError(error: unknown): SubscriptionRepositoryError {
  console.error('Subscription repository error:', error)
  return { type: 'DATABASE_ERROR', message: 'Database operation failed' }
}

function mapToDomain(row: typeof subscriptions.$inferSelect): Subscription | null {
  const result = createSubscription({
    id: row.id,
    organizationId: row.organizationId,
    planId: row.planId,
    status: row.status as SubscriptionStatus,
    athleteCount: row.athleteCount,
    currentPeriodStart: row.currentPeriodStart,
    currentPeriodEnd: row.currentPeriodEnd,
    createdAt: row.createdAt,
  })

  return result.isOk() ? result.value : null
}

export function createSubscriptionRepository(db: DB): SubscriptionRepositoryPort {
  return {
    findByOrganizationId(ctx: OrganizationContext): ResultAsync<Subscription, SubscriptionRepositoryError> {
      return ResultAsync.fromPromise(
        db.select()
          .from(subscriptions)
          .where(eq(subscriptions.organizationId, ctx.organizationId))
          .then((rows) => rows[0]),
        wrapDbError
      ).andThen((row) => {
        if (!row) {
          return err({ type: 'NOT_FOUND', organizationId: ctx.organizationId } as const)
        }
        const subscription = mapToDomain(row)
        if (!subscription) {
          return err({ type: 'DATABASE_ERROR', message: 'Invalid subscription data' } as const)
        }
        return ok(subscription)
      })
    },

    save(ctx: OrganizationContext, subscription: Subscription): ResultAsync<Subscription, SubscriptionRepositoryError> {
      return ResultAsync.fromPromise(
        db.update(subscriptions)
          .set({
            status: subscription.status,
            athleteCount: subscription.athleteCount,
            currentPeriodStart: subscription.currentPeriodStart,
            currentPeriodEnd: subscription.currentPeriodEnd,
            updatedAt: new Date(),
          })
          .where(
            eq(subscriptions.organizationId, ctx.organizationId)
          )
          .returning()
          .then((rows) => rows[0]),
        wrapDbError
      ).andThen((row) => {
        if (!row) {
          return err({ type: 'NOT_FOUND', organizationId: ctx.organizationId } as const)
        }
        const updated = mapToDomain(row)
        if (!updated) {
          return err({ type: 'DATABASE_ERROR', message: 'Invalid subscription data' } as const)
        }
        return ok(updated)
      })
    },

    updateAthleteCount(ctx: OrganizationContext, count: number): ResultAsync<void, SubscriptionRepositoryError> {
      return ResultAsync.fromPromise(
        db.update(subscriptions)
          .set({
            athleteCount: count,
            updatedAt: new Date(),
          })
          .where(eq(subscriptions.organizationId, ctx.organizationId))
          .then(() => undefined),
        wrapDbError
      )
    },
  }
}
```
  </action>
  <verify>
`pnpm typecheck` passes.
Repository implements all methods from SubscriptionRepositoryPort with OrganizationContext.
  </verify>
  <done>
Subscription repository created with findByOrganizationId, save, updateAthleteCount.
  </done>
</task>

<task type="auto">
  <name>Task 4: Refactor Use Cases with Authorization and Domain Entities</name>
  <files>
    packages/backend/src/use-cases/subscriptions/check-athlete-limit.ts
    packages/backend/src/use-cases/subscriptions/check-feature-access.ts
    packages/backend/src/use-cases/subscriptions/get-subscription.ts
  </files>
  <action>
Refactor use cases to follow /use-case and /authorization skills:

1. **packages/backend/src/use-cases/subscriptions/check-athlete-limit.ts**:
   ```typescript
   import { ResultAsync, errAsync } from 'neverthrow'
   import {
     hasPermission,
     canAddAthlete,
     type Role,
     type OrganizationContext,
     type PlanRepositoryPort,
     type SubscriptionRepositoryPort,
   } from '@strenly/core'

   export type CheckAthleteLimitInput = OrganizationContext & {
     memberRole: Role
   }

   export type CheckAthleteLimitResult = {
     canAdd: boolean
     currentCount: number
     limit: number
     remaining: number
   }

   export type CheckAthleteLimitError =
     | { type: 'forbidden'; message: string }
     | { type: 'subscription_not_found'; organizationId: string }
     | { type: 'plan_not_found'; planId: string }
     | { type: 'repository_error'; message: string }

   type Dependencies = {
     subscriptionRepository: SubscriptionRepositoryPort
     planRepository: PlanRepositoryPort
   }

   export const makeCheckAthleteLimit =
     (deps: Dependencies) =>
     (input: CheckAthleteLimitInput): ResultAsync<CheckAthleteLimitResult, CheckAthleteLimitError> => {
       // 1. Authorization FIRST
       if (!hasPermission(input.memberRole, 'athletes:write')) {
         return errAsync({
           type: 'forbidden',
           message: 'No permission to add athletes',
         })
       }

       // 2. Get subscription
       return deps.subscriptionRepository
         .findByOrganizationId(input)
         .mapErr((e): CheckAthleteLimitError => {
           if (e.type === 'NOT_FOUND') {
             return { type: 'subscription_not_found', organizationId: input.organizationId }
           }
           return { type: 'repository_error', message: e.message }
         })
         .andThen((subscription) =>
           // 3. Get plan for limit
           deps.planRepository
             .findById(subscription.planId)
             .mapErr((e): CheckAthleteLimitError => {
               if (e.type === 'NOT_FOUND') {
                 return { type: 'plan_not_found', planId: subscription.planId }
               }
               return { type: 'repository_error', message: e.message }
             })
             .map((plan) => {
               // 4. Use domain helper
               const canAdd = canAddAthlete(plan, subscription.athleteCount)
               const remaining = plan.athleteLimit - subscription.athleteCount

               return {
                 canAdd,
                 currentCount: subscription.athleteCount,
                 limit: plan.athleteLimit,
                 remaining: Math.max(0, remaining),
               }
             })
         )
     }
   ```

2. **packages/backend/src/use-cases/subscriptions/check-feature-access.ts**:
   ```typescript
   import { ResultAsync, errAsync, okAsync } from 'neverthrow'
   import {
     hasPermission,
     hasFeature,
     type Role,
     type OrganizationContext,
     type PlanFeatures,
     type PlanRepositoryPort,
     type SubscriptionRepositoryPort,
   } from '@strenly/core'

   export type CheckFeatureAccessInput = OrganizationContext & {
     memberRole: Role
     feature: keyof PlanFeatures
   }

   export type CheckFeatureAccessError =
     | { type: 'forbidden'; message: string }
     | { type: 'subscription_not_found'; organizationId: string }
     | { type: 'plan_not_found'; planId: string }
     | { type: 'feature_not_available'; feature: keyof PlanFeatures }
     | { type: 'repository_error'; message: string }

   type Dependencies = {
     subscriptionRepository: SubscriptionRepositoryPort
     planRepository: PlanRepositoryPort
   }

   export const makeCheckFeatureAccess =
     (deps: Dependencies) =>
     (input: CheckFeatureAccessInput): ResultAsync<boolean, CheckFeatureAccessError> => {
       // 1. Authorization FIRST (read permission sufficient for checking access)
       if (!hasPermission(input.memberRole, 'organization:read')) {
         return errAsync({
           type: 'forbidden',
           message: 'No permission to check feature access',
         })
       }

       // 2. Get subscription
       return deps.subscriptionRepository
         .findByOrganizationId(input)
         .mapErr((e): CheckFeatureAccessError => {
           if (e.type === 'NOT_FOUND') {
             return { type: 'subscription_not_found', organizationId: input.organizationId }
           }
           return { type: 'repository_error', message: e.message }
         })
         .andThen((subscription) =>
           // 3. Get plan
           deps.planRepository
             .findById(subscription.planId)
             .mapErr((e): CheckFeatureAccessError => {
               if (e.type === 'NOT_FOUND') {
                 return { type: 'plan_not_found', planId: subscription.planId }
               }
               return { type: 'repository_error', message: e.message }
             })
             .andThen((plan) => {
               // 4. Use domain helper
               if (!hasFeature(plan, input.feature)) {
                 return errAsync({
                   type: 'feature_not_available',
                   feature: input.feature,
                 } as const)
               }
               return okAsync(true)
             })
         )
     }
   ```

3. **packages/backend/src/use-cases/subscriptions/get-subscription.ts**:
   ```typescript
   import { ResultAsync, errAsync } from 'neverthrow'
   import {
     hasPermission,
     type Role,
     type OrganizationContext,
     type Subscription,
     type Plan,
     type PlanRepositoryPort,
     type SubscriptionRepositoryPort,
   } from '@strenly/core'

   export type GetSubscriptionInput = OrganizationContext & {
     memberRole: Role
   }

   export type GetSubscriptionResult = {
     subscription: Subscription
     plan: Plan
   }

   export type GetSubscriptionError =
     | { type: 'forbidden'; message: string }
     | { type: 'subscription_not_found'; organizationId: string }
     | { type: 'plan_not_found'; planId: string }
     | { type: 'repository_error'; message: string }

   type Dependencies = {
     subscriptionRepository: SubscriptionRepositoryPort
     planRepository: PlanRepositoryPort
   }

   export const makeGetSubscription =
     (deps: Dependencies) =>
     (input: GetSubscriptionInput): ResultAsync<GetSubscriptionResult, GetSubscriptionError> => {
       // 1. Authorization FIRST
       if (!hasPermission(input.memberRole, 'billing:read')) {
         return errAsync({
           type: 'forbidden',
           message: 'No permission to view subscription',
         })
       }

       // 2. Get subscription
       return deps.subscriptionRepository
         .findByOrganizationId(input)
         .mapErr((e): GetSubscriptionError => {
           if (e.type === 'NOT_FOUND') {
             return { type: 'subscription_not_found', organizationId: input.organizationId }
           }
           return { type: 'repository_error', message: e.message }
         })
         .andThen((subscription) =>
           // 3. Get plan
           deps.planRepository
             .findById(subscription.planId)
             .mapErr((e): GetSubscriptionError => {
               if (e.type === 'NOT_FOUND') {
                 return { type: 'plan_not_found', planId: subscription.planId }
               }
               return { type: 'repository_error', message: e.message }
             })
             .map((plan) => ({
               subscription,
               plan,
             }))
         )
     }
   ```
  </action>
  <verify>
`pnpm typecheck` passes.
All use cases check authorization FIRST.
Use cases use domain helpers (canAddAthlete, hasFeature).
  </verify>
  <done>
Use cases refactored with authorization-first pattern, repository abstraction, domain helpers.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update Procedures to Use Refactored Use Cases</name>
  <files>
    packages/backend/src/procedures/subscriptions/list-plans.ts
    packages/backend/src/procedures/subscriptions/get-subscription.ts
  </files>
  <action>
Update procedures to use repositories and map all errors:

1. **packages/backend/src/procedures/subscriptions/list-plans.ts**:
   ```typescript
   import { publicProcedure } from '../../lib/orpc'
   import { createPlanRepository } from '../../infrastructure/repositories/plan.repository'
   import { organizationTypeSchema } from '@strenly/contracts/organizations/organization'
   import { planSchema } from '@strenly/contracts/subscriptions/plan'
   import { z } from 'zod'

   export const listPlans = publicProcedure
     .input(
       z
         .object({
           organizationType: organizationTypeSchema.optional(),
         })
         .optional()
     )
     .output(z.object({ plans: z.array(planSchema), totalCount: z.number() }))
     .handler(async ({ input, context }) => {
       const planRepository = createPlanRepository(context.db)

       const result = await planRepository.findAll({
         organizationType: input?.organizationType,
         activeOnly: true,
       })

       if (result.isErr()) {
         // Log and throw generic error for public endpoint
         console.error('Failed to list plans:', result.error)
         throw new Error('Failed to load subscription plans')
       }

       return {
         plans: result.value.items.map((p) => ({
           id: p.id,
           name: p.name,
           slug: p.slug,
           organizationType: p.organizationType,
           athleteLimit: p.athleteLimit,
           coachLimit: p.coachLimit,
           features: p.features,
           priceMonthly: p.priceMonthly,
           priceYearly: p.priceYearly,
           isActive: p.isActive,
         })),
         totalCount: result.value.totalCount,
       }
     })
   ```

2. **packages/backend/src/procedures/subscriptions/get-subscription.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { createPlanRepository } from '../../infrastructure/repositories/plan.repository'
   import { createSubscriptionRepository } from '../../infrastructure/repositories/subscription.repository'
   import { makeGetSubscription } from '../../use-cases/subscriptions/get-subscription'
   import { subscriptionSchema } from '@strenly/contracts/subscriptions/subscription'
   import { planSchema } from '@strenly/contracts/subscriptions/plan'
   import { z } from 'zod'

   export const getSubscription = authProcedure
     .errors({
       FORBIDDEN: { message: 'No permission to view subscription' },
       SUBSCRIPTION_NOT_FOUND: { message: 'Subscription not found' },
       PLAN_NOT_FOUND: { message: 'Plan not found' },
     })
     .output(
       z.object({
         subscription: subscriptionSchema,
         plan: planSchema,
       })
     )
     .handler(async ({ context, errors }) => {
       const getSubscription = makeGetSubscription({
         subscriptionRepository: createSubscriptionRepository(context.db),
         planRepository: createPlanRepository(context.db),
       })

       const result = await getSubscription({
         organizationId: context.organization.id,
         userId: context.session.userId,
         memberRole: context.organization.role,
       })

       if (result.isErr()) {
         // Exhaustive error mapping
         switch (result.error.type) {
           case 'forbidden':
             throw errors.FORBIDDEN()
           case 'subscription_not_found':
             throw errors.SUBSCRIPTION_NOT_FOUND()
           case 'plan_not_found':
             throw errors.PLAN_NOT_FOUND()
           case 'repository_error':
             console.error('Repository error:', result.error.message)
             throw new Error('Internal error')
         }
       }

       const { subscription, plan } = result.value

       return {
         subscription: {
           id: subscription.id,
           organizationId: subscription.organizationId,
           plan: {
             id: plan.id,
             name: plan.name,
             slug: plan.slug,
             organizationType: plan.organizationType,
             athleteLimit: plan.athleteLimit,
             coachLimit: plan.coachLimit,
             features: plan.features,
             priceMonthly: plan.priceMonthly,
             priceYearly: plan.priceYearly,
             isActive: plan.isActive,
           },
           status: subscription.status,
           athleteCount: subscription.athleteCount,
           athleteLimit: plan.athleteLimit,
           currentPeriodStart: subscription.currentPeriodStart.toISOString(),
           currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),
           createdAt: subscription.createdAt.toISOString(),
         },
         plan: {
           id: plan.id,
           name: plan.name,
           slug: plan.slug,
           organizationType: plan.organizationType,
           athleteLimit: plan.athleteLimit,
           coachLimit: plan.coachLimit,
           features: plan.features,
           priceMonthly: plan.priceMonthly,
           priceYearly: plan.priceYearly,
           isActive: plan.isActive,
         },
       }
     })
   ```
  </action>
  <verify>
`pnpm typecheck` passes.
Procedures only orchestrate (no business logic).
All error types mapped exhaustively with switch statement.
  </verify>
  <done>
Procedures refactored to use repositories and use cases, with exhaustive error mapping.
  </done>
</task>

<task type="auto">
  <name>Task 6: Delete Old Use Case Files and Verify Coverage</name>
  <files>
    packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts
    packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts
  </files>
  <action>
1. Delete old use case files (they've been replaced):
   ```bash
   rm -f packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts
   rm -f packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts
   ```

2. Run coverage check on core package:
   ```bash
   pnpm --filter @strenly/core test:coverage
   ```

3. Verify 90%+ coverage threshold is met.

4. Run full typecheck:
   ```bash
   pnpm typecheck
   ```
  </action>
  <verify>
Old files deleted.
`pnpm --filter @strenly/core test:coverage` shows 90%+ coverage.
`pnpm typecheck` passes across all packages.
  </verify>
  <done>
Cleanup complete. Core package has 90%+ test coverage. All packages typecheck.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes for all packages
2. `pnpm --filter @strenly/core test:coverage` shows 90%+ coverage
3. Authorization service with hasPermission, getPermissions, hasHigherOrEqualRole
4. Repositories implement port interfaces with OrganizationContext
5. Use cases check authorization FIRST
6. Procedures only orchestrate, map all errors exhaustively
7. No direct DB queries in use cases (use repositories)
</verification>

<success_criteria>
Complete gap closure for Phase 1 architecture:
- Authorization service with tests
- Repositories implementing ports
- Refactored use cases with authorization-first, domain validation
- Procedures that only orchestrate
- 90%+ test coverage on core package
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-multi-tenancy/01-07-SUMMARY.md`
</output>
