---
phase: 01-foundation-multi-tenancy
plan: 06
type: execute
wave: 4
depends_on: ["01-05"]
gap_closure: true
files_modified:
  - packages/core/src/domain/entities/plan.ts
  - packages/core/src/domain/entities/plan.test.ts
  - packages/core/src/domain/entities/subscription.ts
  - packages/core/src/domain/entities/subscription.test.ts
  - packages/core/src/ports/plan-repository.port.ts
  - packages/core/src/ports/subscription-repository.port.ts
  - packages/core/src/index.ts
  - packages/core/package.json
autonomous: true

must_haves:
  truths:
    - "Plan domain entity validates business rules (athlete limits, pricing, features)"
    - "Subscription domain entity validates status transitions and period dates"
    - "Domain entities return Result<Entity, DomainError> from factory functions"
    - "Ports define repository interfaces with OrganizationContext"
    - "Core package has 90%+ test coverage"
  artifacts:
    - path: "packages/core/src/domain/entities/plan.ts"
      provides: "Plan domain entity with validation"
      exports: ["createPlan", "Plan", "PlanError"]
    - path: "packages/core/src/domain/entities/plan.test.ts"
      provides: "Plan entity tests"
    - path: "packages/core/src/domain/entities/subscription.ts"
      provides: "Subscription domain entity with validation"
      exports: ["createSubscription", "Subscription", "SubscriptionError"]
    - path: "packages/core/src/domain/entities/subscription.test.ts"
      provides: "Subscription entity tests"
    - path: "packages/core/src/ports/plan-repository.port.ts"
      provides: "Plan repository interface"
      exports: ["PlanRepositoryPort"]
    - path: "packages/core/src/ports/subscription-repository.port.ts"
      provides: "Subscription repository interface"
      exports: ["SubscriptionRepositoryPort"]
---

<objective>
Create domain entities and ports for Plan and Subscription to establish proper Clean Architecture foundation.

Purpose: Gap closure for Phase 1 - subscriptions were implemented without domain layer, violating architecture.
Output: Domain entities with validation, tests with 90%+ coverage, and port interfaces for repositories.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@.claude/skills/architecture/SKILL.md
@.claude/skills/domain-entity/SKILL.md
@.claude/skills/port/SKILL.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@packages/database/src/schema/plans.ts
@packages/database/src/schema/subscriptions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup Core Package Structure</name>
  <files>
    packages/core/package.json
    packages/core/tsconfig.json
    packages/core/src/index.ts
    packages/core/vitest.config.ts
  </files>
  <action>
Create or update core package structure:

1. **packages/core/package.json**:
   ```json
   {
     "name": "@strenly/core",
     "version": "0.0.0",
     "private": true,
     "type": "module",
     "exports": {
       ".": "./src/index.ts",
       "./domain/entities/*": "./src/domain/entities/*.ts",
       "./ports/*": "./src/ports/*.ts"
     },
     "scripts": {
       "typecheck": "tsc --noEmit",
       "test": "vitest run",
       "test:watch": "vitest",
       "test:coverage": "vitest run --coverage"
     },
     "dependencies": {
       "neverthrow": "^8.2.0"
     },
     "devDependencies": {
       "@vitest/coverage-v8": "^3.0.0",
       "typescript": "^5.7.3",
       "vitest": "^3.0.0"
     }
   }
   ```

2. **packages/core/vitest.config.ts**:
   ```typescript
   import { defineConfig } from 'vitest/config'

   export default defineConfig({
     test: {
       coverage: {
         provider: 'v8',
         reporter: ['text', 'json', 'html'],
         include: ['src/**/*.ts'],
         exclude: ['src/**/*.test.ts', 'src/index.ts'],
         thresholds: {
           lines: 90,
           functions: 90,
           branches: 90,
           statements: 90,
         },
       },
     },
   })
   ```

3. **packages/core/src/index.ts**:
   ```typescript
   // Domain Entities
   export * from './domain/entities/plan'
   export * from './domain/entities/subscription'

   // Ports
   export * from './ports/plan-repository.port'
   export * from './ports/subscription-repository.port'
   ```

Run `pnpm install` after creating package.json.
  </action>
  <verify>
`pnpm typecheck` passes for core package.
`pnpm test:coverage` runs (even if no tests yet).
  </verify>
  <done>
Core package structure created with vitest configured for 90% coverage threshold.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Plan Domain Entity with Tests</name>
  <files>
    packages/core/src/domain/entities/plan.ts
    packages/core/src/domain/entities/plan.test.ts
  </files>
  <action>
Create Plan domain entity following /domain-entity skill:

1. **packages/core/src/domain/entities/plan.ts**:
   ```typescript
   import { Result, ok, err } from 'neverthrow'

   // Domain types (not Zod - pure TypeScript)
   export type OrganizationType = 'coach_solo' | 'gym'

   export type PlanFeatures = {
     templates: boolean
     analytics: boolean
     exportData: boolean
     customExercises: boolean
     multipleCoaches: boolean
   }

   export type Plan = {
     readonly id: string
     readonly name: string
     readonly slug: string
     readonly organizationType: OrganizationType
     readonly athleteLimit: number
     readonly coachLimit: number | null // null = unlimited
     readonly features: PlanFeatures
     readonly priceMonthly: number // cents
     readonly priceYearly: number // cents
     readonly isActive: boolean
   }

   export type PlanError =
     | { type: 'INVALID_NAME'; message: string }
     | { type: 'INVALID_SLUG'; message: string }
     | { type: 'INVALID_ATHLETE_LIMIT'; message: string }
     | { type: 'INVALID_COACH_LIMIT'; message: string }
     | { type: 'INVALID_PRICE'; message: string }
     | { type: 'INVALID_YEARLY_DISCOUNT'; message: string }

   type CreatePlanInput = {
     id: string
     name: string
     slug: string
     organizationType: OrganizationType
     athleteLimit: number
     coachLimit: number | null
     features: PlanFeatures
     priceMonthly: number
     priceYearly: number
     isActive: boolean
   }

   export function createPlan(input: CreatePlanInput): Result<Plan, PlanError> {
     // Validate name
     if (!input.name || input.name.trim().length < 2) {
       return err({ type: 'INVALID_NAME', message: 'Plan name must be at least 2 characters' })
     }
     if (input.name.length > 50) {
       return err({ type: 'INVALID_NAME', message: 'Plan name must not exceed 50 characters' })
     }

     // Validate slug
     const slugRegex = /^[a-z0-9-]+$/
     if (!slugRegex.test(input.slug)) {
       return err({ type: 'INVALID_SLUG', message: 'Slug must be lowercase alphanumeric with hyphens' })
     }

     // Validate athlete limit
     if (input.athleteLimit < 1) {
       return err({ type: 'INVALID_ATHLETE_LIMIT', message: 'Athlete limit must be at least 1' })
     }
     if (input.athleteLimit > 10000) {
       return err({ type: 'INVALID_ATHLETE_LIMIT', message: 'Athlete limit cannot exceed 10000' })
     }

     // Validate coach limit (null means unlimited)
     if (input.coachLimit !== null && input.coachLimit < 1) {
       return err({ type: 'INVALID_COACH_LIMIT', message: 'Coach limit must be at least 1 or null for unlimited' })
     }

     // Validate prices (must be non-negative)
     if (input.priceMonthly < 0) {
       return err({ type: 'INVALID_PRICE', message: 'Monthly price cannot be negative' })
     }
     if (input.priceYearly < 0) {
       return err({ type: 'INVALID_PRICE', message: 'Yearly price cannot be negative' })
     }

     // Validate yearly discount makes sense (yearly should be <= 12 * monthly)
     if (input.priceMonthly > 0 && input.priceYearly > input.priceMonthly * 12) {
       return err({ type: 'INVALID_YEARLY_DISCOUNT', message: 'Yearly price should not exceed 12 months of monthly price' })
     }

     return ok({
       id: input.id,
       name: input.name.trim(),
       slug: input.slug,
       organizationType: input.organizationType,
       athleteLimit: input.athleteLimit,
       coachLimit: input.coachLimit,
       features: input.features,
       priceMonthly: input.priceMonthly,
       priceYearly: input.priceYearly,
       isActive: input.isActive,
     })
   }

   // Helper to check if athlete can be added to a plan
   export function canAddAthlete(plan: Plan, currentCount: number): boolean {
     return currentCount < plan.athleteLimit
   }

   // Helper to check feature access
   export function hasFeature(plan: Plan, feature: keyof PlanFeatures): boolean {
     return plan.features[feature]
   }
   ```

2. **packages/core/src/domain/entities/plan.test.ts**:
   ```typescript
   import { describe, it, expect } from 'vitest'
   import { createPlan, canAddAthlete, hasFeature, type PlanFeatures } from './plan'

   const validFeatures: PlanFeatures = {
     templates: true,
     analytics: false,
     exportData: false,
     customExercises: true,
     multipleCoaches: false,
   }

   const validInput = {
     id: 'plan-123',
     name: 'Coach Starter',
     slug: 'coach-starter',
     organizationType: 'coach_solo' as const,
     athleteLimit: 10,
     coachLimit: 1,
     features: validFeatures,
     priceMonthly: 0,
     priceYearly: 0,
     isActive: true,
   }

   describe('createPlan', () => {
     it('creates a valid plan', () => {
       const result = createPlan(validInput)
       expect(result.isOk()).toBe(true)
       if (result.isOk()) {
         expect(result.value.name).toBe('Coach Starter')
         expect(result.value.athleteLimit).toBe(10)
       }
     })

     it('trims whitespace from name', () => {
       const result = createPlan({ ...validInput, name: '  Gym Pro  ' })
       expect(result.isOk()).toBe(true)
       if (result.isOk()) {
         expect(result.value.name).toBe('Gym Pro')
       }
     })

     describe('name validation', () => {
       it('rejects empty name', () => {
         const result = createPlan({ ...validInput, name: '' })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_NAME')
         }
       })

       it('rejects name shorter than 2 characters', () => {
         const result = createPlan({ ...validInput, name: 'A' })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_NAME')
         }
       })

       it('rejects name longer than 50 characters', () => {
         const result = createPlan({ ...validInput, name: 'A'.repeat(51) })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_NAME')
         }
       })
     })

     describe('slug validation', () => {
       it('rejects uppercase in slug', () => {
         const result = createPlan({ ...validInput, slug: 'Coach-Starter' })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_SLUG')
         }
       })

       it('rejects spaces in slug', () => {
         const result = createPlan({ ...validInput, slug: 'coach starter' })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_SLUG')
         }
       })

       it('accepts valid slug with hyphens', () => {
         const result = createPlan({ ...validInput, slug: 'gym-pro-2024' })
         expect(result.isOk()).toBe(true)
       })
     })

     describe('athlete limit validation', () => {
       it('rejects zero athlete limit', () => {
         const result = createPlan({ ...validInput, athleteLimit: 0 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_ATHLETE_LIMIT')
         }
       })

       it('rejects negative athlete limit', () => {
         const result = createPlan({ ...validInput, athleteLimit: -1 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_ATHLETE_LIMIT')
         }
       })

       it('rejects athlete limit over 10000', () => {
         const result = createPlan({ ...validInput, athleteLimit: 10001 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_ATHLETE_LIMIT')
         }
       })

       it('accepts maximum athlete limit of 10000', () => {
         const result = createPlan({ ...validInput, athleteLimit: 10000 })
         expect(result.isOk()).toBe(true)
       })
     })

     describe('coach limit validation', () => {
       it('accepts null for unlimited coaches', () => {
         const result = createPlan({ ...validInput, coachLimit: null })
         expect(result.isOk()).toBe(true)
         if (result.isOk()) {
           expect(result.value.coachLimit).toBeNull()
         }
       })

       it('rejects zero coach limit', () => {
         const result = createPlan({ ...validInput, coachLimit: 0 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_COACH_LIMIT')
         }
       })

       it('rejects negative coach limit', () => {
         const result = createPlan({ ...validInput, coachLimit: -1 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_COACH_LIMIT')
         }
       })
     })

     describe('price validation', () => {
       it('rejects negative monthly price', () => {
         const result = createPlan({ ...validInput, priceMonthly: -100 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_PRICE')
         }
       })

       it('rejects negative yearly price', () => {
         const result = createPlan({ ...validInput, priceYearly: -100 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_PRICE')
         }
       })

       it('accepts free tier (zero prices)', () => {
         const result = createPlan({ ...validInput, priceMonthly: 0, priceYearly: 0 })
         expect(result.isOk()).toBe(true)
       })

       it('rejects yearly price higher than 12x monthly', () => {
         const result = createPlan({ ...validInput, priceMonthly: 1000, priceYearly: 15000 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_YEARLY_DISCOUNT')
         }
       })

       it('accepts yearly price equal to 12x monthly (no discount)', () => {
         const result = createPlan({ ...validInput, priceMonthly: 1000, priceYearly: 12000 })
         expect(result.isOk()).toBe(true)
       })

       it('accepts yearly price with discount', () => {
         const result = createPlan({ ...validInput, priceMonthly: 1000, priceYearly: 10000 })
         expect(result.isOk()).toBe(true)
       })
     })
   })

   describe('canAddAthlete', () => {
     it('returns true when under limit', () => {
       const plan = createPlan(validInput)._unsafeUnwrap()
       expect(canAddAthlete(plan, 5)).toBe(true)
     })

     it('returns true when at limit minus one', () => {
       const plan = createPlan(validInput)._unsafeUnwrap()
       expect(canAddAthlete(plan, 9)).toBe(true)
     })

     it('returns false when at limit', () => {
       const plan = createPlan(validInput)._unsafeUnwrap()
       expect(canAddAthlete(plan, 10)).toBe(false)
     })

     it('returns false when over limit', () => {
       const plan = createPlan(validInput)._unsafeUnwrap()
       expect(canAddAthlete(plan, 15)).toBe(false)
     })
   })

   describe('hasFeature', () => {
     it('returns true for enabled feature', () => {
       const plan = createPlan(validInput)._unsafeUnwrap()
       expect(hasFeature(plan, 'templates')).toBe(true)
       expect(hasFeature(plan, 'customExercises')).toBe(true)
     })

     it('returns false for disabled feature', () => {
       const plan = createPlan(validInput)._unsafeUnwrap()
       expect(hasFeature(plan, 'analytics')).toBe(false)
       expect(hasFeature(plan, 'exportData')).toBe(false)
       expect(hasFeature(plan, 'multipleCoaches')).toBe(false)
     })
   })
   ```
  </action>
  <verify>
`pnpm --filter @strenly/core test` passes.
`pnpm --filter @strenly/core test:coverage` shows 90%+ on plan.ts.
  </verify>
  <done>
Plan domain entity created with comprehensive validation and tests covering all business rules.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Subscription Domain Entity with Tests</name>
  <files>
    packages/core/src/domain/entities/subscription.ts
    packages/core/src/domain/entities/subscription.test.ts
  </files>
  <action>
Create Subscription domain entity following /domain-entity skill:

1. **packages/core/src/domain/entities/subscription.ts**:
   ```typescript
   import { Result, ok, err } from 'neverthrow'

   export type SubscriptionStatus = 'active' | 'canceled' | 'past_due'

   export type Subscription = {
     readonly id: string
     readonly organizationId: string
     readonly planId: string
     readonly status: SubscriptionStatus
     readonly athleteCount: number
     readonly currentPeriodStart: Date
     readonly currentPeriodEnd: Date
     readonly createdAt: Date
   }

   export type SubscriptionError =
     | { type: 'INVALID_ATHLETE_COUNT'; message: string }
     | { type: 'INVALID_PERIOD'; message: string }
     | { type: 'INVALID_STATUS_TRANSITION'; message: string; from: SubscriptionStatus; to: SubscriptionStatus }

   type CreateSubscriptionInput = {
     id: string
     organizationId: string
     planId: string
     status: SubscriptionStatus
     athleteCount: number
     currentPeriodStart: Date
     currentPeriodEnd: Date
     createdAt: Date
   }

   export function createSubscription(input: CreateSubscriptionInput): Result<Subscription, SubscriptionError> {
     // Validate athlete count
     if (input.athleteCount < 0) {
       return err({ type: 'INVALID_ATHLETE_COUNT', message: 'Athlete count cannot be negative' })
     }

     // Validate period dates
     if (input.currentPeriodEnd <= input.currentPeriodStart) {
       return err({ type: 'INVALID_PERIOD', message: 'Period end must be after period start' })
     }

     return ok({
       id: input.id,
       organizationId: input.organizationId,
       planId: input.planId,
       status: input.status,
       athleteCount: input.athleteCount,
       currentPeriodStart: input.currentPeriodStart,
       currentPeriodEnd: input.currentPeriodEnd,
       createdAt: input.createdAt,
     })
   }

   // Valid status transitions
   const VALID_TRANSITIONS: Record<SubscriptionStatus, SubscriptionStatus[]> = {
     active: ['canceled', 'past_due'],
     past_due: ['active', 'canceled'],
     canceled: ['active'], // reactivation
   }

   export function canTransitionTo(from: SubscriptionStatus, to: SubscriptionStatus): boolean {
     return VALID_TRANSITIONS[from].includes(to)
   }

   export function transitionStatus(
     subscription: Subscription,
     newStatus: SubscriptionStatus
   ): Result<Subscription, SubscriptionError> {
     if (subscription.status === newStatus) {
       return ok(subscription) // No-op if same status
     }

     if (!canTransitionTo(subscription.status, newStatus)) {
       return err({
         type: 'INVALID_STATUS_TRANSITION',
         message: `Cannot transition from ${subscription.status} to ${newStatus}`,
         from: subscription.status,
         to: newStatus,
       })
     }

     return ok({
       ...subscription,
       status: newStatus,
     })
   }

   export function incrementAthleteCount(subscription: Subscription): Subscription {
     return {
       ...subscription,
       athleteCount: subscription.athleteCount + 1,
     }
   }

   export function decrementAthleteCount(subscription: Subscription): Result<Subscription, SubscriptionError> {
     if (subscription.athleteCount <= 0) {
       return err({ type: 'INVALID_ATHLETE_COUNT', message: 'Athlete count cannot go below zero' })
     }

     return ok({
       ...subscription,
       athleteCount: subscription.athleteCount - 1,
     })
   }

   export function isActive(subscription: Subscription): boolean {
     return subscription.status === 'active'
   }

   export function isPastDue(subscription: Subscription): boolean {
     return subscription.status === 'past_due'
   }
   ```

2. **packages/core/src/domain/entities/subscription.test.ts**:
   ```typescript
   import { describe, it, expect } from 'vitest'
   import {
     createSubscription,
     transitionStatus,
     canTransitionTo,
     incrementAthleteCount,
     decrementAthleteCount,
     isActive,
     isPastDue,
   } from './subscription'

   const now = new Date()
   const oneMonthLater = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000)

   const validInput = {
     id: 'sub-123',
     organizationId: 'org-456',
     planId: 'plan-789',
     status: 'active' as const,
     athleteCount: 5,
     currentPeriodStart: now,
     currentPeriodEnd: oneMonthLater,
     createdAt: now,
   }

   describe('createSubscription', () => {
     it('creates a valid subscription', () => {
       const result = createSubscription(validInput)
       expect(result.isOk()).toBe(true)
       if (result.isOk()) {
         expect(result.value.organizationId).toBe('org-456')
         expect(result.value.athleteCount).toBe(5)
         expect(result.value.status).toBe('active')
       }
     })

     describe('athlete count validation', () => {
       it('accepts zero athlete count', () => {
         const result = createSubscription({ ...validInput, athleteCount: 0 })
         expect(result.isOk()).toBe(true)
       })

       it('rejects negative athlete count', () => {
         const result = createSubscription({ ...validInput, athleteCount: -1 })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_ATHLETE_COUNT')
         }
       })
     })

     describe('period validation', () => {
       it('rejects period end before period start', () => {
         const result = createSubscription({
           ...validInput,
           currentPeriodStart: oneMonthLater,
           currentPeriodEnd: now,
         })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_PERIOD')
         }
       })

       it('rejects period end equal to period start', () => {
         const result = createSubscription({
           ...validInput,
           currentPeriodStart: now,
           currentPeriodEnd: now,
         })
         expect(result.isErr()).toBe(true)
         if (result.isErr()) {
           expect(result.error.type).toBe('INVALID_PERIOD')
         }
       })
     })
   })

   describe('canTransitionTo', () => {
     it('allows active -> canceled', () => {
       expect(canTransitionTo('active', 'canceled')).toBe(true)
     })

     it('allows active -> past_due', () => {
       expect(canTransitionTo('active', 'past_due')).toBe(true)
     })

     it('allows past_due -> active', () => {
       expect(canTransitionTo('past_due', 'active')).toBe(true)
     })

     it('allows past_due -> canceled', () => {
       expect(canTransitionTo('past_due', 'canceled')).toBe(true)
     })

     it('allows canceled -> active (reactivation)', () => {
       expect(canTransitionTo('canceled', 'active')).toBe(true)
     })

     it('disallows canceled -> past_due', () => {
       expect(canTransitionTo('canceled', 'past_due')).toBe(false)
     })

     it('disallows active -> active (no-op handled separately)', () => {
       expect(canTransitionTo('active', 'active')).toBe(false)
     })
   })

   describe('transitionStatus', () => {
     it('returns same subscription when status unchanged', () => {
       const subscription = createSubscription(validInput)._unsafeUnwrap()
       const result = transitionStatus(subscription, 'active')
       expect(result.isOk()).toBe(true)
       if (result.isOk()) {
         expect(result.value).toBe(subscription) // Same reference
       }
     })

     it('transitions active to canceled', () => {
       const subscription = createSubscription(validInput)._unsafeUnwrap()
       const result = transitionStatus(subscription, 'canceled')
       expect(result.isOk()).toBe(true)
       if (result.isOk()) {
         expect(result.value.status).toBe('canceled')
       }
     })

     it('transitions active to past_due', () => {
       const subscription = createSubscription(validInput)._unsafeUnwrap()
       const result = transitionStatus(subscription, 'past_due')
       expect(result.isOk()).toBe(true)
       if (result.isOk()) {
         expect(result.value.status).toBe('past_due')
       }
     })

     it('rejects invalid transition from canceled to past_due', () => {
       const subscription = createSubscription({ ...validInput, status: 'canceled' })._unsafeUnwrap()
       const result = transitionStatus(subscription, 'past_due')
       expect(result.isErr()).toBe(true)
       if (result.isErr()) {
         expect(result.error.type).toBe('INVALID_STATUS_TRANSITION')
         expect(result.error.from).toBe('canceled')
         expect(result.error.to).toBe('past_due')
       }
     })
   })

   describe('incrementAthleteCount', () => {
     it('increments count by 1', () => {
       const subscription = createSubscription(validInput)._unsafeUnwrap()
       const updated = incrementAthleteCount(subscription)
       expect(updated.athleteCount).toBe(6)
     })

     it('increments from zero', () => {
       const subscription = createSubscription({ ...validInput, athleteCount: 0 })._unsafeUnwrap()
       const updated = incrementAthleteCount(subscription)
       expect(updated.athleteCount).toBe(1)
     })
   })

   describe('decrementAthleteCount', () => {
     it('decrements count by 1', () => {
       const subscription = createSubscription(validInput)._unsafeUnwrap()
       const result = decrementAthleteCount(subscription)
       expect(result.isOk()).toBe(true)
       if (result.isOk()) {
         expect(result.value.athleteCount).toBe(4)
       }
     })

     it('rejects decrement when count is zero', () => {
       const subscription = createSubscription({ ...validInput, athleteCount: 0 })._unsafeUnwrap()
       const result = decrementAthleteCount(subscription)
       expect(result.isErr()).toBe(true)
       if (result.isErr()) {
         expect(result.error.type).toBe('INVALID_ATHLETE_COUNT')
       }
     })
   })

   describe('status helpers', () => {
     it('isActive returns true for active subscription', () => {
       const subscription = createSubscription(validInput)._unsafeUnwrap()
       expect(isActive(subscription)).toBe(true)
     })

     it('isActive returns false for canceled subscription', () => {
       const subscription = createSubscription({ ...validInput, status: 'canceled' })._unsafeUnwrap()
       expect(isActive(subscription)).toBe(false)
     })

     it('isPastDue returns true for past_due subscription', () => {
       const subscription = createSubscription({ ...validInput, status: 'past_due' })._unsafeUnwrap()
       expect(isPastDue(subscription)).toBe(true)
     })

     it('isPastDue returns false for active subscription', () => {
       const subscription = createSubscription(validInput)._unsafeUnwrap()
       expect(isPastDue(subscription)).toBe(false)
     })
   })
   ```
  </action>
  <verify>
`pnpm --filter @strenly/core test` passes.
`pnpm --filter @strenly/core test:coverage` shows 90%+ on subscription.ts.
  </verify>
  <done>
Subscription domain entity created with status transitions, athlete count management, and comprehensive tests.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Repository Ports</name>
  <files>
    packages/core/src/ports/plan-repository.port.ts
    packages/core/src/ports/subscription-repository.port.ts
    packages/core/src/types/organization-context.ts
  </files>
  <action>
Create repository port interfaces following /port skill:

1. **packages/core/src/types/organization-context.ts**:
   ```typescript
   export type OrganizationContext = {
     organizationId: string
     userId: string
     memberRole: 'owner' | 'admin' | 'member'
   }
   ```

2. **packages/core/src/ports/plan-repository.port.ts**:
   ```typescript
   import { ResultAsync } from 'neverthrow'
   import type { Plan, OrganizationType } from '../domain/entities/plan'

   export type PlanRepositoryError =
     | { type: 'NOT_FOUND'; planId: string }
     | { type: 'DATABASE_ERROR'; message: string }

   export type ListPlansOptions = {
     organizationType?: OrganizationType
     activeOnly?: boolean
   }

   export type PlanRepositoryPort = {
     findById(id: string): ResultAsync<Plan, PlanRepositoryError>
     findBySlug(slug: string): ResultAsync<Plan, PlanRepositoryError>
     findAll(options?: ListPlansOptions): ResultAsync<{ items: Plan[]; totalCount: number }, PlanRepositoryError>
   }
   ```

3. **packages/core/src/ports/subscription-repository.port.ts**:
   ```typescript
   import { ResultAsync } from 'neverthrow'
   import type { Subscription } from '../domain/entities/subscription'
   import type { OrganizationContext } from '../types/organization-context'

   export type SubscriptionRepositoryError =
     | { type: 'NOT_FOUND'; organizationId: string }
     | { type: 'DATABASE_ERROR'; message: string }

   export type SubscriptionRepositoryPort = {
     findByOrganizationId(ctx: OrganizationContext): ResultAsync<Subscription, SubscriptionRepositoryError>
     save(ctx: OrganizationContext, subscription: Subscription): ResultAsync<Subscription, SubscriptionRepositoryError>
     updateAthleteCount(ctx: OrganizationContext, count: number): ResultAsync<void, SubscriptionRepositoryError>
   }
   ```

4. Update **packages/core/src/index.ts**:
   ```typescript
   // Domain Entities
   export * from './domain/entities/plan'
   export * from './domain/entities/subscription'

   // Ports
   export * from './ports/plan-repository.port'
   export * from './ports/subscription-repository.port'

   // Types
   export * from './types/organization-context'
   ```
  </action>
  <verify>
`pnpm typecheck` passes.
All ports export interfaces with proper types.
  </verify>
  <done>
Repository ports created with OrganizationContext, proper error types, and pagination support.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @strenly/core typecheck` passes
2. `pnpm --filter @strenly/core test` passes - all tests green
3. `pnpm --filter @strenly/core test:coverage` shows 90%+ coverage on core package
4. Domain entities export factory functions returning Result<Entity, Error>
5. Ports define interfaces with OrganizationContext where appropriate
</verification>

<success_criteria>
Gap closure for Phase 1 architecture:
- Domain entities for Plan and Subscription with business validation
- Comprehensive test coverage (90%+) on core package
- Port interfaces for repositories
- Foundation for 01-07 repository implementation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-multi-tenancy/01-06-SUMMARY.md`
</output>
