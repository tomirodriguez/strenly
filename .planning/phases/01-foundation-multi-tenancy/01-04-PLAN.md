---
phase: 01-foundation-multi-tenancy
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - packages/contracts/src/organizations/organization.ts
  - packages/contracts/src/organizations/create-organization.ts
  - packages/contracts/src/organizations/update-organization.ts
  - packages/contracts/src/organizations/invite-member.ts
  - packages/contracts/src/organizations/member.ts
  - packages/backend/src/procedures/organizations/create-organization.ts
  - packages/backend/src/procedures/organizations/update-organization.ts
  - packages/backend/src/procedures/organizations/get-organization.ts
  - packages/backend/src/procedures/organizations/invite-member.ts
  - packages/backend/src/procedures/organizations/accept-invitation.ts
  - packages/backend/src/procedures/organizations/update-member-role.ts
  - packages/backend/src/procedures/organizations/remove-member.ts
  - packages/backend/src/procedures/organizations/list-user-organizations.ts
  - packages/backend/src/procedures/organizations/list-members.ts
  - packages/backend/src/procedures/organizations/index.ts
  - packages/backend/src/procedures/router.ts
  - packages/database/src/schema/auth.ts
autonomous: true

must_haves:
  truths:
    - "User can create an organization during onboarding with name and type"
    - "Organization owner can update organization details (name)"
    - "Organization owner can invite coaches to organization with email and role"
    - "User can accept invitation and join organization"
    - "Organization owner can assign/change member roles (owner/admin/member)"
    - "Organization owner can remove members from organization"
    - "User can list all organizations they belong to"
    - "Organization data is isolated by organization_id in all queries"
  artifacts:
    - path: "packages/contracts/src/organizations/create-organization.ts"
      provides: "Create organization input/output schemas"
      exports: ["createOrganizationInputSchema"]
    - path: "packages/backend/src/procedures/organizations/create-organization.ts"
      provides: "Create organization procedure"
      exports: ["createOrganization"]
    - path: "packages/backend/src/procedures/organizations/index.ts"
      provides: "Organizations router"
      exports: ["organizationsRouter"]
  key_links:
    - from: "packages/backend/src/procedures/organizations/create-organization.ts"
      to: "Better-Auth organization.create"
      via: "auth.api.createOrganization"
      pattern: "auth\\.api\\.createOrganization"
    - from: "packages/backend/src/procedures/organizations/invite-member.ts"
      to: "Better-Auth organization.inviteMember"
      via: "auth.api.inviteMember"
      pattern: "auth\\.api\\.inviteMember"
---

<objective>
Implement organization management including creation during onboarding, member invitations with roles, and multi-organization membership support.

Purpose: Enables multi-tenancy. Organizations are the isolation boundary for all data. Without orgs, no athlete/program management is possible.
Output: Complete organization API covering ORG-01 through ORG-07 requirements
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-multi-tenancy/01-RESEARCH.md
@.planning/phases/01-foundation-multi-tenancy/01-01-SUMMARY.md
@.planning/phases/01-foundation-multi-tenancy/01-02-SUMMARY.md
@.claude/skills/procedure/SKILL.md
@.claude/skills/contracts/SKILL.md
@.claude/skills/authorization/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Organization Contracts and Core Procedures</name>
  <files>
    packages/contracts/src/organizations/organization.ts
    packages/contracts/src/organizations/create-organization.ts
    packages/contracts/src/organizations/update-organization.ts
    packages/contracts/src/organizations/member.ts
    packages/backend/src/procedures/organizations/create-organization.ts
    packages/backend/src/procedures/organizations/update-organization.ts
    packages/backend/src/procedures/organizations/get-organization.ts
    packages/backend/src/procedures/organizations/list-user-organizations.ts
  </files>
  <action>
Create organization contracts and core management procedures:

1. **packages/contracts/src/organizations/organization.ts** - Base schemas:
   ```typescript
   import { z } from 'zod'

   export const organizationTypeSchema = z.enum(['coach_solo', 'gym'])
   export type OrganizationType = z.infer<typeof organizationTypeSchema>

   export const organizationSchema = z.object({
     id: z.string(),
     name: z.string(),
     slug: z.string(),
     logo: z.string().nullable(),
     type: organizationTypeSchema,
     createdAt: z.string(),
   })

   export type Organization = z.infer<typeof organizationSchema>
   ```

2. **packages/contracts/src/organizations/create-organization.ts**:
   ```typescript
   import { z } from 'zod'
   import { organizationSchema, organizationTypeSchema } from './organization'

   export const createOrganizationInputSchema = z.object({
     name: z.string()
       .min(2, 'El nombre debe tener al menos 2 caracteres')
       .max(100, 'El nombre es muy largo'),
     slug: z.string()
       .min(2, 'El slug debe tener al menos 2 caracteres')
       .max(50, 'El slug es muy largo')
       .regex(/^[a-z0-9-]+$/, 'El slug solo puede contener letras minúsculas, números y guiones'),
     type: organizationTypeSchema,
     planId: z.string(), // Selected subscription plan (required before org creation)
   })

   export const createOrganizationOutputSchema = z.object({
     organization: organizationSchema,
   })

   export type CreateOrganizationInput = z.infer<typeof createOrganizationInputSchema>
   ```

3. **packages/contracts/src/organizations/update-organization.ts**:
   ```typescript
   import { z } from 'zod'
   import { organizationSchema } from './organization'

   export const updateOrganizationInputSchema = z.object({
     name: z.string()
       .min(2, 'El nombre debe tener al menos 2 caracteres')
       .max(100, 'El nombre es muy largo')
       .optional(),
     logo: z.string().url('URL de logo inválida').nullable().optional(),
   })

   export const updateOrganizationOutputSchema = z.object({
     organization: organizationSchema,
   })

   export type UpdateOrganizationInput = z.infer<typeof updateOrganizationInputSchema>
   ```

4. **packages/contracts/src/organizations/member.ts**:
   ```typescript
   import { z } from 'zod'

   export const memberRoleSchema = z.enum(['owner', 'admin', 'member'])
   export type MemberRole = z.infer<typeof memberRoleSchema>

   export const memberSchema = z.object({
     id: z.string(),
     userId: z.string(),
     organizationId: z.string(),
     role: memberRoleSchema,
     user: z.object({
       id: z.string(),
       name: z.string(),
       email: z.string(),
       image: z.string().nullable(),
     }),
     createdAt: z.string(),
   })

   export type Member = z.infer<typeof memberSchema>
   ```

5. **packages/backend/src/procedures/organizations/create-organization.ts**:
   ```typescript
   import { sessionProcedure } from '../../lib/orpc'
   import { createOrganizationInputSchema, createOrganizationOutputSchema } from '@strenly/contracts/organizations/create-organization'
   import { eq } from 'drizzle-orm'
   import { plans, subscriptions } from '@strenly/database/schema'

   export const createOrganization = sessionProcedure
     .errors({
       SLUG_EXISTS: { message: 'Ya existe una organización con ese slug' },
       PLAN_NOT_FOUND: { message: 'Plan no encontrado' },
       INVALID_PLAN_TYPE: { message: 'El plan no es compatible con el tipo de organización' },
     })
     .input(createOrganizationInputSchema)
     .output(createOrganizationOutputSchema)
     .handler(async ({ input, context, errors }) => {
       // 1. Validate plan exists and matches org type
       const [plan] = await context.db
         .select()
         .from(plans)
         .where(eq(plans.id, input.planId))

       if (!plan) {
         throw errors.PLAN_NOT_FOUND()
       }

       if (plan.organizationType !== input.type) {
         throw errors.INVALID_PLAN_TYPE()
       }

       // 2. Create organization via Better-Auth
       const result = await context.auth.api.createOrganization({
         body: {
           name: input.name,
           slug: input.slug,
           metadata: { type: input.type },
         },
         headers: context.headers,
       })

       if (!result) {
         throw errors.SLUG_EXISTS()
       }

       // 3. Create subscription linking org to plan
       await context.db.insert(subscriptions).values({
         id: crypto.randomUUID(),
         organizationId: result.id,
         planId: plan.id,
         status: 'active',
         currentPeriodStart: new Date(),
         currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
         athleteCount: 0,
         createdAt: new Date(),
         updatedAt: new Date(),
       })

       return {
         organization: {
           id: result.id,
           name: result.name,
           slug: result.slug,
           logo: result.logo ?? null,
           type: input.type,
           createdAt: result.createdAt.toISOString(),
         },
       }
     })
   ```

6. **packages/backend/src/procedures/organizations/update-organization.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { updateOrganizationInputSchema, updateOrganizationOutputSchema } from '@strenly/contracts/organizations/update-organization'
   import { organizationTypeSchema } from '@strenly/contracts/organizations/organization'

   export const updateOrganization = authProcedure
     .errors({
       FORBIDDEN: { message: 'Solo el propietario puede actualizar la organización' },
     })
     .input(updateOrganizationInputSchema)
     .output(updateOrganizationOutputSchema)
     .handler(async ({ input, context, errors }) => {
       // Only owner can update organization
       if (context.membership.role !== 'owner') {
         throw errors.FORBIDDEN()
       }

       const result = await context.auth.api.updateOrganization({
         body: {
           organizationId: context.organization.id,
           data: {
             name: input.name,
             logo: input.logo,
           },
         },
         headers: context.headers,
       })

       // Get org type from metadata with Zod validation
       const fullOrg = await context.auth.api.getFullOrganization({
         headers: context.headers,
         query: { organizationId: context.organization.id },
       })

       // Safely parse the type from metadata - default to coach_solo if invalid
       const typeResult = organizationTypeSchema.safeParse(fullOrg?.metadata?.type)
       const orgType = typeResult.success ? typeResult.data : 'coach_solo'

       return {
         organization: {
           id: result.id,
           name: result.name,
           slug: result.slug,
           logo: result.logo ?? null,
           type: orgType,
           createdAt: result.createdAt.toISOString(),
         },
       }
     })
   ```

7. **packages/backend/src/procedures/organizations/get-organization.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { organizationSchema, organizationTypeSchema } from '@strenly/contracts/organizations/organization'
   import { z } from 'zod'

   export const getOrganization = authProcedure
     .output(z.object({ organization: organizationSchema }))
     .handler(async ({ context }) => {
       const fullOrg = await context.auth.api.getFullOrganization({
         headers: context.headers,
         query: { organizationId: context.organization.id },
       })

       // Safely parse the type from metadata - default to coach_solo if invalid
       const typeResult = organizationTypeSchema.safeParse(fullOrg?.metadata?.type)
       const orgType = typeResult.success ? typeResult.data : 'coach_solo'

       return {
         organization: {
           id: context.organization.id,
           name: context.organization.name,
           slug: context.organization.slug,
           logo: fullOrg?.logo ?? null,
           type: orgType,
           createdAt: fullOrg?.createdAt?.toISOString() ?? new Date().toISOString(),
         },
       }
     })
   ```

8. **packages/backend/src/procedures/organizations/list-user-organizations.ts**:
   ```typescript
   import { sessionProcedure } from '../../lib/orpc'
   import { organizationSchema, organizationTypeSchema } from '@strenly/contracts/organizations/organization'
   import { memberRoleSchema } from '@strenly/contracts/organizations/member'
   import { z } from 'zod'

   const userOrganizationSchema = z.object({
     organization: organizationSchema,
     role: memberRoleSchema,
   })

   export const listUserOrganizations = sessionProcedure
     .output(z.object({ organizations: z.array(userOrganizationSchema) }))
     .handler(async ({ context }) => {
       const orgs = await context.auth.api.listOrganizations({
         headers: context.headers,
       })

       return {
         organizations: (orgs ?? []).map((org) => {
           // Safely parse type from metadata
           const typeResult = organizationTypeSchema.safeParse(org.metadata?.type)
           const orgType = typeResult.success ? typeResult.data : 'coach_solo'

           // Safely parse role from members array
           const rawRole = org.members?.[0]?.role
           const roleResult = memberRoleSchema.safeParse(rawRole)
           const role = roleResult.success ? roleResult.data : 'member'

           return {
             organization: {
               id: org.id,
               name: org.name,
               slug: org.slug,
               logo: org.logo ?? null,
               type: orgType,
               createdAt: org.createdAt.toISOString(),
             },
             role,
           }
         }),
       }
     })
   ```

Note: Organization type is stored in metadata since Better-Auth schema doesn't have native type field. All type conversions use Zod safeParse to avoid `as` casting.
  </action>
  <verify>
`pnpm typecheck` passes for packages/contracts and packages/backend.
All organization procedures use contracts schemas.
No `as` type casting - all conversions use Zod safeParse.
  </verify>
  <done>
Core organization procedures implemented:
- createOrganization (with plan selection requirement)
- updateOrganization (owner only)
- getOrganization
- listUserOrganizations (for multi-org membership)
All metadata type extraction uses Zod safeParse instead of type casting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Member Management Procedures and Router</name>
  <files>
    packages/contracts/src/organizations/invite-member.ts
    packages/backend/src/procedures/organizations/invite-member.ts
    packages/backend/src/procedures/organizations/accept-invitation.ts
    packages/backend/src/procedures/organizations/update-member-role.ts
    packages/backend/src/procedures/organizations/remove-member.ts
    packages/backend/src/procedures/organizations/list-members.ts
    packages/backend/src/procedures/organizations/index.ts
    packages/backend/src/procedures/router.ts
  </files>
  <action>
Create member management procedures:

1. **packages/contracts/src/organizations/invite-member.ts**:
   ```typescript
   import { z } from 'zod'
   import { memberRoleSchema } from './member'

   export const inviteMemberInputSchema = z.object({
     email: z.string().email('Email inválido'),
     role: memberRoleSchema.exclude(['owner']), // Cannot invite as owner
   })

   export const invitationStatusSchema = z.enum(['pending', 'accepted', 'rejected', 'canceled'])

   export const inviteMemberOutputSchema = z.object({
     invitation: z.object({
       id: z.string(),
       email: z.string(),
       role: memberRoleSchema,
       status: invitationStatusSchema,
       expiresAt: z.string(),
     }),
   })

   export type InviteMemberInput = z.infer<typeof inviteMemberInputSchema>
   ```

2. **packages/backend/src/procedures/organizations/invite-member.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { inviteMemberInputSchema, inviteMemberOutputSchema, invitationStatusSchema } from '@strenly/contracts/organizations/invite-member'
   import { memberRoleSchema } from '@strenly/contracts/organizations/member'
   import { eq, and } from 'drizzle-orm'
   import { subscriptions, plans } from '@strenly/database/schema'

   export const inviteMember = authProcedure
     .errors({
       FORBIDDEN: { message: 'No tienes permisos para invitar miembros' },
       COACH_LIMIT_EXCEEDED: { message: 'Has alcanzado el límite de coaches de tu plan' },
       ALREADY_INVITED: { message: 'Este email ya tiene una invitación pendiente' },
     })
     .input(inviteMemberInputSchema)
     .output(inviteMemberOutputSchema)
     .handler(async ({ input, context, errors }) => {
       // Only owner and admin can invite
       if (context.membership.role === 'member') {
         throw errors.FORBIDDEN()
       }

       // Check coach limit for gym organizations
       const [subscription] = await context.db
         .select({
           subscription: subscriptions,
           plan: plans,
         })
         .from(subscriptions)
         .innerJoin(plans, eq(subscriptions.planId, plans.id))
         .where(eq(subscriptions.organizationId, context.organization.id))

       if (subscription?.plan.coachLimit !== null) {
         const fullOrg = await context.auth.api.getFullOrganization({
           headers: context.headers,
           query: { organizationId: context.organization.id },
         })
         const currentCoaches = fullOrg?.members?.length ?? 0

         if (currentCoaches >= subscription.plan.coachLimit) {
           throw errors.COACH_LIMIT_EXCEEDED()
         }
       }

       // Create invitation via Better-Auth
       const result = await context.auth.api.createInvitation({
         body: {
           organizationId: context.organization.id,
           email: input.email,
           role: input.role,
         },
         headers: context.headers,
       })

       if (!result) {
         throw errors.ALREADY_INVITED()
       }

       // Safely parse role and status from result
       const roleResult = memberRoleSchema.safeParse(result.role)
       const statusResult = invitationStatusSchema.safeParse(result.status)

       return {
         invitation: {
           id: result.id,
           email: result.email,
           role: roleResult.success ? roleResult.data : 'member',
           status: statusResult.success ? statusResult.data : 'pending',
           expiresAt: result.expiresAt.toISOString(),
         },
       }
     })
   ```

3. **packages/backend/src/procedures/organizations/accept-invitation.ts**:
   ```typescript
   import { sessionProcedure } from '../../lib/orpc'
   import { z } from 'zod'

   export const acceptInvitation = sessionProcedure
     .errors({
       INVITATION_NOT_FOUND: { message: 'Invitación no encontrada o expirada' },
       ALREADY_MEMBER: { message: 'Ya eres miembro de esta organización' },
     })
     .input(z.object({ invitationId: z.string() }))
     .output(z.object({ success: z.boolean() }))
     .handler(async ({ input, context, errors }) => {
       try {
         await context.auth.api.acceptInvitation({
           body: { invitationId: input.invitationId },
           headers: context.headers,
         })
         return { success: true }
       } catch {
         throw errors.INVITATION_NOT_FOUND()
       }
     })
   ```

4. **packages/backend/src/procedures/organizations/update-member-role.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { memberRoleSchema } from '@strenly/contracts/organizations/member'
   import { z } from 'zod'

   export const updateMemberRole = authProcedure
     .errors({
       FORBIDDEN: { message: 'Solo el propietario puede cambiar roles' },
       MEMBER_NOT_FOUND: { message: 'Miembro no encontrado' },
       CANNOT_CHANGE_OWNER: { message: 'No puedes cambiar el rol del propietario' },
     })
     .input(z.object({
       memberId: z.string(),
       role: memberRoleSchema.exclude(['owner']), // Cannot assign owner role
     }))
     .output(z.object({ success: z.boolean() }))
     .handler(async ({ input, context, errors }) => {
       // Only owner can change roles
       if (context.membership.role !== 'owner') {
         throw errors.FORBIDDEN()
       }

       try {
         await context.auth.api.updateMemberRole({
           body: {
             memberId: input.memberId,
             role: input.role,
             organizationId: context.organization.id,
           },
           headers: context.headers,
         })
         return { success: true }
       } catch {
         throw errors.MEMBER_NOT_FOUND()
       }
     })
   ```

5. **packages/backend/src/procedures/organizations/remove-member.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { z } from 'zod'

   export const removeMember = authProcedure
     .errors({
       FORBIDDEN: { message: 'No tienes permisos para eliminar miembros' },
       CANNOT_REMOVE_OWNER: { message: 'No puedes eliminar al propietario' },
       MEMBER_NOT_FOUND: { message: 'Miembro no encontrado' },
     })
     .input(z.object({ memberIdOrEmail: z.string() }))
     .output(z.object({ success: z.boolean() }))
     .handler(async ({ input, context, errors }) => {
       // Only owner can remove members
       if (context.membership.role !== 'owner') {
         throw errors.FORBIDDEN()
       }

       // Cannot remove self (owner)
       if (input.memberIdOrEmail === context.user.id || input.memberIdOrEmail === context.user.email) {
         throw errors.CANNOT_REMOVE_OWNER()
       }

       try {
         await context.auth.api.removeMember({
           body: {
             memberIdOrEmail: input.memberIdOrEmail,
             organizationId: context.organization.id,
           },
           headers: context.headers,
         })
         return { success: true }
       } catch {
         throw errors.MEMBER_NOT_FOUND()
       }
     })
   ```

6. **packages/backend/src/procedures/organizations/list-members.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { memberSchema, memberRoleSchema } from '@strenly/contracts/organizations/member'
   import { z } from 'zod'

   export const listMembers = authProcedure
     .output(z.object({ members: z.array(memberSchema) }))
     .handler(async ({ context }) => {
       const fullOrg = await context.auth.api.getFullOrganization({
         headers: context.headers,
         query: { organizationId: context.organization.id },
       })

       return {
         members: (fullOrg?.members ?? []).map((m) => {
           // Safely parse role from Better-Auth response
           const roleResult = memberRoleSchema.safeParse(m.role)
           const role = roleResult.success ? roleResult.data : 'member'

           return {
             id: m.id,
             userId: m.userId,
             organizationId: m.organizationId,
             role,
             user: {
               id: m.user.id,
               name: m.user.name ?? '',
               email: m.user.email,
               image: m.user.image ?? null,
             },
             createdAt: m.createdAt.toISOString(),
           }
         }),
       }
     })
   ```

7. **packages/backend/src/procedures/organizations/index.ts**:
   ```typescript
   import { os } from '@orpc/server'
   import { createOrganization } from './create-organization'
   import { updateOrganization } from './update-organization'
   import { getOrganization } from './get-organization'
   import { listUserOrganizations } from './list-user-organizations'
   import { inviteMember } from './invite-member'
   import { acceptInvitation } from './accept-invitation'
   import { updateMemberRole } from './update-member-role'
   import { removeMember } from './remove-member'
   import { listMembers } from './list-members'

   export const organizationsRouter = os.router({
     create: createOrganization,
     update: updateOrganization,
     get: getOrganization,
     listUserOrgs: listUserOrganizations,
     inviteMember,
     acceptInvitation,
     updateMemberRole,
     removeMember,
     listMembers,
   })
   ```

8. **packages/backend/src/procedures/router.ts** - Update:
   ```typescript
   import { os } from '@orpc/server'
   import { health } from './health/health'
   import { authRouter } from './auth'
   import { organizationsRouter } from './organizations'

   export const router = os.router({
     health,
     auth: authRouter,
     organizations: organizationsRouter,
   })

   export type Router = typeof router
   ```

Note: Authorization checks ensure:
- Only owner/admin can invite members
- Only owner can change roles and remove members
- Owner role cannot be assigned via updateMemberRole
- All role/status parsing uses Zod safeParse instead of type casting
  </action>
  <verify>
`pnpm typecheck` passes.
Organizations router includes all 9 procedures.
Main router includes organizations namespace.
No `as` type casting - all conversions use Zod safeParse.
  </verify>
  <done>
Member management procedures implemented:
- inviteMember (owner/admin only, respects coach limit)
- acceptInvitation
- updateMemberRole (owner only)
- removeMember (owner only)
- listMembers
Organizations router aggregated and added to main router.
All role/status parsing uses Zod safeParse instead of type casting.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes for all packages
2. Organization procedures accessible via /rpc/organizations.*
3. Authorization checks properly restrict actions by role
4. Coach limit is checked during invitation
5. Multi-org membership works via listUserOrganizations
6. No `as` type casting anywhere - all use Zod safeParse
</verification>

<success_criteria>
Requirements covered:
- ORG-01: User can create organization during onboarding (createOrganization)
- ORG-02: Organization data isolated (inherent in authProcedure middleware)
- ORG-03: Owner can update organization details (updateOrganization)
- ORG-04: Owner can invite coaches (inviteMember)
- ORG-05: Owner can assign roles (updateMemberRole)
- ORG-06: Owner can remove coaches (removeMember)
- ORG-07: User can belong to multiple organizations (listUserOrganizations)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-multi-tenancy/01-04-SUMMARY.md`
</output>
