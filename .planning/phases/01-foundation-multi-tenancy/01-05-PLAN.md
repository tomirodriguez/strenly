---
phase: 01-foundation-multi-tenancy
plan: 05
type: execute
wave: 3
depends_on: ["01-04"]
files_modified:
  - packages/contracts/src/subscriptions/plan.ts
  - packages/contracts/src/subscriptions/subscription.ts
  - packages/backend/src/procedures/subscriptions/list-plans.ts
  - packages/backend/src/procedures/subscriptions/get-subscription.ts
  - packages/backend/src/procedures/subscriptions/index.ts
  - packages/backend/src/procedures/router.ts
  - packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts
  - packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts
  - packages/database/scripts/seed-plans.ts
autonomous: false

must_haves:
  truths:
    - "User can view available subscription plans before creating organization"
    - "User can view current subscription status for their organization"
    - "User cannot add athletes beyond their plan's athlete limit"
    - "User cannot access features not included in their subscription plan"
    - "Plans are seeded in database with different limits for coach_solo and gym types"
  artifacts:
    - path: "packages/contracts/src/subscriptions/plan.ts"
      provides: "Plan schema definitions"
      exports: ["planSchema"]
    - path: "packages/backend/src/procedures/subscriptions/list-plans.ts"
      provides: "List available plans procedure"
      exports: ["listPlans"]
    - path: "packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts"
      provides: "Athlete limit enforcement use case"
      exports: ["checkAthleteLimit"]
    - path: "packages/database/scripts/seed-plans.ts"
      provides: "Database seed script for subscription plans"
  key_links:
    - from: "packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts"
      to: "subscriptions table"
      via: "athleteCount vs plan.athleteLimit comparison"
      pattern: "athleteCount.*athleteLimit"
    - from: "packages/backend/src/procedures/subscriptions/get-subscription.ts"
      to: "plans + subscriptions tables"
      via: "join query"
      pattern: "innerJoin.*plans"
---

<objective>
Implement subscription plan management including plan listing, subscription status viewing, and limit enforcement use cases for athlete counts and feature access.

Purpose: Enables subscription-based feature gating and limit enforcement. Ensures system can restrict features based on plan type.
Output: Complete subscription API covering SUB-01 through SUB-05 requirements, plus enforcement use cases for future athlete/feature limits
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-multi-tenancy/01-RESEARCH.md
@.planning/phases/01-foundation-multi-tenancy/01-01-SUMMARY.md
@.planning/phases/01-foundation-multi-tenancy/01-04-SUMMARY.md
@.claude/skills/procedure/SKILL.md
@.claude/skills/use-case/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Subscription Contracts and Procedures</name>
  <files>
    packages/contracts/src/subscriptions/plan.ts
    packages/contracts/src/subscriptions/subscription.ts
    packages/backend/src/procedures/subscriptions/list-plans.ts
    packages/backend/src/procedures/subscriptions/get-subscription.ts
    packages/backend/src/procedures/subscriptions/index.ts
    packages/backend/src/procedures/router.ts
  </files>
  <action>
Create subscription contracts and API procedures:

1. **packages/contracts/src/subscriptions/plan.ts** - Plan schemas:
   ```typescript
   import { z } from 'zod'
   import { organizationTypeSchema } from '../organizations/organization'

   export const planFeaturesSchema = z.object({
     templates: z.boolean(),
     analytics: z.boolean(),
     exportData: z.boolean(),
     customExercises: z.boolean(),
     multipleCoaches: z.boolean(),
   })

   export const planSchema = z.object({
     id: z.string(),
     name: z.string(),
     slug: z.string(),
     organizationType: organizationTypeSchema,
     athleteLimit: z.number(),
     coachLimit: z.number().nullable(), // null = unlimited
     features: planFeaturesSchema,
     priceMonthly: z.number(), // cents
     priceYearly: z.number(), // cents
     isActive: z.boolean(),
   })

   export type Plan = z.infer<typeof planSchema>
   export type PlanFeatures = z.infer<typeof planFeaturesSchema>
   ```

2. **packages/contracts/src/subscriptions/subscription.ts** - Subscription schemas:
   ```typescript
   import { z } from 'zod'
   import { planSchema } from './plan'

   export const subscriptionStatusSchema = z.enum(['active', 'canceled', 'past_due'])

   export const subscriptionSchema = z.object({
     id: z.string(),
     organizationId: z.string(),
     plan: planSchema,
     status: subscriptionStatusSchema,
     athleteCount: z.number(),
     athleteLimit: z.number(), // denormalized from plan for convenience
     currentPeriodStart: z.string(),
     currentPeriodEnd: z.string(),
     createdAt: z.string(),
   })

   export type Subscription = z.infer<typeof subscriptionSchema>
   export type SubscriptionStatus = z.infer<typeof subscriptionStatusSchema>
   ```

3. **packages/backend/src/procedures/subscriptions/list-plans.ts**:
   ```typescript
   import { publicProcedure } from '../../lib/orpc'
   import { planSchema, planFeaturesSchema } from '@strenly/contracts/subscriptions/plan'
   import { organizationTypeSchema } from '@strenly/contracts/organizations/organization'
   import { z } from 'zod'
   import { eq, and } from 'drizzle-orm'
   import { plans } from '@strenly/database/schema'

   export const listPlans = publicProcedure
     .input(z.object({
       organizationType: organizationTypeSchema.optional(),
     }).optional())
     .output(z.object({ plans: z.array(planSchema) }))
     .handler(async ({ input, context }) => {
       const conditions = [eq(plans.isActive, true)]

       if (input?.organizationType) {
         conditions.push(eq(plans.organizationType, input.organizationType))
       }

       const result = await context.db
         .select()
         .from(plans)
         .where(and(...conditions))
         .orderBy(plans.priceMonthly)

       return {
         plans: result.map((p) => {
           // Safely parse organization type
           const typeResult = organizationTypeSchema.safeParse(p.organizationType)
           const orgType = typeResult.success ? typeResult.data : 'coach_solo'

           // Safely parse features
           const featuresResult = planFeaturesSchema.safeParse(p.features)
           const features = featuresResult.success ? featuresResult.data : {
             templates: false,
             analytics: false,
             exportData: false,
             customExercises: false,
             multipleCoaches: false,
           }

           return {
             id: p.id,
             name: p.name,
             slug: p.slug,
             organizationType: orgType,
             athleteLimit: p.athleteLimit,
             coachLimit: p.coachLimit,
             features,
             priceMonthly: p.priceMonthly,
             priceYearly: p.priceYearly,
             isActive: p.isActive,
           }
         }),
       }
     })
   ```

4. **packages/backend/src/procedures/subscriptions/get-subscription.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { subscriptionSchema, subscriptionStatusSchema } from '@strenly/contracts/subscriptions/subscription'
   import { organizationTypeSchema } from '@strenly/contracts/organizations/organization'
   import { planFeaturesSchema } from '@strenly/contracts/subscriptions/plan'
   import { z } from 'zod'
   import { eq } from 'drizzle-orm'
   import { subscriptions, plans } from '@strenly/database/schema'

   export const getSubscription = authProcedure
     .errors({
       SUBSCRIPTION_NOT_FOUND: { message: 'Suscripcion no encontrada' },
     })
     .output(z.object({ subscription: subscriptionSchema }))
     .handler(async ({ context, errors }) => {
       const [result] = await context.db
         .select({
           subscription: subscriptions,
           plan: plans,
         })
         .from(subscriptions)
         .innerJoin(plans, eq(subscriptions.planId, plans.id))
         .where(eq(subscriptions.organizationId, context.organization.id))

       if (!result) {
         throw errors.SUBSCRIPTION_NOT_FOUND()
       }

       const { subscription, plan } = result

       // Safely parse all enum/complex types
       const typeResult = organizationTypeSchema.safeParse(plan.organizationType)
       const orgType = typeResult.success ? typeResult.data : 'coach_solo'

       const featuresResult = planFeaturesSchema.safeParse(plan.features)
       const features = featuresResult.success ? featuresResult.data : {
         templates: false,
         analytics: false,
         exportData: false,
         customExercises: false,
         multipleCoaches: false,
       }

       const statusResult = subscriptionStatusSchema.safeParse(subscription.status)
       const status = statusResult.success ? statusResult.data : 'active'

       return {
         subscription: {
           id: subscription.id,
           organizationId: subscription.organizationId,
           plan: {
             id: plan.id,
             name: plan.name,
             slug: plan.slug,
             organizationType: orgType,
             athleteLimit: plan.athleteLimit,
             coachLimit: plan.coachLimit,
             features,
             priceMonthly: plan.priceMonthly,
             priceYearly: plan.priceYearly,
             isActive: plan.isActive,
           },
           status,
           athleteCount: subscription.athleteCount,
           athleteLimit: plan.athleteLimit,
           currentPeriodStart: subscription.currentPeriodStart.toISOString(),
           currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),
           createdAt: subscription.createdAt.toISOString(),
         },
       }
     })
   ```

5. **packages/backend/src/procedures/subscriptions/index.ts**:
   ```typescript
   import { os } from '@orpc/server'
   import { listPlans } from './list-plans'
   import { getSubscription } from './get-subscription'

   export const subscriptionsRouter = os.router({
     listPlans,
     getSubscription,
   })
   ```

6. **packages/backend/src/procedures/router.ts** - Update:
   ```typescript
   import { os } from '@orpc/server'
   import { health } from './health/health'
   import { authRouter } from './auth'
   import { organizationsRouter } from './organizations'
   import { subscriptionsRouter } from './subscriptions'

   export const router = os.router({
     health,
     auth: authRouter,
     organizations: organizationsRouter,
     subscriptions: subscriptionsRouter,
   })

   export type Router = typeof router
   ```
  </action>
  <verify>
`pnpm typecheck` passes.
Subscriptions router includes listPlans (public) and getSubscription (auth required).
No `as` type casting - all use Zod safeParse.
  </verify>
  <done>
Subscription procedures implemented:
- listPlans (public, filterable by org type)
- getSubscription (returns current org's subscription with plan details)
All type conversions use Zod safeParse instead of casting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Limit Enforcement Use Cases and Seed Script</name>
  <files>
    packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts
    packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts
    packages/database/scripts/seed-plans.ts
  </files>
  <action>
Create use cases for subscription limit enforcement and seed script:

1. **packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts**:
   ```typescript
   import { ResultAsync, ok, err } from 'neverthrow'
   import { eq, sql } from 'drizzle-orm'
   import { subscriptions, plans } from '@strenly/database/schema'
   import type { DB } from '@strenly/database'

   type SubscriptionNotFoundError = { type: 'SUBSCRIPTION_NOT_FOUND' }
   type AthleteLimitExceededError = { type: 'ATHLETE_LIMIT_EXCEEDED'; currentCount: number; limit: number }
   type CheckAthleteLimitError = SubscriptionNotFoundError | AthleteLimitExceededError

   type CheckAthleteLimitResult = {
     canAdd: boolean
     currentCount: number
     limit: number
     remaining: number
   }

   export function checkAthleteLimit(
     db: DB,
     organizationId: string
   ): ResultAsync<CheckAthleteLimitResult, CheckAthleteLimitError> {
     return ResultAsync.fromPromise(
       (async () => {
         const [result] = await db
           .select({
             athleteCount: subscriptions.athleteCount,
             athleteLimit: plans.athleteLimit,
           })
           .from(subscriptions)
           .innerJoin(plans, eq(subscriptions.planId, plans.id))
           .where(eq(subscriptions.organizationId, organizationId))

         if (!result) {
           return err<CheckAthleteLimitResult, SubscriptionNotFoundError>({ type: 'SUBSCRIPTION_NOT_FOUND' })
         }

         const { athleteCount, athleteLimit } = result
         const remaining = athleteLimit - athleteCount
         const canAdd = remaining > 0

         if (!canAdd) {
           return err<CheckAthleteLimitResult, AthleteLimitExceededError>({
             type: 'ATHLETE_LIMIT_EXCEEDED',
             currentCount: athleteCount,
             limit: athleteLimit,
           })
         }

         return ok<CheckAthleteLimitResult, CheckAthleteLimitError>({
           canAdd: true,
           currentCount: athleteCount,
           limit: athleteLimit,
           remaining,
         })
       })(),
       (): SubscriptionNotFoundError => ({ type: 'SUBSCRIPTION_NOT_FOUND' })
     ).andThen((result) => result)
   }

   export async function incrementAthleteCount(
     db: DB,
     organizationId: string
   ): Promise<void> {
     await db
       .update(subscriptions)
       .set({
         athleteCount: sql`${subscriptions.athleteCount} + 1`,
         updatedAt: new Date(),
       })
       .where(eq(subscriptions.organizationId, organizationId))
   }

   export async function decrementAthleteCount(
     db: DB,
     organizationId: string
   ): Promise<void> {
     await db
       .update(subscriptions)
       .set({
         athleteCount: sql`GREATEST(${subscriptions.athleteCount} - 1, 0)`,
         updatedAt: new Date(),
       })
       .where(eq(subscriptions.organizationId, organizationId))
   }
   ```

2. **packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts**:
   ```typescript
   import { ResultAsync, ok, err } from 'neverthrow'
   import { eq } from 'drizzle-orm'
   import { subscriptions, plans } from '@strenly/database/schema'
   import type { DB } from '@strenly/database'
   import { planFeaturesSchema, type PlanFeatures } from '@strenly/contracts/subscriptions/plan'

   type FeatureName = keyof PlanFeatures

   type SubscriptionNotFoundError = { type: 'SUBSCRIPTION_NOT_FOUND' }
   type FeatureNotAvailableError = { type: 'FEATURE_NOT_AVAILABLE'; feature: FeatureName }
   type CheckFeatureAccessError = SubscriptionNotFoundError | FeatureNotAvailableError

   export function checkFeatureAccess(
     db: DB,
     organizationId: string,
     feature: FeatureName
   ): ResultAsync<boolean, CheckFeatureAccessError> {
     return ResultAsync.fromPromise(
       (async () => {
         const [result] = await db
           .select({
             features: plans.features,
           })
           .from(subscriptions)
           .innerJoin(plans, eq(subscriptions.planId, plans.id))
           .where(eq(subscriptions.organizationId, organizationId))

         if (!result) {
           return err<boolean, SubscriptionNotFoundError>({ type: 'SUBSCRIPTION_NOT_FOUND' })
         }

         // Safely parse features using Zod
         const featuresResult = planFeaturesSchema.safeParse(result.features)
         if (!featuresResult.success) {
           // Features couldn't be parsed - deny access
           return err<boolean, FeatureNotAvailableError>({
             type: 'FEATURE_NOT_AVAILABLE',
             feature,
           })
         }

         const features = featuresResult.data
         const hasAccess = features[feature] ?? false

         if (!hasAccess) {
           return err<boolean, FeatureNotAvailableError>({
             type: 'FEATURE_NOT_AVAILABLE',
             feature,
           })
         }

         return ok<boolean, CheckFeatureAccessError>(true)
       })(),
       (): SubscriptionNotFoundError => ({ type: 'SUBSCRIPTION_NOT_FOUND' })
     ).andThen((result) => result)
   }
   ```

3. **packages/database/scripts/seed-plans.ts**:
   ```typescript
   import { drizzle } from 'drizzle-orm/postgres-js'
   import postgres from 'postgres'
   import { plans } from '../src/schema'

   const DATABASE_URL = process.env.DATABASE_URL
   if (!DATABASE_URL) {
     throw new Error('DATABASE_URL environment variable is required')
   }

   const sql = postgres(DATABASE_URL)
   const db = drizzle(sql)

   const defaultPlans = [
     // Coach Solo Plans
     {
       id: crypto.randomUUID(),
       name: 'Coach Starter',
       slug: 'coach-starter',
       organizationType: 'coach_solo',
       athleteLimit: 10,
       coachLimit: 1,
       features: {
         templates: true,
         analytics: false,
         exportData: false,
         customExercises: true,
         multipleCoaches: false,
       },
       priceMonthly: 0, // Free tier
       priceYearly: 0,
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     {
       id: crypto.randomUUID(),
       name: 'Coach Pro',
       slug: 'coach-pro',
       organizationType: 'coach_solo',
       athleteLimit: 50,
       coachLimit: 1,
       features: {
         templates: true,
         analytics: true,
         exportData: true,
         customExercises: true,
         multipleCoaches: false,
       },
       priceMonthly: 2900, // $29/mo
       priceYearly: 29000, // $290/yr (~17% discount)
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     // Gym Plans
     {
       id: crypto.randomUUID(),
       name: 'Gym Starter',
       slug: 'gym-starter',
       organizationType: 'gym',
       athleteLimit: 50,
       coachLimit: 3,
       features: {
         templates: true,
         analytics: false,
         exportData: false,
         customExercises: true,
         multipleCoaches: true,
       },
       priceMonthly: 4900, // $49/mo
       priceYearly: 49000, // $490/yr
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     {
       id: crypto.randomUUID(),
       name: 'Gym Pro',
       slug: 'gym-pro',
       organizationType: 'gym',
       athleteLimit: 200,
       coachLimit: 10,
       features: {
         templates: true,
         analytics: true,
         exportData: true,
         customExercises: true,
         multipleCoaches: true,
       },
       priceMonthly: 9900, // $99/mo
       priceYearly: 99000, // $990/yr
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     {
       id: crypto.randomUUID(),
       name: 'Gym Enterprise',
       slug: 'gym-enterprise',
       organizationType: 'gym',
       athleteLimit: 1000,
       coachLimit: null, // Unlimited coaches
       features: {
         templates: true,
         analytics: true,
         exportData: true,
         customExercises: true,
         multipleCoaches: true,
       },
       priceMonthly: 19900, // $199/mo
       priceYearly: 199000, // $1990/yr
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
   ]

   async function seedPlans() {
     console.log('Seeding subscription plans...')

     // Delete existing plans (for clean re-seed)
     await db.delete(plans)

     // Insert new plans
     await db.insert(plans).values(defaultPlans)

     console.log(`Seeded ${defaultPlans.length} subscription plans:`)
     for (const plan of defaultPlans) {
       console.log(`  - ${plan.name} (${plan.organizationType}): ${plan.athleteLimit} athletes`)
     }

     await sql.end()
   }

   seedPlans().catch(console.error)
   ```

Add to package.json scripts:
```json
"db:seed:plans": "tsx scripts/seed-plans.ts"
```

Note: Use cases return neverthrow Result types for composability with other use cases. Error types are defined as explicit discriminated unions - neverthrow infers the union from ok/err calls correctly without needing `as const`.
  </action>
  <verify>
`pnpm typecheck` passes.
Seed script can be run with `pnpm db:seed:plans`.
No `as const` or other type casting in use cases.
  </verify>
  <done>
Subscription limit enforcement implemented:
- checkAthleteLimit use case (checks and returns remaining capacity)
- incrementAthleteCount / decrementAthleteCount helpers
- checkFeatureAccess use case (validates feature availability)
- Seed script creates 5 plans (2 coach solo, 3 gym)
All use proper TypeScript discriminated unions without casting.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete subscription system with plans, status viewing, and limit enforcement</what-built>
  <how-to-verify>
1. Start the development server: `pnpm dev`
2. Seed the plans: `pnpm db:seed:plans`
3. Test list plans: GET /rpc/subscriptions.listPlans (should return 5 plans)
4. Test filter by type: POST /rpc/subscriptions.listPlans with {"organizationType":"coach_solo"} (should return 2 plans)
5. Create an organization (from 01-04) and test get subscription: GET /rpc/subscriptions.getSubscription (with X-Organization-Slug header)

Expected:
- 5 plans seeded (Coach Starter, Coach Pro, Gym Starter, Gym Pro, Gym Enterprise)
- Plans filterable by organization type
- Subscription shows plan details, athlete count (0), and athlete limit
- Different plans have different feature flags and limits
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes for all packages
2. Plans seeded in database with correct structure
3. listPlans returns plans filterable by org type
4. getSubscription returns org's subscription with plan details
5. Use cases can be imported and used by future athlete procedures
6. No `as` casting or `as const` - all use Zod safeParse or explicit type annotations
</verification>

<success_criteria>
Requirements covered:
- SUB-01: User must select subscription plan before creating org (enforced in createOrganization)
- SUB-02: System enforces feature limits (checkFeatureAccess use case)
- SUB-03: System enforces athlete limits (checkAthleteLimit use case)
- SUB-04: User can view current subscription status (getSubscription)
- SUB-05: Plans configured by org type (organizationType field, seed script)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-multi-tenancy/01-05-SUMMARY.md`
</output>
