---
phase: 01-foundation-multi-tenancy
plan: 05
type: execute
wave: 3
depends_on: ["01-04"]
files_modified:
  - packages/contracts/src/subscriptions/plan.ts
  - packages/contracts/src/subscriptions/subscription.ts
  - packages/backend/src/procedures/subscriptions/list-plans.ts
  - packages/backend/src/procedures/subscriptions/get-subscription.ts
  - packages/backend/src/procedures/subscriptions/index.ts
  - packages/backend/src/procedures/router.ts
  - packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts
  - packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts
  - packages/database/scripts/seed-plans.ts
autonomous: false

must_haves:
  truths:
    - "User can view available subscription plans before creating organization"
    - "User can view current subscription status for their organization"
    - "System has use case to check athlete limit before adding athletes"
    - "System has use case to check feature access based on plan"
    - "Plans are seeded in database with different limits for coach_solo and gym types"
  artifacts:
    - path: "packages/contracts/src/subscriptions/plan.ts"
      provides: "Plan schema definitions"
      exports: ["planSchema"]
    - path: "packages/backend/src/procedures/subscriptions/list-plans.ts"
      provides: "List available plans procedure"
      exports: ["listPlans"]
    - path: "packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts"
      provides: "Athlete limit enforcement use case"
      exports: ["checkAthleteLimit"]
    - path: "packages/database/scripts/seed-plans.ts"
      provides: "Database seed script for subscription plans"
  key_links:
    - from: "packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts"
      to: "subscriptions table"
      via: "athleteCount vs plan.athleteLimit comparison"
      pattern: "athleteCount.*athleteLimit"
    - from: "packages/backend/src/procedures/subscriptions/get-subscription.ts"
      to: "plans + subscriptions tables"
      via: "join query"
      pattern: "innerJoin.*plans"
---

<objective>
Implement subscription plan management including plan listing, subscription status viewing, and limit enforcement use cases for athlete counts and feature access.

Purpose: Enables subscription-based feature gating and limit enforcement. Ensures system can restrict features based on plan type.
Output: Complete subscription API covering SUB-01 through SUB-05 requirements, plus enforcement use cases for future athlete/feature limits
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-multi-tenancy/01-RESEARCH.md
@.planning/phases/01-foundation-multi-tenancy/01-01-SUMMARY.md
@.planning/phases/01-foundation-multi-tenancy/01-04-SUMMARY.md
@.claude/skills/procedure/SKILL.md
@.claude/skills/use-case/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Subscription Contracts and Procedures</name>
  <files>
    packages/contracts/src/subscriptions/plan.ts
    packages/contracts/src/subscriptions/subscription.ts
    packages/backend/src/procedures/subscriptions/list-plans.ts
    packages/backend/src/procedures/subscriptions/get-subscription.ts
    packages/backend/src/procedures/subscriptions/index.ts
    packages/backend/src/procedures/router.ts
  </files>
  <action>
Create subscription contracts and API procedures:

1. **packages/contracts/src/subscriptions/plan.ts** - Plan schemas:
   ```typescript
   import { z } from 'zod'
   import { organizationTypeSchema } from '../organizations/organization'

   export const planFeaturesSchema = z.object({
     templates: z.boolean(),
     analytics: z.boolean(),
     exportData: z.boolean(),
     customExercises: z.boolean(),
     multipleCoaches: z.boolean(),
   })

   export const planSchema = z.object({
     id: z.string(),
     name: z.string(),
     slug: z.string(),
     organizationType: organizationTypeSchema,
     athleteLimit: z.number(),
     coachLimit: z.number().nullable(), // null = unlimited
     features: planFeaturesSchema,
     priceMonthly: z.number(), // cents
     priceYearly: z.number(), // cents
     isActive: z.boolean(),
   })

   export type Plan = z.infer<typeof planSchema>
   export type PlanFeatures = z.infer<typeof planFeaturesSchema>
   ```

2. **packages/contracts/src/subscriptions/subscription.ts** - Subscription schemas:
   ```typescript
   import { z } from 'zod'
   import { planSchema } from './plan'

   export const subscriptionStatusSchema = z.enum(['active', 'canceled', 'past_due'])

   export const subscriptionSchema = z.object({
     id: z.string(),
     organizationId: z.string(),
     plan: planSchema,
     status: subscriptionStatusSchema,
     athleteCount: z.number(),
     athleteLimit: z.number(), // denormalized from plan for convenience
     currentPeriodStart: z.string(),
     currentPeriodEnd: z.string(),
     createdAt: z.string(),
   })

   export type Subscription = z.infer<typeof subscriptionSchema>
   export type SubscriptionStatus = z.infer<typeof subscriptionStatusSchema>
   ```

3. **packages/backend/src/procedures/subscriptions/list-plans.ts**:
   ```typescript
   import { publicProcedure } from '../../lib/orpc'
   import { planSchema } from '@strenly/contracts/subscriptions/plan'
   import { organizationTypeSchema } from '@strenly/contracts/organizations/organization'
   import { z } from 'zod'
   import { eq, and } from 'drizzle-orm'
   import { plans } from '@strenly/database/schema'

   export const listPlans = publicProcedure
     .input(z.object({
       organizationType: organizationTypeSchema.optional(),
     }).optional())
     .output(z.object({ plans: z.array(planSchema) }))
     .handler(async ({ input, context }) => {
       const conditions = [eq(plans.isActive, true)]

       if (input?.organizationType) {
         conditions.push(eq(plans.organizationType, input.organizationType))
       }

       const result = await context.db
         .select()
         .from(plans)
         .where(and(...conditions))
         .orderBy(plans.priceMonthly)

       return {
         plans: result.map((p) => ({
           id: p.id,
           name: p.name,
           slug: p.slug,
           organizationType: p.organizationType as 'coach_solo' | 'gym',
           athleteLimit: p.athleteLimit,
           coachLimit: p.coachLimit,
           features: p.features as z.infer<typeof planSchema>['features'],
           priceMonthly: p.priceMonthly,
           priceYearly: p.priceYearly,
           isActive: p.isActive,
         })),
       }
     })
   ```

4. **packages/backend/src/procedures/subscriptions/get-subscription.ts**:
   ```typescript
   import { authProcedure } from '../../lib/orpc'
   import { subscriptionSchema } from '@strenly/contracts/subscriptions/subscription'
   import { z } from 'zod'
   import { eq } from 'drizzle-orm'
   import { subscriptions, plans } from '@strenly/database/schema'

   export const getSubscription = authProcedure
     .errors({
       SUBSCRIPTION_NOT_FOUND: { message: 'SuscripciÃ³n no encontrada' },
     })
     .output(z.object({ subscription: subscriptionSchema }))
     .handler(async ({ context, errors }) => {
       const [result] = await context.db
         .select({
           subscription: subscriptions,
           plan: plans,
         })
         .from(subscriptions)
         .innerJoin(plans, eq(subscriptions.planId, plans.id))
         .where(eq(subscriptions.organizationId, context.organization.id))

       if (!result) {
         throw errors.SUBSCRIPTION_NOT_FOUND()
       }

       const { subscription, plan } = result

       return {
         subscription: {
           id: subscription.id,
           organizationId: subscription.organizationId,
           plan: {
             id: plan.id,
             name: plan.name,
             slug: plan.slug,
             organizationType: plan.organizationType as 'coach_solo' | 'gym',
             athleteLimit: plan.athleteLimit,
             coachLimit: plan.coachLimit,
             features: plan.features as z.infer<typeof subscriptionSchema>['plan']['features'],
             priceMonthly: plan.priceMonthly,
             priceYearly: plan.priceYearly,
             isActive: plan.isActive,
           },
           status: subscription.status as 'active' | 'canceled' | 'past_due',
           athleteCount: subscription.athleteCount,
           athleteLimit: plan.athleteLimit,
           currentPeriodStart: subscription.currentPeriodStart.toISOString(),
           currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),
           createdAt: subscription.createdAt.toISOString(),
         },
       }
     })
   ```

5. **packages/backend/src/procedures/subscriptions/index.ts**:
   ```typescript
   import { os } from '@orpc/server'
   import { listPlans } from './list-plans'
   import { getSubscription } from './get-subscription'

   export const subscriptionsRouter = os.router({
     listPlans,
     getSubscription,
   })
   ```

6. **packages/backend/src/procedures/router.ts** - Update:
   ```typescript
   import { os } from '@orpc/server'
   import { health } from './health/health'
   import { authRouter } from './auth'
   import { organizationsRouter } from './organizations'
   import { subscriptionsRouter } from './subscriptions'

   export const router = os.router({
     health,
     auth: authRouter,
     organizations: organizationsRouter,
     subscriptions: subscriptionsRouter,
   })

   export type Router = typeof router
   ```
  </action>
  <verify>
`pnpm typecheck` passes.
Subscriptions router includes listPlans (public) and getSubscription (auth required).
  </verify>
  <done>
Subscription procedures implemented:
- listPlans (public, filterable by org type)
- getSubscription (returns current org's subscription with plan details)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Limit Enforcement Use Cases and Seed Script</name>
  <files>
    packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts
    packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts
    packages/database/scripts/seed-plans.ts
  </files>
  <action>
Create use cases for subscription limit enforcement and seed script:

1. **packages/backend/src/application/use-cases/subscriptions/check-athlete-limit.ts**:
   ```typescript
   import { ResultAsync, ok, err } from 'neverthrow'
   import { eq } from 'drizzle-orm'
   import { subscriptions, plans } from '@strenly/database/schema'
   import type { DB } from '@strenly/database'

   type CheckAthleteLimitError =
     | { type: 'SUBSCRIPTION_NOT_FOUND' }
     | { type: 'ATHLETE_LIMIT_EXCEEDED'; currentCount: number; limit: number }

   type CheckAthleteLimitResult = {
     canAdd: boolean
     currentCount: number
     limit: number
     remaining: number
   }

   export function checkAthleteLimit(
     db: DB,
     organizationId: string
   ): ResultAsync<CheckAthleteLimitResult, CheckAthleteLimitError> {
     return ResultAsync.fromPromise(
       (async () => {
         const [result] = await db
           .select({
             athleteCount: subscriptions.athleteCount,
             athleteLimit: plans.athleteLimit,
           })
           .from(subscriptions)
           .innerJoin(plans, eq(subscriptions.planId, plans.id))
           .where(eq(subscriptions.organizationId, organizationId))

         if (!result) {
           return err({ type: 'SUBSCRIPTION_NOT_FOUND' as const })
         }

         const { athleteCount, athleteLimit } = result
         const remaining = athleteLimit - athleteCount
         const canAdd = remaining > 0

         if (!canAdd) {
           return err({
             type: 'ATHLETE_LIMIT_EXCEEDED' as const,
             currentCount: athleteCount,
             limit: athleteLimit,
           })
         }

         return ok({
           canAdd: true,
           currentCount: athleteCount,
           limit: athleteLimit,
           remaining,
         })
       })(),
       () => ({ type: 'SUBSCRIPTION_NOT_FOUND' as const })
     ).andThen((result) => result)
   }

   export async function incrementAthleteCount(
     db: DB,
     organizationId: string
   ): Promise<void> {
     await db
       .update(subscriptions)
       .set({
         athleteCount: sql`${subscriptions.athleteCount} + 1`,
         updatedAt: new Date(),
       })
       .where(eq(subscriptions.organizationId, organizationId))
   }

   export async function decrementAthleteCount(
     db: DB,
     organizationId: string
   ): Promise<void> {
     await db
       .update(subscriptions)
       .set({
         athleteCount: sql`GREATEST(${subscriptions.athleteCount} - 1, 0)`,
         updatedAt: new Date(),
       })
       .where(eq(subscriptions.organizationId, organizationId))
   }
   ```

   Add the sql import at top:
   ```typescript
   import { eq, sql } from 'drizzle-orm'
   ```

2. **packages/backend/src/application/use-cases/subscriptions/check-feature-access.ts**:
   ```typescript
   import { ResultAsync, ok, err } from 'neverthrow'
   import { eq } from 'drizzle-orm'
   import { subscriptions, plans } from '@strenly/database/schema'
   import type { DB } from '@strenly/database'
   import type { PlanFeatures } from '@strenly/contracts/subscriptions/plan'

   type FeatureName = keyof PlanFeatures

   type CheckFeatureAccessError =
     | { type: 'SUBSCRIPTION_NOT_FOUND' }
     | { type: 'FEATURE_NOT_AVAILABLE'; feature: FeatureName }

   export function checkFeatureAccess(
     db: DB,
     organizationId: string,
     feature: FeatureName
   ): ResultAsync<boolean, CheckFeatureAccessError> {
     return ResultAsync.fromPromise(
       (async () => {
         const [result] = await db
           .select({
             features: plans.features,
           })
           .from(subscriptions)
           .innerJoin(plans, eq(subscriptions.planId, plans.id))
           .where(eq(subscriptions.organizationId, organizationId))

         if (!result) {
           return err({ type: 'SUBSCRIPTION_NOT_FOUND' as const })
         }

         const features = result.features as PlanFeatures
         const hasAccess = features[feature] ?? false

         if (!hasAccess) {
           return err({
             type: 'FEATURE_NOT_AVAILABLE' as const,
             feature,
           })
         }

         return ok(true)
       })(),
       () => ({ type: 'SUBSCRIPTION_NOT_FOUND' as const })
     ).andThen((result) => result)
   }
   ```

3. **packages/database/scripts/seed-plans.ts**:
   ```typescript
   import { drizzle } from 'drizzle-orm/postgres-js'
   import postgres from 'postgres'
   import { plans } from '../src/schema'

   const DATABASE_URL = process.env.DATABASE_URL
   if (!DATABASE_URL) {
     throw new Error('DATABASE_URL environment variable is required')
   }

   const sql = postgres(DATABASE_URL)
   const db = drizzle(sql)

   const defaultPlans = [
     // Coach Solo Plans
     {
       id: crypto.randomUUID(),
       name: 'Coach Starter',
       slug: 'coach-starter',
       organizationType: 'coach_solo' as const,
       athleteLimit: 10,
       coachLimit: 1,
       features: {
         templates: true,
         analytics: false,
         exportData: false,
         customExercises: true,
         multipleCoaches: false,
       },
       priceMonthly: 0, // Free tier
       priceYearly: 0,
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     {
       id: crypto.randomUUID(),
       name: 'Coach Pro',
       slug: 'coach-pro',
       organizationType: 'coach_solo' as const,
       athleteLimit: 50,
       coachLimit: 1,
       features: {
         templates: true,
         analytics: true,
         exportData: true,
         customExercises: true,
         multipleCoaches: false,
       },
       priceMonthly: 2900, // $29/mo
       priceYearly: 29000, // $290/yr (~17% discount)
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     // Gym Plans
     {
       id: crypto.randomUUID(),
       name: 'Gym Starter',
       slug: 'gym-starter',
       organizationType: 'gym' as const,
       athleteLimit: 50,
       coachLimit: 3,
       features: {
         templates: true,
         analytics: false,
         exportData: false,
         customExercises: true,
         multipleCoaches: true,
       },
       priceMonthly: 4900, // $49/mo
       priceYearly: 49000, // $490/yr
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     {
       id: crypto.randomUUID(),
       name: 'Gym Pro',
       slug: 'gym-pro',
       organizationType: 'gym' as const,
       athleteLimit: 200,
       coachLimit: 10,
       features: {
         templates: true,
         analytics: true,
         exportData: true,
         customExercises: true,
         multipleCoaches: true,
       },
       priceMonthly: 9900, // $99/mo
       priceYearly: 99000, // $990/yr
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
     {
       id: crypto.randomUUID(),
       name: 'Gym Enterprise',
       slug: 'gym-enterprise',
       organizationType: 'gym' as const,
       athleteLimit: 1000,
       coachLimit: null, // Unlimited coaches
       features: {
         templates: true,
         analytics: true,
         exportData: true,
         customExercises: true,
         multipleCoaches: true,
       },
       priceMonthly: 19900, // $199/mo
       priceYearly: 199000, // $1990/yr
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
     },
   ]

   async function seedPlans() {
     console.log('Seeding subscription plans...')

     // Delete existing plans (for clean re-seed)
     await db.delete(plans)

     // Insert new plans
     await db.insert(plans).values(defaultPlans)

     console.log(`Seeded ${defaultPlans.length} subscription plans:`)
     for (const plan of defaultPlans) {
       console.log(`  - ${plan.name} (${plan.organizationType}): ${plan.athleteLimit} athletes`)
     }

     await sql.end()
   }

   seedPlans().catch(console.error)
   ```

Add to package.json scripts:
```json
"db:seed:plans": "tsx scripts/seed-plans.ts"
```

Note: Use cases return neverthrow Result types for composability with other use cases.
  </action>
  <verify>
`pnpm typecheck` passes.
Seed script can be run with `pnpm db:seed:plans`.
  </verify>
  <done>
Subscription limit enforcement implemented:
- checkAthleteLimit use case (checks and returns remaining capacity)
- incrementAthleteCount / decrementAthleteCount helpers
- checkFeatureAccess use case (validates feature availability)
- Seed script creates 5 plans (2 coach solo, 3 gym)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete subscription system with plans, status viewing, and limit enforcement</what-built>
  <how-to-verify>
1. Start the development server: `pnpm dev`
2. Seed the plans: `pnpm db:seed:plans`
3. Test list plans: GET /rpc/subscriptions.listPlans (should return 5 plans)
4. Test filter by type: POST /rpc/subscriptions.listPlans with {"organizationType":"coach_solo"} (should return 2 plans)
5. Create an organization (from 01-04) and test get subscription: GET /rpc/subscriptions.getSubscription (with X-Organization-Slug header)

Expected:
- 5 plans seeded (Coach Starter, Coach Pro, Gym Starter, Gym Pro, Gym Enterprise)
- Plans filterable by organization type
- Subscription shows plan details, athlete count (0), and athlete limit
- Different plans have different feature flags and limits
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes for all packages
2. Plans seeded in database with correct structure
3. listPlans returns plans filterable by org type
4. getSubscription returns org's subscription with plan details
5. Use cases can be imported and used by future athlete procedures
</verification>

<success_criteria>
Requirements covered:
- SUB-01: User must select subscription plan before creating org (enforced in createOrganization)
- SUB-02: System enforces feature limits (checkFeatureAccess use case)
- SUB-03: System enforces athlete limits (checkAthleteLimit use case)
- SUB-04: User can view current subscription status (getSubscription)
- SUB-05: Plans configured by org type (organizationType field, seed script)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-multi-tenancy/01-05-SUMMARY.md`
</output>
