---
phase: 02-exercise-library-athlete-management
plan: 06
type: execute
wave: 3
depends_on: ["02-04"]
files_modified:
  - packages/backend/src/use-cases/athletes/create-athlete.ts
  - packages/backend/src/use-cases/athletes/list-athletes.ts
  - packages/backend/src/use-cases/athletes/get-athlete.ts
  - packages/backend/src/use-cases/athletes/update-athlete.ts
  - packages/backend/src/use-cases/athletes/archive-athlete.ts
autonomous: true

must_haves:
  truths:
    - "All use cases check authorization FIRST"
    - "Athlete creation validates via domain entity"
    - "List athletes returns paginated results with totalCount"
    - "Archive sets status to inactive, not delete"
  artifacts:
    - path: "packages/backend/src/use-cases/athletes/create-athlete.ts"
      provides: "Create athlete use case"
      exports: ["makeCreateAthlete"]
    - path: "packages/backend/src/use-cases/athletes/list-athletes.ts"
      provides: "List athletes use case"
      exports: ["makeListAthletes"]
    - path: "packages/backend/src/use-cases/athletes/get-athlete.ts"
      provides: "Get athlete use case"
      exports: ["makeGetAthlete"]
  key_links:
    - from: "packages/backend/src/use-cases/athletes/create-athlete.ts"
      to: "@strenly/core"
      via: "uses hasPermission and createAthlete"
      pattern: "hasPermission.*athletes:write"
---

<objective>
Implement athlete CRUD use cases following authorization-first pattern.

Purpose: Business logic layer for athlete management with proper authorization.
Output: Use case factory functions for create, list, get, update, archive.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-exercise-library-athlete-management/02-RESEARCH.md
@packages/backend/src/use-cases/subscriptions/get-subscription.ts
@packages/core/src/services/authorization.ts
@packages/core/src/ports/athlete-repository.port.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Athlete Use Case</name>
  <files>packages/backend/src/use-cases/athletes/create-athlete.ts</files>
  <action>
Create create-athlete.ts following get-subscription.ts pattern:

Type definitions:
- CreateAthleteInput = OrganizationContext & { memberRole, name, email?, phone?, birthdate?, gender?, notes? }
- CreateAthleteError = forbidden | validation_error | repository_error
- Dependencies = { athleteRepository, generateId }

makeCreateAthlete(deps) => (input) => ResultAsync<Athlete, Error>:
1. Authorization FIRST: Check hasPermission(memberRole, "athletes:write")
   - If false, return errAsync({ type: "forbidden", message: "..." })
2. Domain validation: Call createAthlete factory from @strenly/core
   - If err, return errAsync({ type: "validation_error", message: error.message })
3. Persist: Call athleteRepository.create(ctx, athlete)
   - Map repository errors to CreateAthleteError
4. Return ok(athlete)

Use neverthrow errAsync/okAsync, not Promise.reject.
  </action>
  <verify>pnpm typecheck --filter @strenly/backend</verify>
  <done>Create athlete use case with authorization and domain validation</done>
</task>

<task type="auto">
  <name>Task 2: List and Get Athlete Use Cases</name>
  <files>
    packages/backend/src/use-cases/athletes/list-athletes.ts
    packages/backend/src/use-cases/athletes/get-athlete.ts
  </files>
  <action>
Create list-athletes.ts:
- ListAthletesInput = OrganizationContext & { memberRole, status?, search?, limit?, offset? }
- ListAthletesError = forbidden | repository_error
- makeListAthletes(deps) => (input) => ResultAsync<{ items, totalCount }, Error>

Flow:
1. Authorization: hasPermission(memberRole, "athletes:read")
2. Call athleteRepository.findAll(ctx, options)
3. Return { items, totalCount }

Create get-athlete.ts:
- GetAthleteInput = OrganizationContext & { memberRole, athleteId }
- GetAthleteError = forbidden | not_found | repository_error
- makeGetAthlete(deps) => (input) => ResultAsync<Athlete, Error>

Flow:
1. Authorization: hasPermission(memberRole, "athletes:read")
2. Call athleteRepository.findById(ctx, athleteId)
3. If NOT_FOUND, return errAsync({ type: "not_found", athleteId })
4. Return ok(athlete)
  </action>
  <verify>pnpm typecheck --filter @strenly/backend</verify>
  <done>List and Get athlete use cases implemented</done>
</task>

<task type="auto">
  <name>Task 3: Update and Archive Athlete Use Cases</name>
  <files>
    packages/backend/src/use-cases/athletes/update-athlete.ts
    packages/backend/src/use-cases/athletes/archive-athlete.ts
  </files>
  <action>
Create update-athlete.ts:
- UpdateAthleteInput = OrganizationContext & { memberRole, athleteId, name?, email?, phone?, birthdate?, gender?, notes?, status? }
- UpdateAthleteError = forbidden | not_found | validation_error | repository_error
- makeUpdateAthlete(deps) => (input) => ResultAsync<Athlete, Error>

Flow:
1. Authorization: hasPermission(memberRole, "athletes:write")
2. Fetch existing: athleteRepository.findById(ctx, athleteId)
3. Merge updates with existing athlete data
4. Domain validation: createAthlete(merged) to validate
5. Persist: athleteRepository.update(ctx, updatedAthlete)

Create archive-athlete.ts:
- ArchiveAthleteInput = OrganizationContext & { memberRole, athleteId }
- ArchiveAthleteError = forbidden | not_found | repository_error
- makeArchiveAthlete(deps) => (input) => ResultAsync<void, Error>

Flow:
1. Authorization: hasPermission(memberRole, "athletes:write")
2. Call athleteRepository.archive(ctx, athleteId)
3. Return ok(undefined)

Note: archive changes status to "inactive", does NOT delete.
  </action>
  <verify>pnpm typecheck --filter @strenly/backend</verify>
  <done>Update and Archive athlete use cases implemented</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck --filter @strenly/backend` passes
2. All use cases check authorization FIRST
3. All use cases use neverthrow ResultAsync
4. Error types are discriminated unions
5. Archive uses status change, not delete
</verification>

<success_criteria>
- Create athlete validates via domain entity
- List athletes supports pagination and filtering
- Get athlete returns 404 if not found
- Update athlete merges with existing data
- Archive athlete sets status to inactive
- All operations require athletes:read or athletes:write permission
</success_criteria>

<output>
After completion, create `.planning/phases/02-exercise-library-athlete-management/02-06-SUMMARY.md`
</output>
