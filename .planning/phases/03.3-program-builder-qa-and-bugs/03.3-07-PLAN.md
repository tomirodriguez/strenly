---
phase: 03.3-program-builder-qa-and-bugs
plan: 07
type: execute
wave: 2
depends_on: ["06"]
files_modified:
  - apps/coach-web/src/stores/grid-store.ts
  - apps/coach-web/src/components/programs/grid-toolbar.tsx
  - apps/coach-web/src/components/programs/add-session-modal.tsx
  - apps/coach-web/src/routes/_authenticated/$orgSlug/programs/$programId.tsx
  - packages/contracts/src/programs/save-draft.ts
  - packages/core/src/ports/program-repository.port.ts
  - packages/backend/src/use-cases/programs/save-draft.ts
  - packages/backend/src/infrastructure/repositories/program.repository.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Add week button updates local state without API call - network tab shows zero requests"
    - "Add session modal updates local state without API call - network tab shows zero requests"
    - "Save button persists new weeks, sessions, and exercises to database"
    - "Unsaved changes indicator appears after adding week or session"
  artifacts:
    - path: "apps/coach-web/src/stores/grid-store.ts"
      provides: "addWeek and addSession actions with change tracking"
      exports: ["useGridStore", "useGridActions"]
    - path: "apps/coach-web/src/components/programs/grid-toolbar.tsx"
      provides: "Toolbar wired to store actions instead of mutations"
    - path: "packages/contracts/src/programs/save-draft.ts"
      provides: "Extended saveDraft schema with structural changes"
      contains: "newWeeks"
    - path: "packages/backend/src/use-cases/programs/save-draft.ts"
      provides: "saveDraft handling structural changes"
  key_links:
    - from: "apps/coach-web/src/components/programs/grid-toolbar.tsx"
      to: "apps/coach-web/src/stores/grid-store.ts"
      via: "useGridActions().addWeek"
      pattern: "addWeek\\("
    - from: "apps/coach-web/src/components/programs/add-session-modal.tsx"
      to: "apps/coach-web/src/stores/grid-store.ts"
      via: "useGridActions().addSession"
      pattern: "addSession\\("
---

<objective>
Make ALL program builder operations client-side only with no API calls until explicit save.

Currently, Add Week and Add Session trigger immediate API calls. This violates the core requirement that ALL builder operations are client-side in Zustand store until the user clicks "Guardar".

Purpose: Complete the client-side editing vision from Phase 3.2
Output: Zero network requests during editing; Save button persists all structural changes
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.3-program-builder-qa-and-bugs/03.3-UAT.md

# Relevant source files
@apps/coach-web/src/stores/grid-store.ts
@apps/coach-web/src/components/programs/grid-toolbar.tsx
@apps/coach-web/src/components/programs/add-session-modal.tsx
@apps/coach-web/src/routes/_authenticated/$orgSlug/programs/$programId.tsx
@packages/contracts/src/programs/save-draft.ts
@packages/core/src/ports/program-repository.port.ts
@packages/backend/src/use-cases/programs/save-draft.ts
@packages/backend/src/infrastructure/repositories/program.repository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add week/session actions to grid store with change tracking</name>
  <files>apps/coach-web/src/stores/grid-store.ts</files>
  <action>
Add `addWeek` and `addSession` actions to the grid store with proper change tracking for saveDraft.

**Add new change tracking interfaces:**

```typescript
/**
 * Tracked new week for bulk save
 */
interface NewWeek {
  tempId: string      // Client-generated ID (temp-week-xxx)
  name: string
  orderIndex: number
}

/**
 * Tracked new session for bulk save
 */
interface NewSession {
  tempId: string      // Client-generated ID (temp-session-xxx)
  name: string
  orderIndex: number
}

/**
 * Tracked new exercise row for bulk save
 */
interface NewExerciseRow {
  tempId: string
  sessionId: string   // May be a tempId if session is also new
  exerciseId: string
  orderIndex: number
}
```

**Add to GridState:**

```typescript
interface GridState {
  // ... existing fields ...

  // Structural change tracking
  newWeeks: Map<string, NewWeek>
  newSessions: Map<string, NewSession>
  newExerciseRows: Map<string, NewExerciseRow>
}
```

**Add addWeek action:**

```typescript
addWeek: () =>
  set((state) => {
    if (!state.data) return state

    const tempId = `temp-week-${Date.now()}`
    const orderIndex = state.data.columns.filter((c) => c.type === 'week').length
    const name = `Semana ${orderIndex + 1}`

    // Add column to grid data
    const newColumn: GridColumn = {
      id: tempId,
      name,
      type: 'week',
      weekId: tempId,
    }

    // Add empty prescriptions for all exercise rows
    const updatedRows = state.data.rows.map((row) => {
      if (row.type === 'exercise') {
        return {
          ...row,
          prescriptions: {
            ...row.prescriptions,
            [tempId]: '',
          },
        }
      }
      return row
    })

    // Track the new week
    const newWeeks = new Map(state.newWeeks)
    newWeeks.set(tempId, { tempId, name, orderIndex })

    return {
      data: {
        ...state.data,
        columns: [...state.data.columns, newColumn],
        rows: updatedRows,
      },
      isDirty: true,
      newWeeks,
    }
  }),
```

**Add addSession action:**

```typescript
addSession: (name: string) =>
  set((state) => {
    if (!state.data) return state

    const tempId = `temp-session-${Date.now()}`

    // Calculate order index (count existing sessions)
    const existingSessionIds = new Set<string>()
    for (const row of state.data.rows) {
      if (row.sessionId) existingSessionIds.add(row.sessionId)
    }
    const orderIndex = existingSessionIds.size

    // Get all week IDs for empty prescriptions
    const weekIds = state.data.columns
      .filter((col) => col.type === 'week' && col.weekId)
      .map((col) => col.weekId as string)

    // Create empty prescriptions map
    const prescriptions: Record<string, string> = {}
    for (const weekId of weekIds) {
      prescriptions[weekId] = ''
    }

    // Create session header row
    const sessionHeaderRow: GridRow = {
      id: `session-header-${tempId}`,
      type: 'session-header',
      sessionId: tempId,
      sessionName: name,
      supersetGroup: null,
      supersetOrder: null,
      supersetPosition: null,
      isSubRow: false,
      parentRowId: null,
      setTypeLabel: null,
      prescriptions: {},
    }

    // Create add-exercise row for this session
    const addExerciseRow: GridRow = {
      id: `add-exercise-${tempId}`,
      type: 'add-exercise',
      sessionId: tempId,
      sessionName: name,
      supersetGroup: null,
      supersetOrder: null,
      supersetPosition: null,
      isSubRow: false,
      parentRowId: null,
      setTypeLabel: null,
      prescriptions: {},
    }

    // Track the new session
    const newSessions = new Map(state.newSessions)
    newSessions.set(tempId, { tempId, name, orderIndex })

    return {
      data: {
        ...state.data,
        rows: [...state.data.rows, sessionHeaderRow, addExerciseRow],
      },
      isDirty: true,
      newSessions,
    }
  }),
```

**Update addExercise to track new rows:**

```typescript
addExercise: (sessionId, exerciseId, exerciseName) =>
  set((state) => {
    // ... existing logic to create newRow ...

    // Track new exercise row for saveDraft
    const newExerciseRows = new Map(state.newExerciseRows)
    newExerciseRows.set(tempId, {
      tempId,
      sessionId,
      exerciseId,
      orderIndex,
    })

    return {
      data: { ...state.data, rows: updatedRows },
      isDirty: true,
      newExerciseRows,
    }
  }),
```

**Update getChanges to include structural changes:**

```typescript
getChanges: () => {
  const state = get()
  return {
    prescriptions: Array.from(state.changedPrescriptions.values()),
    exerciseRows: Array.from(state.changedExerciseRows.values()),
    newWeeks: Array.from(state.newWeeks.values()),
    newSessions: Array.from(state.newSessions.values()),
    newExerciseRows: Array.from(state.newExerciseRows.values()),
    lastLoadedAt: state.lastLoadedAt,
  }
}
```

**Update initialize and reset to clear structural tracking:**

```typescript
initialize: (programId, data) =>
  set({
    // ... existing fields ...
    newWeeks: new Map(),
    newSessions: new Map(),
    newExerciseRows: new Map(),
  }),

reset: (data) =>
  set({
    // ... existing fields ...
    newWeeks: new Map(),
    newSessions: new Map(),
    newExerciseRows: new Map(),
  }),

markSaved: () =>
  set({
    // ... existing fields ...
    newWeeks: new Map(),
    newSessions: new Map(),
    newExerciseRows: new Map(),
  }),
```

**Update useGridActions export:**

```typescript
export const useGridActions = () =>
  useGridStore(
    useShallow((state) => ({
      // ... existing actions ...
      addWeek: state.addWeek,
      addSession: state.addSession,
    })),
  )
```
  </action>
  <verify>
1. Typecheck passes: `pnpm typecheck`
2. Lint passes: `pnpm lint`
  </verify>
  <done>Grid store has addWeek and addSession actions with proper change tracking for bulk save</done>
</task>

<task type="auto">
  <name>Task 2: Wire toolbar and modal to store actions</name>
  <files>
    apps/coach-web/src/components/programs/grid-toolbar.tsx
    apps/coach-web/src/components/programs/add-session-modal.tsx
  </files>
  <action>
**Update grid-toolbar.tsx:**

Remove useAddWeek mutation import and replace with store action:

```typescript
import { CalendarDays, Columns, Plus } from 'lucide-react'
import { useState } from 'react'
import { AddSessionModal } from './add-session-modal'
import { Button } from '@/components/ui/button'
import { useGridActions } from '@/stores/grid-store'

type GridToolbarProps = {
  programId: string
  weekCount: number
  sessionCount: number
}

export function GridToolbar({ programId, weekCount, sessionCount }: GridToolbarProps) {
  const [addSessionOpen, setAddSessionOpen] = useState(false)
  const { addWeek } = useGridActions()

  const handleAddWeek = () => {
    addWeek()  // Local state only - no API call
  }

  return (
    <>
      <div className="flex items-center justify-between border-border border-t bg-muted/30 px-4 py-2">
        {/* Counts */}
        <div className="flex items-center gap-4 text-muted-foreground text-sm">
          <div className="flex items-center gap-1.5">
            <Columns className="size-4" />
            <span>
              {weekCount} {weekCount === 1 ? 'semana' : 'semanas'}
            </span>
          </div>
          <div className="flex items-center gap-1.5">
            <CalendarDays className="size-4" />
            <span>
              {sessionCount} {sessionCount === 1 ? 'sesion' : 'sesiones'}
            </span>
          </div>
        </div>

        {/* Actions */}
        <div className="flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={handleAddWeek}>
            <Plus className="size-4" />
            Semana
          </Button>
          <Button variant="outline" size="sm" onClick={() => setAddSessionOpen(true)}>
            <Plus className="size-4" />
            Sesion
          </Button>
        </div>
      </div>

      <AddSessionModal open={addSessionOpen} onOpenChange={setAddSessionOpen} />
    </>
  )
}
```

Note: Removed `programId` prop from AddSessionModal (no longer needed for API call).

**Update add-session-modal.tsx:**

Remove useAddSession mutation import and replace with store action:

```typescript
import { useState } from 'react'
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { useGridActions } from '@/stores/grid-store'

type AddSessionModalProps = {
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function AddSessionModal({ open, onOpenChange }: AddSessionModalProps) {
  const [name, setName] = useState('')
  const { addSession } = useGridActions()

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    const trimmedName = name.trim()
    if (!trimmedName) return

    addSession(trimmedName)  // Local state only - no API call
    setName('')
    onOpenChange(false)
  }

  const handleOpenChange = (nextOpen: boolean) => {
    if (!nextOpen) {
      setName('')
    }
    onOpenChange(nextOpen)
  }

  return (
    <Dialog open={open} onOpenChange={handleOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Agregar Sesion</DialogTitle>
          <DialogDescription>
            Agrega un nuevo dia de entrenamiento al programa. Por ejemplo: "DIA 4 - PULL" o "TREN SUPERIOR".
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit}>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="session-name">Nombre de la sesion *</Label>
              <Input
                id="session-name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="DIA 1 - PUSH"
                maxLength={100}
                required
                autoFocus
              />
            </div>
          </div>

          <DialogFooter>
            <DialogClose>
              <Button type="button" variant="outline">
                Cancelar
              </Button>
            </DialogClose>
            <Button type="submit" disabled={!name.trim()}>
              Agregar Sesion
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

Note: Removed isPending state (no API call), removed programId prop.
  </action>
  <verify>
1. Typecheck passes: `pnpm typecheck`
2. Lint passes: `pnpm lint`
3. Build passes: `pnpm --filter @strenly/coach-web build`
4. Manual test: Open Network tab in DevTools, click "Semana" button - verify NO network request
5. Manual test: Open Network tab, click "Sesion" button, enter name, submit - verify NO network request
6. Manual test: Verify save button shows "Cambios sin guardar" after adding week or session
  </verify>
  <done>Toolbar and modal use store actions instead of mutations - zero API calls during editing</done>
</task>

<task type="auto">
  <name>Task 3: Extend saveDraft backend to handle structural changes</name>
  <files>
    packages/contracts/src/programs/save-draft.ts
    packages/core/src/ports/program-repository.port.ts
    packages/backend/src/use-cases/programs/save-draft.ts
    packages/backend/src/infrastructure/repositories/program.repository.ts
    apps/coach-web/src/routes/_authenticated/$orgSlug/programs/$programId.tsx
  </files>
  <action>
**Update packages/contracts/src/programs/save-draft.ts:**

Add schemas for new weeks, sessions, and exercises:

```typescript
import { z } from 'zod'
import { prescriptionSeriesInputSchema } from './prescription'

// ... existing schemas ...

/**
 * New week to create
 */
const newWeekSchema = z.object({
  tempId: z.string(),   // Client-generated ID for reference
  name: z.string(),
  orderIndex: z.number(),
})

/**
 * New session to create
 */
const newSessionSchema = z.object({
  tempId: z.string(),
  name: z.string(),
  orderIndex: z.number(),
})

/**
 * New exercise row to create
 */
const newExerciseRowSchema = z.object({
  tempId: z.string(),
  sessionId: z.string(),  // Can be a tempId if session is also new
  exerciseId: z.string(),
  orderIndex: z.number(),
})

/**
 * Save draft input - bulk program state update
 */
export const saveDraftInputSchema = z.object({
  programId: z.string(),
  // Existing changes
  prescriptions: z.array(prescriptionUpdateSchema).default([]),
  exerciseRows: z.array(exerciseRowUpdateSchema).default([]),
  groups: z.array(groupUpdateSchema).default([]),
  // Structural changes (new entities)
  newWeeks: z.array(newWeekSchema).default([]),
  newSessions: z.array(newSessionSchema).default([]),
  newExerciseRows: z.array(newExerciseRowSchema).default([]),
  // Conflict detection
  lastLoadedAt: z.coerce.date().optional(),
})

export type SaveDraftInput = z.infer<typeof saveDraftInputSchema>
export type NewWeek = z.infer<typeof newWeekSchema>
export type NewSession = z.infer<typeof newSessionSchema>
export type NewExerciseRow = z.infer<typeof newExerciseRowSchema>
```

**Update packages/core/src/ports/program-repository.port.ts:**

Add structural change types to SaveDraftInput:

```typescript
export type SaveDraftInput = {
  readonly programId: string
  // Existing update fields...
  readonly prescriptionUpdates?: ReadonlyArray<{...}>
  readonly exerciseRowUpdates?: ReadonlyArray<{...}>
  readonly groupUpdates?: ReadonlyArray<{...}>
  // NEW: Structural changes
  readonly newWeeks?: ReadonlyArray<{
    readonly tempId: string
    readonly name: string
    readonly orderIndex: number
  }>
  readonly newSessions?: ReadonlyArray<{
    readonly tempId: string
    readonly name: string
    readonly orderIndex: number
  }>
  readonly newExerciseRows?: ReadonlyArray<{
    readonly tempId: string
    readonly sessionId: string  // May be tempId
    readonly exerciseId: string
    readonly orderIndex: number
  }>
}
```

**Update packages/backend/src/use-cases/programs/save-draft.ts:**

Map the new structural fields from contract to repository:

```typescript
// In makeSaveDraft, update repoInput construction:
const repoInput: RepoSaveDraftInput = {
  programId: input.programId,
  // ... existing fields ...

  // Map new structural changes
  newWeeks: input.newWeeks?.map((w) => ({
    tempId: w.tempId,
    name: w.name,
    orderIndex: w.orderIndex,
  })),
  newSessions: input.newSessions?.map((s) => ({
    tempId: s.tempId,
    name: s.name,
    orderIndex: s.orderIndex,
  })),
  newExerciseRows: input.newExerciseRows?.map((r) => ({
    tempId: r.tempId,
    sessionId: r.sessionId,
    exerciseId: r.exerciseId,
    orderIndex: r.orderIndex,
  })),
}
```

**Update packages/backend/src/infrastructure/repositories/program.repository.ts:**

Update the saveDraft method to handle structural changes:

```typescript
saveDraft: (ctx, input) =>
  ResultAsync.fromPromise(
    db.transaction(async (tx) => {
      // Build a map of tempId -> realId for resolving references
      const tempIdMap = new Map<string, string>()

      // 1. Create new weeks first (columns)
      if (input.newWeeks?.length) {
        for (const week of input.newWeeks) {
          const realId = crypto.randomUUID()
          tempIdMap.set(week.tempId, realId)

          await tx.insert(programWeeks).values({
            id: realId,
            programId: input.programId,
            name: week.name,
            orderIndex: week.orderIndex,
            createdAt: new Date(),
            updatedAt: new Date(),
          })
        }
      }

      // 2. Create new sessions
      if (input.newSessions?.length) {
        for (const session of input.newSessions) {
          const realId = crypto.randomUUID()
          tempIdMap.set(session.tempId, realId)

          await tx.insert(programSessions).values({
            id: realId,
            programId: input.programId,
            name: session.name,
            orderIndex: session.orderIndex,
            createdAt: new Date(),
            updatedAt: new Date(),
          })
        }
      }

      // 3. Create new exercise rows (resolve session tempIds)
      if (input.newExerciseRows?.length) {
        for (const row of input.newExerciseRows) {
          const realId = crypto.randomUUID()
          tempIdMap.set(row.tempId, realId)

          // Resolve sessionId (may be tempId from a new session)
          const sessionId = tempIdMap.get(row.sessionId) ?? row.sessionId

          await tx.insert(programExercises).values({
            id: realId,
            sessionId,
            exerciseId: row.exerciseId,
            orderIndex: row.orderIndex,
            groupId: null,
            orderWithinGroup: null,
            setTypeLabel: null,
            notes: null,
            restSeconds: null,
            createdAt: new Date(),
            updatedAt: new Date(),
          })
        }
      }

      // 4. Apply existing prescription updates (resolve tempIds in exercise/week refs)
      if (input.prescriptionUpdates?.length) {
        for (const update of input.prescriptionUpdates) {
          // Resolve tempIds to real IDs
          const exerciseRowId = tempIdMap.get(update.exerciseRowId) ?? update.exerciseRowId
          const weekId = tempIdMap.get(update.weekId) ?? update.weekId

          // ... existing prescription update logic ...
        }
      }

      // 5. Apply exercise row updates
      if (input.exerciseRowUpdates?.length) {
        for (const update of input.exerciseRowUpdates) {
          const rowId = tempIdMap.get(update.rowId) ?? update.rowId
          // ... existing update logic ...
        }
      }

      // 6. Update program timestamp
      const now = new Date()
      await tx
        .update(programs)
        .set({ updatedAt: now })
        .where(eq(programs.id, input.programId))

      return { updatedAt: now }
    }),
    (e) => ({
      type: 'DATABASE_ERROR' as const,
      message: e instanceof Error ? e.message : 'Unknown error',
    }),
  ),
```

**Update apps/coach-web/src/routes/_authenticated/$orgSlug/programs/$programId.tsx:**

Modify the `handleSave` function to pass structural changes from `getChanges()` to the mutation:

1. The `getChanges()` function (updated in Task 1) now returns `newWeeks`, `newSessions`, and `newExerciseRows` arrays
2. Update `handleSave` to include these fields in the mutation call:

```typescript
const handleSave = useCallback(() => {
  const changes = actions.getChanges()
  saveMutation.mutate({
    programId,
    // Existing fields
    prescriptions: changes.prescriptions,
    exerciseRows: changes.exerciseRows,
    groups: [],
    // NEW: Add structural changes
    newWeeks: changes.newWeeks,
    newSessions: changes.newSessions,
    newExerciseRows: changes.newExerciseRows,
    // Conflict detection
    lastLoadedAt: changes.lastLoadedAt ?? undefined,
  })
}, [actions, programId, saveMutation])
```

The `use-save-draft.ts` hook does not need changes - it already uses the oRPC mutation options which will accept the new schema fields once the contracts are updated.
  </action>
  <verify>
1. Typecheck passes: `pnpm typecheck`
2. Lint passes: `pnpm lint`
3. Build passes: `pnpm build`
4. Manual test full flow:
   - Open a program
   - Click "Semana" - verify column appears, no network request
   - Click "Sesion", enter name - verify session appears, no network request
   - Click "+ Agregar ejercicio" in new session - verify row appears
   - Click "Guardar" - verify single API call saves everything
   - Refresh page - verify weeks, sessions, exercises persist
  </verify>
  <done>saveDraft backend handles structural changes; new weeks/sessions/exercises persist on save</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build and lint:**
   ```bash
   pnpm typecheck && pnpm lint && pnpm build
   ```

2. **Client-side only test (Test 11):**
   - Open program grid
   - Open DevTools Network tab, filter by "Fetch/XHR"
   - Click "Semana" button
   - Verify: NO network request, new column appears, save button shows unsaved
   - Click "Sesion" button, enter name, submit
   - Verify: NO network request, new session appears in grid
   - Click "+ Agregar ejercicio" in the new session, select exercise
   - Verify: NO network request, exercise row appears
   - Click "Guardar"
   - Verify: ONE network request (saveDraft), all changes persisted
   - Refresh page
   - Verify: New week column, session, and exercise persist

3. **Existing functionality preserved:**
   - Edit prescription cell, save - works
   - Change exercise selection, save - works
   - Superset operations still work (local state)
</verification>

<success_criteria>
- [ ] Add week updates local state only (zero network requests)
- [ ] Add session updates local state only (zero network requests)
- [ ] Add exercise (from 03.3-02) now tracked for persistence
- [ ] Save button persists all structural changes in one API call
- [ ] New weeks, sessions, exercises survive page refresh
- [ ] Build passes with no TypeScript errors
- [ ] Lint passes with no Biome errors
</success_criteria>

<output>
After completion, create `.planning/phases/03.3-program-builder-qa-and-bugs/03.3-07-SUMMARY.md`
</output>
