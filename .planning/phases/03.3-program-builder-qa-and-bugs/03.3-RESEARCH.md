# Phase 3.3: Program Builder QA & Bug Fixes - Research

**Researched:** 2026-01-26
**Domain:** React client-side state management, Excel-like grid editing, Zustand
**Confidence:** HIGH

## Summary

This phase focuses on completing the client-side editing transition and fixing remaining UI/UX bugs in the program builder grid. The core challenge is converting all grid operations (add week, add session, add exercise, update prescription, change superset) from immediate server mutations to local Zustand store updates, with a single explicit "Guardar" save action.

The codebase already has a solid foundation: a Zustand store (`grid-store.ts`) that tracks changes, a `saveDraft` procedure for bulk saving, and the grid infrastructure. However, several operations still trigger server mutations directly. Additionally, there are specific UX bugs around edit mode behavior, keyboard navigation, and superset functionality that need addressing.

The research reveals these bugs stem from: (1) incomplete migration to client-side state, (2) incorrect edit mode triggers in prescription cells, (3) `select()` being called instead of `setSelectionRange` for cursor positioning, (4) superset menu not receiving sessionRows data correctly, and (5) the create program form lacking a sessions count field.

**Primary recommendation:** Extend the Zustand store with actions for all grid structural operations (add/delete week, session, exercise), fix the cell editing behavior to only trigger on specific keys, and ensure cursor positioning uses `setSelectionRange(length, length)` instead of `select()`.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Zustand | 5.x | Client-side state management | Already in use, handles draft state |
| React | 19.x | UI framework | Project standard |
| TanStack Query | 5.x | Server state management | Handles cache invalidation after save |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| zustand/react/shallow | - | Selector optimization | For object/array selectors |
| immer | 10.x | Immutable state updates | Optional - for complex nested updates |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Zustand | Redux Toolkit | Zustand already in place, RTK overkill for this |
| Manual immutable updates | Immer middleware | Current approach is working, Immer adds complexity |

**Installation:**
Already installed - no new packages needed.

## Architecture Patterns

### Current State Flow (Problematic)
```
User Action → Grid Component → Server Mutation → Refetch → Re-render
```

### Target State Flow (Client-Side First)
```
User Action → Grid Component → Zustand Store Update → Local Re-render
                                      ↓
                               "Guardar" Click
                                      ↓
                               saveDraft Mutation → Server
                                      ↓
                               markSaved() → Clear dirty flag
```

### Recommended Store Structure Extension
```typescript
// Current store handles: prescriptions, exerciseRows
// Need to add: weeks, sessions, exercises (structural changes)

interface GridState {
  // Data
  data: GridData | null
  programId: string | null

  // Dirty tracking
  isDirty: boolean
  lastLoadedAt: Date | null

  // Change tracking for efficient save
  changedPrescriptions: Map<string, PrescriptionChange>
  changedExerciseRows: Map<string, ExerciseRowChange>

  // NEW: Structural changes (need server persistence)
  pendingAddWeeks: AddWeekChange[]
  pendingAddSessions: AddSessionChange[]
  pendingAddExercises: AddExerciseChange[]
  pendingDeleteWeeks: string[]
  pendingDeleteSessions: string[]
  pendingDeleteExercises: string[]

  // NEW: Superset changes
  changedGroups: Map<string, GroupChange>
}
```

### Pattern 1: Client-Side Structural Changes
**What:** Add operations create temporary IDs, update local state, track for server sync
**When to use:** Add week, add session, add exercise
**Example:**
```typescript
// Source: Verified pattern from Zustand docs
addWeek: () =>
  set((state) => {
    if (!state.data) return state

    const tempId = `temp-week-${Date.now()}`
    const newWeek = {
      id: tempId,
      name: `Semana ${state.data.columns.length}`,
      weekNumber: state.data.columns.length,
    }

    // Add column to grid
    const newColumn: GridColumn = {
      id: tempId,
      type: 'week',
      weekId: tempId,
      name: newWeek.name,
    }

    // Add empty prescriptions to all exercise rows
    const updatedRows = state.data.rows.map(row => {
      if (row.type === 'exercise') {
        return {
          ...row,
          prescriptions: { ...row.prescriptions, [tempId]: '' }
        }
      }
      return row
    })

    return {
      data: {
        ...state.data,
        columns: [...state.data.columns, newColumn],
        rows: updatedRows,
      },
      isDirty: true,
      pendingAddWeeks: [...state.pendingAddWeeks, { tempId, name: newWeek.name }],
    }
  }),
```

### Pattern 2: Edit Mode Triggers (Prescription Cell)
**What:** Only enter edit mode on specific keys (Enter, F2, double-click, or digits 0-9)
**When to use:** PrescriptionCell onKeyDown handler
**Example:**
```typescript
// Source: Verified pattern from Excel-like grid implementations
const handleCellKeyDown = (e: React.KeyboardEvent) => {
  // Only handle edit mode triggers - let navigation keys bubble to grid
  switch (e.key) {
    case 'Enter':
    case 'F2':
      e.preventDefault()
      onStartEdit()
      break
    default:
      // Only start editing on numeric keys (0-9)
      if (/^[0-9]$/.test(e.key) && !e.ctrlKey && !e.metaKey && !e.altKey) {
        e.preventDefault()
        setEditValue(e.key) // Start with typed digit
        onStartEdit()
      }
      // Let all other keys (letters, arrows, etc.) bubble to grid
  }
}
```

### Pattern 3: Cursor Position at End (Not Select All)
**What:** When entering edit mode, position cursor at end instead of selecting all text
**When to use:** When isEditing becomes true in PrescriptionCell
**Example:**
```typescript
// Source: Verified from React controlled input patterns
useEffect(() => {
  if (isEditing && inputRef.current) {
    inputRef.current.focus()
    // Position cursor at end instead of select()
    const length = inputRef.current.value.length
    inputRef.current.setSelectionRange(length, length)
  }
}, [isEditing])
```

### Pattern 4: Arrow Keys in Edit Mode (Cursor Movement vs Navigation)
**What:** Arrow keys should move cursor within input, not navigate cells
**When to use:** Input onKeyDown in edit mode
**Example:**
```typescript
// Source: Verified Excel-like behavior
const handleKeyDown = (e: React.KeyboardEvent) => {
  switch (e.key) {
    case 'ArrowLeft':
      // Only navigate to previous cell if cursor is at start of input
      if (inputRef.current?.selectionStart === 0 &&
          inputRef.current?.selectionEnd === 0) {
        e.preventDefault()
        onCommit(editValue)
        onNavigate('left')
      }
      // Otherwise, let default cursor movement happen (don't prevent)
      break
    case 'ArrowRight':
      // Only navigate to next cell if cursor is at end of input
      if (inputRef.current?.selectionStart === editValue.length) {
        e.preventDefault()
        onCommit(editValue)
        onNavigate('right')
      }
      // Otherwise, let default cursor movement happen
      break
    case 'ArrowUp':
    case 'ArrowDown':
      // These always commit and navigate (no cursor movement in single-line input)
      e.preventDefault()
      onCommit(editValue)
      onNavigate(e.key === 'ArrowUp' ? 'up' : 'down')
      break
  }
}
```

### Anti-Patterns to Avoid
- **Calling select() on focus:** This selects all text. Use `setSelectionRange(len, len)` for cursor at end.
- **Server mutations on every keystroke:** Batch changes and save on explicit action.
- **Storing edit state in multiple places:** Use single source of truth (Zustand) for grid state.
- **Preventing default on all arrow keys in edit mode:** This breaks cursor movement within input.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Cursor position management | Manual DOM manipulation | `setSelectionRange(start, end)` | Standard API, handles edge cases |
| Immutable state updates | Deep cloning | Zustand's built-in immutability or Immer | Performance, correctness |
| Form validation | Manual checks | Zod schemas from contracts | Consistency with backend |
| Focus management | Manual refs everywhere | `requestAnimationFrame` + DOM queries | Timing issues with React |

**Key insight:** The grid editing patterns are well-established. The bugs stem from incomplete implementation of standard patterns, not from novel problems.

## Common Pitfalls

### Pitfall 1: Edit Mode Triggered on Any Key
**What goes wrong:** Typing "abc" triggers edit mode and types "abc" instead of being ignored
**Why it happens:** Current code starts editing on "any printable character" (line 123 in prescription-cell.tsx)
**How to avoid:** Restrict edit triggers to Enter, F2, double-click, and numeric keys only
**Warning signs:** User types letter, edit mode opens unexpectedly

### Pitfall 2: Select All Instead of Cursor at End
**What goes wrong:** `inputRef.current?.select()` selects all text
**Why it happens:** Lines 51-52 in prescription-cell.tsx call `select()` instead of positioning cursor
**How to avoid:** Use `setSelectionRange(length, length)` to position cursor at end
**Warning signs:** Entering edit mode highlights all existing text

### Pitfall 3: Arrow Keys Navigate Cells While Editing
**What goes wrong:** Pressing left/right arrow in middle of text navigates to adjacent cell
**Why it happens:** Current code only checks cursor position for left (start) and right (end), but still prevents default
**How to avoid:** Only call `e.preventDefault()` when actually navigating, let cursor movement happen naturally
**Warning signs:** Cannot move cursor within input using arrow keys

### Pitfall 4: Wrong Cell Gets Edited After Navigation
**What goes wrong:** After editing cell A1 and navigating to B2, next edit opens A1 again
**Why it happens:** `lastEditedCellRef` used for focus restoration may interfere with new active cell
**How to avoid:** Ensure `activeCell` state is updated before `startEditing` is called
**Warning signs:** Edit modal/input appears in wrong cell position

### Pitfall 5: Server Calls Still Happening
**What goes wrong:** Add week/session/exercise still triggers immediate server mutation
**Why it happens:** GridToolbar, AddSessionModal, AddExerciseRow call useAddWeek, useAddSession, useAddExerciseRow directly
**How to avoid:** Replace mutation hooks with Zustand store actions, save pending changes on "Guardar"
**Warning signs:** Network requests on every structural change

### Pitfall 6: Superset Menu Shows Only "Create A"
**What goes wrong:** Menu only shows "Crear superserie A" even when other groups exist
**Why it happens:** sessionRows array passed to ExerciseRowActions may not contain superset data
**How to avoid:** Verify transform-program.ts includes supersetGroup in row data, pass to menu
**Warning signs:** Cannot join existing superset groups

## Code Examples

Verified patterns for implementing fixes:

### Fix 1: Prescription Cell Edit Mode Triggers
```typescript
// Source: Excel-like grid best practices
const handleCellKeyDown = (e: React.KeyboardEvent) => {
  switch (e.key) {
    case 'Enter':
    case 'F2':
      e.preventDefault()
      onStartEdit()
      break
    default:
      // Only digits trigger edit mode with that character
      if (/^[0-9]$/.test(e.key) && !e.ctrlKey && !e.metaKey && !e.altKey) {
        e.preventDefault()
        setEditValue(e.key)
        onStartEdit()
      }
      // All other keys bubble to grid for navigation
  }
}
```

### Fix 2: Cursor Position at End
```typescript
// Source: React controlled input patterns
useEffect(() => {
  if (isEditing && inputRef.current) {
    const input = inputRef.current
    input.focus()
    // Use RAF to ensure DOM is ready
    requestAnimationFrame(() => {
      const len = input.value.length
      input.setSelectionRange(len, len)
    })
  }
}, [isEditing])
```

### Fix 3: Zustand Store Add Week Action
```typescript
// Source: Zustand documentation patterns
addWeek: (name?: string) =>
  set((state) => {
    if (!state.data) return state

    const weekCount = state.data.columns.filter(c => c.type === 'week').length
    const tempId = `temp-week-${Date.now()}`
    const weekName = name ?? `Semana ${weekCount + 1}`

    const newColumn: GridColumn = {
      id: tempId,
      type: 'week',
      weekId: tempId,
      name: weekName,
    }

    // Add empty prescription slot to all exercise rows
    const updatedRows = state.data.rows.map(row => {
      if (row.type === 'exercise') {
        return {
          ...row,
          prescriptions: { ...row.prescriptions, [tempId]: '' }
        }
      }
      return row
    })

    return {
      data: {
        ...state.data,
        columns: [...state.data.columns, newColumn],
        rows: updatedRows,
      },
      isDirty: true,
      pendingAddWeeks: [...(state.pendingAddWeeks ?? []), { tempId, name: weekName }],
    }
  }),
```

### Fix 4: Session Count in Create Program Form
```typescript
// Source: Project patterns
// Add to ProgramForm after weeksCount field
<Field>
  <FieldLabel htmlFor="sessionsCount">Sesiones iniciales</FieldLabel>
  <FieldContent>
    <Input
      id="sessionsCount"
      type="number"
      min={1}
      max={7}
      {...register('sessionsCount', { valueAsNumber: true })}
    />
    <FieldDescription>Cantidad de sesiones (dias de entrenamiento) por semana (1-7). Por defecto: 3</FieldDescription>
    <FieldError errors={[errors.sessionsCount]} />
  </FieldContent>
</Field>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Server mutation per change | Client-side state with bulk save | Phase 3.2 (partial) | Better UX, fewer API calls |
| `select()` for focus | `setSelectionRange()` for cursor | Standard practice | Precise cursor control |
| Any key starts edit | Specific keys only | Excel convention | Matches user expectations |

**Deprecated/outdated:**
- Using individual mutation hooks for grid changes during editing (legacy pattern, being replaced)

## Open Questions

Things that need resolution during implementation:

1. **Superset Menu Data Flow**
   - What we know: Menu logic is correct (per debug file), data may not be reaching it
   - What's unclear: Exactly where supersetGroup data is lost in prop chain
   - Recommendation: Add console.log at each step to trace data flow, fix where it breaks

2. **Backend saveDraft Extension**
   - What we know: Current saveDraft handles prescriptions and exerciseRows
   - What's unclear: Does backend need extension to handle weeks/sessions/exercises?
   - Recommendation: Check if backend procedure needs new fields, or if structural changes use different endpoints

3. **Conflict Resolution on Save**
   - What we know: saveDraft has lastLoadedAt for conflict detection
   - What's unclear: How to handle conflicts when structural changes (new rows) have temp IDs
   - Recommendation: Backend should return mapping of tempId -> realId after save

## Sources

### Primary (HIGH confidence)
- Existing codebase: grid-store.ts, prescription-cell.tsx, use-cell-editing.ts
- Debug files: superset-functionality-issues.md, superset-row-positioning.md
- Project CLAUDE.md documentation

### Secondary (MEDIUM confidence)
- [Zustand GitHub](https://github.com/pmndrs/zustand) - State management patterns
- [React controlled input cursor issues](https://github.com/facebook/react/issues/955) - setSelectionRange patterns
- [React-datasheet](https://github.com/nadbm/react-datasheet) - Excel-like keyboard navigation patterns

### Tertiary (LOW confidence)
- Web search results for "react excel spreadsheet keyboard navigation 2026" - general patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Already in place, just extending
- Architecture: HIGH - Clear patterns from existing codebase
- Pitfalls: HIGH - Root causes identified in debug files
- Code examples: HIGH - Based on verified patterns and existing code

**Research date:** 2026-01-26
**Valid until:** 60 days (stable codebase, patterns well-established)
