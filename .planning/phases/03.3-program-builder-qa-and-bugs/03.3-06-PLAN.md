---
phase: 03.3-program-builder-qa-and-bugs
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/coach-web/src/components/programs/program-grid/use-cell-editing.ts
  - apps/coach-web/src/stores/grid-store.ts
  - apps/coach-web/src/components/programs/program-grid/transform-program.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After boundary navigation, internal focus state matches visual indicator so Enter triggers edit on the NEW focused cell"
    - "Exercise rows show correct group letter (A/B/C based on group index) and position number (1/2/3 based on position in group)"
  artifacts:
    - path: "apps/coach-web/src/components/programs/program-grid/use-cell-editing.ts"
      provides: "Cell editing hook without focus restoration interference"
      contains: "stopEditing"
    - path: "apps/coach-web/src/stores/grid-store.ts"
      provides: "Store actions that recalculate group labels after changes"
      exports: ["useGridStore", "useGridActions"]
    - path: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      provides: "Exported function for recalculating group letters/indices"
      exports: ["recalculateSessionGroups"]
  key_links:
    - from: "apps/coach-web/src/stores/grid-store.ts"
      to: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      via: "import recalculateSessionGroups"
      pattern: "recalculateSessionGroups"
---

<objective>
Fix two UAT-diagnosed bugs in the program builder grid:

1. **Focus state sync (Test 5):** After boundary navigation (cursor at end + right arrow), the UI shows the new cell focused but Enter triggers edit mode on the OLD cell. Root cause: `stopEditing` unconditionally restores DOM focus to the last edited cell, overwriting navigation state.

2. **Superset labeling (Test 7):** All exercises show "A1" regardless of their actual group. Root cause: `updateSupersetGroup` and `addExercise` in grid-store.ts don't recalculate `groupIndex` for all session rows after changes.

Purpose: Complete UAT pass for Phase 3.3
Output: Both issues fixed, keyboard navigation and superset groups work correctly
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.3-program-builder-qa-and-bugs/03.3-UAT.md

# Relevant source files
@apps/coach-web/src/components/programs/program-grid/use-cell-editing.ts
@apps/coach-web/src/stores/grid-store.ts
@apps/coach-web/src/components/programs/program-grid/transform-program.ts
@apps/coach-web/src/components/programs/program-grid/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove focus restoration from stopEditing</name>
  <files>apps/coach-web/src/components/programs/program-grid/use-cell-editing.ts</files>
  <action>
Remove the focus restoration logic from `stopEditing` (lines 49-55). This code overwrites navigation that occurred during edit-commit-navigate sequence.

**Current problematic code:**
```typescript
const stopEditing = useCallback(() => {
  const lastCell = lastEditedCellRef.current
  setEditingCell(null)
  onEditStop?.()
  // THIS BLOCK CAUSES THE BUG - REMOVE IT
  if (lastCell && focusCell) {
    requestAnimationFrame(() => {
      focusCell(lastCell.rowId, lastCell.colId)
    })
  }
}, [onEditStop, focusCell])
```

**After fix:**
```typescript
const stopEditing = useCallback(() => {
  setEditingCell(null)
  onEditStop?.()
  // Focus restoration removed - useGridNavigation already syncs DOM focus to activeCell state
  // Navigation keys in prescription-cell.tsx update activeCell before calling stopEditing
}, [onEditStop])
```

Also:
- Remove `focusCell` from the options interface (no longer needed)
- Remove `lastEditedCellRef` if it's only used for focus restoration (check if startEditing still needs it)
- Clean up any unused imports

**Why this fixes Test 5:**
- When user presses Right at cursor boundary, prescription-cell.tsx updates activeCell via navigation callback THEN calls stopEditing
- Current stopEditing overwrites this by restoring focus to OLD cell
- After removal, activeCell remains pointing to the NEW cell, so Enter works correctly
  </action>
  <verify>
1. Build passes: `pnpm --filter @strenly/coach-web build`
2. Typecheck passes: `pnpm typecheck`
3. Manual test: Edit a cell, press Right at cursor end boundary, confirm new cell is visually focused, press Enter - should enter edit mode on NEW cell (not old one)
  </verify>
  <done>Focus state syncs correctly after boundary navigation - pressing Enter on newly focused cell enters edit mode on that cell, not the previous one</done>
</task>

<task type="auto">
  <name>Task 2: Extract group recalculation and wire to store actions</name>
  <files>
    apps/coach-web/src/components/programs/program-grid/transform-program.ts
    apps/coach-web/src/stores/grid-store.ts
  </files>
  <action>
**Part A: Extract recalculateSessionGroups from transform-program.ts**

Extract the group calculation logic (lines 135-183 in transform-program.ts) into a reusable function that operates on GridRow[]:

```typescript
/**
 * Recalculate groupLetter and groupIndex for all exercise rows in a session.
 *
 * Rules:
 * - Letter (A, B, C...) assigned sequentially as groups are encountered
 * - Index (1, 2, 3...) is position within that group
 * - Rows without supersetGroup get their own letter with index 1
 * - Rows sharing supersetGroup share a letter, indices increment
 *
 * @param sessionRows - Exercise rows belonging to a single session (ordered)
 * @returns Updated rows with groupLetter and groupIndex set
 */
export function recalculateSessionGroups(sessionRows: GridRow[]): GridRow[] {
  const LETTER_A_CODE = 65
  let letterIndex = 0
  const groupLetters = new Map<string, string>()
  const groupCounters = new Map<string, number>()

  return sessionRows.map((row) => {
    if (row.type !== 'exercise') return row

    if (row.supersetGroup) {
      // Named group (superset) - share letter, increment counter
      let letter = groupLetters.get(row.supersetGroup)
      if (!letter) {
        letter = String.fromCharCode(LETTER_A_CODE + letterIndex)
        groupLetters.set(row.supersetGroup, letter)
        groupCounters.set(row.supersetGroup, 0)
        letterIndex++
      }
      const counter = (groupCounters.get(row.supersetGroup) ?? 0) + 1
      groupCounters.set(row.supersetGroup, counter)

      return { ...row, groupLetter: letter, groupIndex: counter }
    } else {
      // Standalone exercise = implicit group of 1
      const letter = String.fromCharCode(LETTER_A_CODE + letterIndex)
      letterIndex++
      return { ...row, groupLetter: letter, groupIndex: 1 }
    }
  })
}
```

Update `transformProgramToGrid` to use this extracted function instead of inline logic.

**Part B: Wire recalculation into grid-store.ts actions**

Import the new function:
```typescript
import { recalculateSessionGroups } from '@/components/programs/program-grid/transform-program'
```

Update `updateSupersetGroup` to recalculate ALL rows in the affected session:
```typescript
updateSupersetGroup: (rowId, groupLetter) =>
  set((state) => {
    if (!state.data) return state

    // Find the row to get its sessionId
    const targetRow = state.data.rows.find(
      (row) => row.type === 'exercise' && row.id === rowId
    )
    if (!targetRow) return state
    const sessionId = targetRow.sessionId

    // First, update the target row's supersetGroup
    let updatedRows = state.data.rows.map((row) => {
      if (row.type === 'exercise' && row.id === rowId) {
        return {
          ...row,
          supersetGroup: groupLetter,
        }
      }
      return row
    })

    // Get all exercise rows for this session (in order)
    const sessionExerciseRows = updatedRows.filter(
      (row) => row.type === 'exercise' && row.sessionId === sessionId
    )

    // Recalculate group labels for entire session
    const recalculatedRows = recalculateSessionGroups(sessionExerciseRows)

    // Create a map for quick lookup
    const recalculatedMap = new Map(
      recalculatedRows.map((row) => [row.id, row])
    )

    // Merge recalculated rows back
    updatedRows = updatedRows.map((row) => {
      const recalculated = recalculatedMap.get(row.id)
      return recalculated ?? row
    })

    return {
      data: { ...state.data, rows: updatedRows },
      isDirty: true,
    }
  }),
```

Update `addExercise` similarly - after inserting the new row, recalculate groups for that session:
```typescript
addExercise: (sessionId, exerciseId, exerciseName) =>
  set((state) => {
    if (!state.data) return state

    // ... existing row creation code (keep as-is until the splice) ...

    const updatedRows = [...state.data.rows]
    if (insertIndex >= 0) {
      updatedRows.splice(insertIndex, 0, newRow)
    } else {
      updatedRows.push(newRow)
    }

    // Recalculate groups for this session
    const sessionExerciseRows = updatedRows.filter(
      (row) => row.type === 'exercise' && row.sessionId === sessionId
    )
    const recalculatedRows = recalculateSessionGroups(sessionExerciseRows)
    const recalculatedMap = new Map(
      recalculatedRows.map((row) => [row.id, row])
    )

    const finalRows = updatedRows.map((row) => {
      const recalculated = recalculatedMap.get(row.id)
      return recalculated ?? row
    })

    return {
      data: { ...state.data, rows: finalRows },
      isDirty: true,
    }
  }),
```

**Why this fixes Test 7:**
- Currently, updateSupersetGroup only updates the target row's supersetGroup/groupLetter but never recalculates groupIndex
- New exercises via addExercise are created with undefined groupLetter/groupIndex
- exercise-row-prefix.tsx defaults to 'A' and 1 when undefined, causing all rows to show A1
- After fix, every mutation that affects groups triggers full session recalculation
  </action>
  <verify>
1. Typecheck passes: `pnpm typecheck`
2. Lint passes: `pnpm lint`
3. Build passes: `pnpm --filter @strenly/coach-web build`
4. Manual test superset creation:
   - Open a program with multiple exercises in a session
   - Open row actions menu, create new superset group
   - Verify: Rows show correct letters (A, B, C) based on group
   - Verify: Positions within group are numbered correctly (A1, A2, B1, etc.)
5. Manual test add exercise:
   - Click "+ Agregar ejercicio", select an exercise
   - Verify: New row shows next sequential letter (e.g., if A, B exist, new row is C1)
  </verify>
  <done>Exercise rows display correct group letters (A/B/C) and position numbers (1/2/3) after superset changes and exercise additions</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Build and lint:**
   ```bash
   pnpm typecheck && pnpm lint && pnpm --filter @strenly/coach-web build
   ```

2. **Focus state test (Test 5):**
   - Navigate to program grid
   - Click on a prescription cell with content
   - Press Enter to edit
   - Type some digits, cursor is at end
   - Press Right arrow
   - Confirm: Cell focus visually moves to next cell
   - Press Enter
   - Confirm: Edit mode starts on the NEW cell (not the old one)

3. **Superset labeling test (Test 7):**
   - Open a program with 3+ exercises in a session
   - All should show sequential letters (A1, B1, C1)
   - Open row actions on exercise B1, create superset "B"
   - Open row actions on exercise C1, join superset "B"
   - Confirm: Labels now show A1, B1, B2 (B group has 2 members)
   - Add new exercise
   - Confirm: New row shows C1 (next available letter)
</verification>

<success_criteria>
- [ ] Focus state syncs correctly after boundary navigation (Test 5 passes)
- [ ] Exercise rows show correct group letters and positions (Test 7 passes)
- [ ] Build passes with no TypeScript errors
- [ ] Lint passes with no Biome errors
</success_criteria>

<output>
After completion, create `.planning/phases/03.3-program-builder-qa-and-bugs/03.3-06-SUMMARY.md`
</output>
