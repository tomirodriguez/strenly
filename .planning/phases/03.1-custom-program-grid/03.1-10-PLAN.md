---
phase: 03.1-custom-program-grid
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/coach-web/src/components/programs/exercise-row-actions.tsx
  - packages/backend/src/use-cases/programs/toggle-superset.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Superset dropdown shows only available groups based on existing exercises"
    - "Adding exercise to existing superset group combines with existing exercises"
    - "Superset order is calculated as max(existing order) + 1"
  artifacts:
    - path: "apps/coach-web/src/components/programs/exercise-row-actions.tsx"
      provides: "Dynamic superset groups based on session exercises"
      contains: "existingSupersets"
    - path: "packages/backend/src/use-cases/programs/toggle-superset.ts"
      provides: "Calculate supersetOrder from existing group members"
      contains: "maxSupersetOrder"
  key_links:
    - from: "exercise-row-actions.tsx"
      to: "session rows"
      via: "derive available groups from props"
      pattern: "sessionRows.*supersetGroup"
    - from: "toggle-superset.ts"
      to: "programRepository"
      via: "query existing rows with same supersetGroup"
      pattern: "findExerciseRowsBySession"
---

<objective>
Fix superset grouping to show dynamic groups and calculate proper order when adding to existing groups.

Purpose: UAT Test 8 failed because:
1. Frontend shows hardcoded groups (A, B, C, D, E) instead of dynamic based on current exercises
2. Backend sets supersetOrder: 1 always, ignoring existing rows in the group

Output: Superset system that shows relevant groups and properly combines exercises in the same group.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-custom-program-grid/03.1-UAT.md (gap diagnosis)
@apps/coach-web/src/components/programs/exercise-row-actions.tsx
@packages/backend/src/use-cases/programs/toggle-superset.ts
@packages/backend/src/infrastructure/repositories/program.repository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update exercise-row-actions.tsx for dynamic superset groups</name>
  <files>apps/coach-web/src/components/programs/exercise-row-actions.tsx</files>
  <action>
    Replace the hardcoded `SUPERSET_GROUPS = ['A', 'B', 'C', 'D', 'E']` with dynamic groups derived from session data.

    **Current problematic code (line 48):**
    ```typescript
    const SUPERSET_GROUPS = ['A', 'B', 'C', 'D', 'E']
    ```

    **Changes needed:**

    1. **Update props to receive session rows data:**
       Add a prop for all rows in the session (not just row IDs):
       ```typescript
       interface ExerciseRowActionsProps {
         programId: string
         sessionId: string
         rowId: string
         exerciseName: string
         supersetGroup: string | null
         isSubRow?: boolean
         sessionRowIds: string[]
         /** All exercise rows in this session for deriving superset groups */
         sessionRows: Array<{ id: string; supersetGroup: string | null }>
         onAddSplitRow?: () => void
         onClose?: () => void
       }
       ```

    2. **Derive dynamic superset groups:**
       ```typescript
       // Get existing superset groups in this session
       const existingSupersets = useMemo(() => {
         const groups = new Set<string>()
         for (const row of sessionRows) {
           if (row.supersetGroup) {
             groups.add(row.supersetGroup)
           }
         }
         return Array.from(groups).sort()
       }, [sessionRows])

       // Calculate next available letter (for "Create new group" option)
       const nextAvailableLetter = useMemo(() => {
         const usedLetters = new Set(existingSupersets)
         for (const letter of 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') {
           if (!usedLetters.has(letter)) {
             return letter
           }
         }
         return null // All letters used (unlikely)
       }, [existingSupersets])
       ```

    3. **Update the dropdown menu:**
       Replace the static SUPERSET_GROUPS.map with dynamic options:

       ```tsx
       {/* Superset options */}
       {supersetGroup ? (
         <>
           <DropdownMenuItem onClick={() => handleSetSupersetGroup(null)}>
             <Link2OffIcon className="size-4" />
             Quitar de superserie
           </DropdownMenuItem>
           {/* Option to move to different existing group */}
           {existingSupersets
             .filter((g) => g !== supersetGroup)
             .map((group) => (
               <DropdownMenuItem key={group} onClick={() => handleSetSupersetGroup(group)}>
                 <Link2Icon className="size-4" />
                 Mover a grupo {group}
               </DropdownMenuItem>
             ))}
         </>
       ) : (
         <>
           {/* Add to existing groups */}
           {existingSupersets.map((group) => (
             <DropdownMenuItem key={group} onClick={() => handleSetSupersetGroup(group)}>
               <Link2Icon className="size-4" />
               Agregar a superserie {group}
             </DropdownMenuItem>
           ))}
           {/* Create new group option */}
           {nextAvailableLetter && (
             <DropdownMenuItem onClick={() => handleSetSupersetGroup(nextAvailableLetter)}>
               <Link2Icon className="size-4" />
               Crear superserie {nextAvailableLetter}
             </DropdownMenuItem>
           )}
         </>
       )}
       ```

    4. **Remove the hardcoded constant:**
       Delete `const SUPERSET_GROUPS = ['A', 'B', 'C', 'D', 'E']`
  </action>
  <verify>
    TypeScript compiles:
    ```bash
    pnpm --filter coach-web typecheck
    ```
  </verify>
  <done>
    - Superset dropdown shows existing groups from session
    - "Create new group" option shows next available letter
    - No more hardcoded A, B, C, D, E list
  </done>
</task>

<task type="auto">
  <name>Task 2: Update callers to pass sessionRows prop</name>
  <files>
    apps/coach-web/src/components/programs/program-grid/exercise-cell.tsx
    apps/coach-web/src/components/programs/program-grid/exercise-row.tsx
    apps/coach-web/src/components/programs/program-grid/grid-body.tsx
  </files>
  <action>
    Update the component tree to pass sessionRows down to ExerciseRowActions.

    **In grid-body.tsx:**
    The rows are already available. Group them by session and pass to ExerciseRow:

    ```typescript
    // Group rows by sessionId
    const rowsBySession = useMemo(() => {
      const grouped = new Map<string, Array<{ id: string; supersetGroup: string | null }>>()
      for (const row of rows) {
        if (row.type === 'exercise') {
          const existing = grouped.get(row.sessionId) ?? []
          existing.push({ id: row.id, supersetGroup: row.supersetGroup })
          grouped.set(row.sessionId, existing)
        }
      }
      return grouped
    }, [rows])
    ```

    Pass to ExerciseRow:
    ```tsx
    <ExerciseRow
      ...
      sessionRows={rowsBySession.get(row.sessionId) ?? []}
    />
    ```

    **In exercise-row.tsx:**
    Accept sessionRows prop and pass to ExerciseCell:
    ```typescript
    interface ExerciseRowProps {
      // ... existing props
      sessionRows: Array<{ id: string; supersetGroup: string | null }>
    }
    ```

    Pass to ExerciseCell:
    ```tsx
    <ExerciseCell
      ...
      sessionRows={sessionRows}
    />
    ```

    **In exercise-cell.tsx:**
    Accept sessionRows prop and pass to ExerciseRowActions:
    ```typescript
    interface ExerciseCellProps {
      // ... existing props
      sessionRows: Array<{ id: string; supersetGroup: string | null }>
    }
    ```

    Pass to ExerciseRowActions:
    ```tsx
    <ExerciseRowActions
      ...
      sessionRows={sessionRows}
    />
    ```
  </action>
  <verify>
    TypeScript compiles:
    ```bash
    pnpm --filter coach-web typecheck
    ```
  </verify>
  <done>
    sessionRows prop flows from grid-body through exercise-row to exercise-cell to exercise-row-actions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix toggle-superset.ts to calculate proper supersetOrder</name>
  <files>packages/backend/src/use-cases/programs/toggle-superset.ts</files>
  <action>
    Fix the supersetOrder calculation at lines 98-99 where it's hardcoded to 1.

    **Current problematic code:**
    ```typescript
    const newSupersetOrder =
      existing.supersetGroup === input.supersetGroup && existing.supersetOrder !== null
        ? existing.supersetOrder
        : 1  // BUG: Always 1 for new entries
    ```

    **Fix: Query existing rows with same supersetGroup to find max order**

    The challenge is we need to find other rows in the same session with the same supersetGroup. We need to:
    1. Get the sessionId from the existing row
    2. Query all rows in that session with the target supersetGroup
    3. Find max supersetOrder
    4. Set new row's order to max + 1

    **Option 1: Add a method to repository to get max superset order**
    Add `getMaxSupersetOrder(ctx, sessionId, supersetGroup): ResultAsync<number, Error>`

    **Option 2: Get all rows in session and calculate in use case**
    More queries but simpler port interface.

    Let's go with Option 1 for cleaner code.

    **Step 1: Add to ProgramRepositoryPort (packages/core/src/ports/program-repository.port.ts):**
    ```typescript
    getMaxSupersetOrder(
      ctx: OrganizationContext,
      sessionId: string,
      supersetGroup: string
    ): ResultAsync<number | null, ProgramRepositoryError>
    ```

    **Step 2: Implement in program.repository.ts:**
    ```typescript
    getMaxSupersetOrder(
      ctx: OrganizationContext,
      sessionId: string,
      supersetGroup: string
    ): ResultAsync<number | null, ProgramRepositoryError> {
      return RA.fromPromise(
        (async (): Promise<{ ok: true; data: number | null } | { ok: false; error: ProgramRepositoryError }> => {
          const existingSession = await verifySessionAccess(ctx, sessionId)
          if (!existingSession) {
            return { ok: false, error: notFoundError('session', sessionId) }
          }

          const result = await db
            .select({ maxOrder: sql<number | null>`MAX(${programExercises.supersetOrder})` })
            .from(programExercises)
            .where(
              and(
                eq(programExercises.sessionId, sessionId),
                eq(programExercises.supersetGroup, supersetGroup)
              )
            )

          return { ok: true, data: result[0]?.maxOrder ?? null }
        })(),
        wrapDbError,
      ).andThen((result) => {
        if (!result.ok) {
          return err(result.error)
        }
        return ok(result.data)
      })
    },
    ```

    **Step 3: Update toggle-superset.ts:**
    ```typescript
    export const makeToggleSuperset =
      (deps: Dependencies) =>
      (input: ToggleSupersetInput): ResultAsync<ProgramExerciseRow, ToggleSupersetError> => {
        // 1. Authorization FIRST
        if (!hasPermission(input.memberRole, 'programs:write')) {
          return errAsync({
            type: 'forbidden',
            message: 'No permission to modify programs',
          })
        }

        const ctx = { organizationId: input.organizationId, userId: input.userId, memberRole: input.memberRole }

        // 2. Fetch existing row
        return deps.programRepository
          .findExerciseRowById(ctx, input.rowId)
          .mapErr((e): ToggleSupersetError => {
            if (e.type === 'NOT_FOUND') {
              return { type: 'not_found', rowId: input.rowId }
            }
            return { type: 'repository_error', message: e.message }
          })
          .andThen((existing) => {
            // 3. If removing from superset
            if (input.supersetGroup === null) {
              const updated: ProgramExerciseRow = {
                ...existing,
                supersetGroup: null,
                supersetOrder: null,
                updatedAt: new Date(),
              }

              return deps.programRepository.updateExerciseRow(ctx, updated).mapErr(
                (e): ToggleSupersetError => ({
                  type: 'repository_error',
                  message: e.type === 'DATABASE_ERROR' ? e.message : `Entity not found: ${e.id}`,
                }),
              )
            }

            // 4. Adding to superset - calculate proper order
            // If row is already in this group with an order, keep it
            if (existing.supersetGroup === input.supersetGroup && existing.supersetOrder !== null) {
              // Already in this group, no change needed
              return deps.programRepository.updateExerciseRow(ctx, {
                ...existing,
                updatedAt: new Date(),
              }).mapErr(
                (e): ToggleSupersetError => ({
                  type: 'repository_error',
                  message: e.type === 'DATABASE_ERROR' ? e.message : `Entity not found: ${e.id}`,
                }),
              )
            }

            // 5. Get max order in target group and add 1
            return deps.programRepository
              .getMaxSupersetOrder(ctx, existing.sessionId, input.supersetGroup)
              .mapErr((e): ToggleSupersetError => ({
                type: 'repository_error',
                message: e.type === 'DATABASE_ERROR' ? e.message : 'Failed to get superset order',
              }))
              .andThen((maxOrder) => {
                const newOrder = (maxOrder ?? 0) + 1

                const updated: ProgramExerciseRow = {
                  ...existing,
                  supersetGroup: input.supersetGroup,
                  supersetOrder: newOrder,
                  updatedAt: new Date(),
                }

                return deps.programRepository.updateExerciseRow(ctx, updated).mapErr(
                  (e): ToggleSupersetError => ({
                    type: 'repository_error',
                    message: e.type === 'DATABASE_ERROR' ? e.message : `Entity not found: ${e.id}`,
                  }),
                )
              })
          })
      }
    ```
  </action>
  <verify>
    1. TypeScript compiles:
       ```bash
       pnpm typecheck
       ```
    2. Manual test:
       - Create program with 3 exercises (A1, B1, C1)
       - Add A1 to superset A (becomes A1)
       - Add B1 to superset A (should become A2, not A1)
       - Verify both show as superset A (A1 and A2)
  </verify>
  <done>
    - getMaxSupersetOrder added to port and repository
    - toggle-superset.ts calculates proper order when adding to existing group
    - Exercises combine correctly in superset groups
  </done>
</task>

</tasks>

<verification>
1. Open a program with 4 exercise rows
2. Click superset menu on row 1
3. Verify dropdown shows "Crear superserie A" (not A, B, C, D, E)
4. Add row 1 to superset A (becomes A1)
5. Click superset menu on row 2
6. Verify dropdown shows "Agregar a superserie A" and "Crear superserie B"
7. Add row 2 to superset A
8. Verify it becomes A2 (not A1)
9. Both rows should show blue superset indicator
</verification>

<success_criteria>
- Superset dropdown is dynamic based on existing groups
- Adding to existing group calculates next order (A1, A2, A3...)
- "Create new group" option shows next available letter
- Blue superset indicator connects exercises in same group
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-custom-program-grid/03.1-10-SUMMARY.md`
</output>
