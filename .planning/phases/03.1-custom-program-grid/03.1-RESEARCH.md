# Phase 3.1: Custom Program Grid - Research

**Researched:** 2026-01-25
**Domain:** Custom HTML table grid, keyboard navigation, inline editing, design system integration
**Confidence:** HIGH

## Summary

This phase requires replacing the react-datasheet-grid library with a custom HTML table implementation that matches our design system. The UAT revealed that react-datasheet-grid looks like "plain Excel pasted in" and doesn't integrate with our dark slate theme, blue accents, and shadcn/ui components.

The research reveals that building a custom grid is achievable using native HTML `<table>` elements with CSS `position: sticky` for the exercise column, and a roving tabindex pattern for keyboard navigation. The existing mutation hooks (`use-grid-mutations.ts`) are well-designed and should remain unchanged - only the presentation layer needs replacement.

Key technical challenges:
1. **Keyboard navigation**: Arrow keys, Tab, Enter, Escape with roving tabindex
2. **Sticky first column**: CSS `position: sticky` with proper z-index layering
3. **Inline cell editing**: Click-to-edit with our Input component
4. **Exercise combobox**: Integrate existing Combobox component for exercise search
5. **Session headers**: Full-width rows separating training days
6. **Superset visual indicators**: Vertical blue lines connecting grouped exercises

**Primary recommendation:** Build a custom `<ProgramGrid>` component using native HTML table, shadcn/ui primitives (Input, Combobox, DropdownMenu), and a useGridNavigation hook for keyboard handling. Do NOT use any external grid library.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Native HTML `<table>` | N/A | Grid structure | Full control over styling, no library conflicts |
| React 19 | 19.x | Component framework | Already in project, hooks for state management |
| Tailwind CSS | (catalog) | Styling | Already in project, matches design tokens |
| shadcn/ui components | Local | UI primitives | Already in project: Input, Combobox, DropdownMenu |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @tanstack/react-query | 5.x | Data fetching/caching | Already used by mutation hooks |
| lucide-react | (catalog) | Icons | Already in project |
| clsx/cn | (catalog) | Class merging | Already in project |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom HTML table | TanStack Table | TanStack Table is headless but adds complexity; we need visual control |
| Custom HTML table | react-datasheet-grid | UAT showed it doesn't match design system (blocker) |
| Custom keyboard nav | @tanstack/react-virtual | Only needed for 100+ rows; our grids are small |
| Custom combobox | cmdk | Our Combobox component already works well |

**Installation:**
```bash
# No new packages needed - using existing dependencies
```

## Architecture Patterns

### Recommended Project Structure
```
apps/coach-web/src/
  components/programs/
    program-grid/
      program-grid.tsx           # Main grid container
      grid-header.tsx            # Sticky header row with week columns
      grid-body.tsx              # Session groups with exercise rows
      session-header-row.tsx     # "DIA 1 - SQUAT DOMINANT" divider
      exercise-row.tsx           # Single exercise row with prescriptions
      exercise-cell.tsx          # Exercise name cell with combobox
      prescription-cell.tsx      # Editable prescription cell
      superset-indicator.tsx     # Vertical line for grouped exercises
    week-actions-menu.tsx        # Existing - keep unchanged
    split-row-dialog.tsx         # Existing - keep unchanged
    exercise-row-actions.tsx     # Existing - keep unchanged
  hooks/
    use-grid-navigation.ts       # Keyboard navigation hook (new)
    use-cell-editing.ts          # Click-to-edit state management (new)
```

### Pattern 1: Roving Tabindex for Grid Navigation
**What:** Single focusable cell at a time, arrow keys move focus between cells
**When to use:** For accessible keyboard navigation per W3C ARIA Grid pattern
**Why:** W3C recommends only one focusable element in tab sequence for composite widgets

```typescript
// Source: W3C WAI-ARIA Authoring Practices Guide
// https://www.w3.org/WAI/ARIA/apg/patterns/grid/

interface GridCell {
  rowIndex: number
  colIndex: number
  rowId: string
  colId: string
}

function useGridNavigation(
  rows: GridRow[],
  columns: Column[],
  onCellChange: (cell: GridCell | null) => void
) {
  const [activeCell, setActiveCell] = useState<GridCell | null>(null)

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (!activeCell) return

    const { rowIndex, colIndex } = activeCell
    let nextRow = rowIndex
    let nextCol = colIndex

    switch (e.key) {
      case 'ArrowUp':
        nextRow = Math.max(0, rowIndex - 1)
        // Skip session header rows
        while (nextRow > 0 && rows[nextRow].type === 'session-header') {
          nextRow--
        }
        e.preventDefault()
        break
      case 'ArrowDown':
        nextRow = Math.min(rows.length - 1, rowIndex + 1)
        while (nextRow < rows.length - 1 && rows[nextRow].type === 'session-header') {
          nextRow++
        }
        e.preventDefault()
        break
      case 'ArrowLeft':
        nextCol = Math.max(0, colIndex - 1)
        e.preventDefault()
        break
      case 'ArrowRight':
        nextCol = Math.min(columns.length - 1, colIndex + 1)
        e.preventDefault()
        break
      case 'Tab':
        // Move to next cell, wrap to next row
        if (e.shiftKey) {
          nextCol--
          if (nextCol < 0) {
            nextCol = columns.length - 1
            nextRow--
          }
        } else {
          nextCol++
          if (nextCol >= columns.length) {
            nextCol = 0
            nextRow++
          }
        }
        e.preventDefault()
        break
      case 'Enter':
        // Enter edit mode (handled by cell component)
        break
      case 'Escape':
        // Exit edit mode, keep focus
        break
    }

    if (nextRow !== rowIndex || nextCol !== colIndex) {
      const newCell: GridCell = {
        rowIndex: nextRow,
        colIndex: nextCol,
        rowId: rows[nextRow].id,
        colId: columns[nextCol].id,
      }
      setActiveCell(newCell)
      onCellChange(newCell)
    }
  }, [activeCell, rows, columns, onCellChange])

  return { activeCell, setActiveCell, handleKeyDown }
}
```

### Pattern 2: CSS Sticky Column
**What:** First column (exercise names) stays visible during horizontal scroll
**When to use:** When grid has many week columns
**Why:** Essential for programs with 4-10 weeks that extend beyond viewport

```css
/* Source: CSS-Tricks sticky columns guide */
/* https://css-tricks.com/a-table-with-both-a-sticky-header-and-a-sticky-first-column/ */

.program-grid-container {
  overflow-x: auto;
  overflow-y: visible;
}

.program-grid {
  border-collapse: separate;
  border-spacing: 0;
  min-width: 100%;
}

/* Sticky header row */
.program-grid thead th {
  position: sticky;
  top: 0;
  z-index: 20;
  background: hsl(var(--background));
}

/* Sticky first column (exercise names) */
.program-grid tbody td:first-child,
.program-grid thead th:first-child {
  position: sticky;
  left: 0;
  z-index: 10;
  background: hsl(var(--background));
  /* Shadow to indicate scrolling */
  box-shadow: 2px 0 5px -2px rgba(0, 0, 0, 0.3);
}

/* Corner cell (header + first column) needs highest z-index */
.program-grid thead th:first-child {
  z-index: 30;
}

/* Session header rows span full width */
.program-grid tr.session-header td {
  position: relative;
  z-index: 5;
}
```

### Pattern 3: Click-to-Edit Cell
**What:** Single click activates edit mode with input, blur/enter commits
**When to use:** For all editable prescription cells
**Why:** Excel-like inline editing per PRG-03 requirement

```typescript
// Source: Custom implementation based on Excel UX patterns

interface EditableCellProps {
  value: string
  isActive: boolean
  isEditing: boolean
  onStartEdit: () => void
  onCommit: (value: string) => void
  onCancel: () => void
}

function PrescriptionCell({
  value,
  isActive,
  isEditing,
  onStartEdit,
  onCommit,
  onCancel,
}: EditableCellProps) {
  const [editValue, setEditValue] = useState(value)
  const inputRef = useRef<HTMLInputElement>(null)

  // Focus input when entering edit mode
  useEffect(() => {
    if (isEditing) {
      inputRef.current?.focus()
      inputRef.current?.select()
    }
  }, [isEditing])

  // Reset edit value when cell becomes active (not editing)
  useEffect(() => {
    if (isActive && !isEditing) {
      setEditValue(value)
    }
  }, [isActive, isEditing, value])

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      onCommit(editValue)
    } else if (e.key === 'Escape') {
      setEditValue(value)
      onCancel()
    } else if (e.key === 'Tab') {
      onCommit(editValue)
      // Let parent handle Tab navigation
    }
  }

  if (isEditing) {
    return (
      <Input
        ref={inputRef}
        value={editValue}
        onChange={(e) => setEditValue(e.target.value)}
        onBlur={() => onCommit(editValue)}
        onKeyDown={handleKeyDown}
        className="h-full w-full border-none bg-transparent text-center focus-visible:ring-1 focus-visible:ring-primary"
        placeholder="3x8@RIR2"
      />
    )
  }

  return (
    <div
      onClick={onStartEdit}
      onDoubleClick={onStartEdit}
      className={cn(
        "flex h-full w-full cursor-text items-center justify-center px-2 text-sm",
        isActive && "bg-primary/5 ring-1 ring-inset ring-primary"
      )}
      tabIndex={isActive ? 0 : -1}
    >
      {value || 'â€”'}
    </div>
  )
}
```

### Pattern 4: Superset Visual Indicator
**What:** Vertical blue line connecting exercises in same superset group
**When to use:** For B1/B2/B3 grouped exercises
**Why:** Visual indicator per UI/UX specification

```typescript
// Source: UI/UX specification code.html

function SupersetIndicator({ position }: { position: 'start' | 'middle' | 'end' }) {
  const lineClass = cn(
    "absolute left-[15px] w-[1.5px] bg-primary/40 z-20",
    position === 'start' && "top-1/2 bottom-[-50%]",
    position === 'middle' && "top-[-50%] bottom-[-50%]",
    position === 'end' && "top-[-50%] bottom-1/2"
  )

  return <div className={lineClass} />
}

function ExerciseRowPrefix({ row }: { row: GridRow }) {
  const prefix = row.supersetGroup
    ? `${row.supersetGroup}${row.supersetOrder ?? ''}`
    : null

  const prefixClass = cn(
    "w-10 flex justify-center text-[10px] font-bold border-r border-border h-full items-center",
    row.supersetGroup ? "text-primary bg-background" : "text-muted-foreground bg-muted/20"
  )

  return (
    <div className="relative flex items-center h-full">
      {row.supersetGroup && (
        <SupersetIndicator position={getSupersetPosition(row)} />
      )}
      <span className={prefixClass}>{prefix || row.orderLabel}</span>
    </div>
  )
}
```

### Anti-Patterns to Avoid
- **Using tabIndex on every cell**: Use roving tabindex (only active cell has tabIndex=0)
- **Re-rendering entire grid on cell change**: Memoize rows and cells
- **Mixing controlled/uncontrolled inputs**: Commit on blur, not on every keystroke
- **Absolute positioning for sticky columns**: Use CSS `position: sticky`
- **Building own combobox**: Use existing shadcn/ui Combobox component
- **Storing display value as source of truth**: Parse notation on commit, display formatted

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Exercise search dropdown | Custom autocomplete | shadcn/ui Combobox | Already handles keyboard nav, filtering, async loading |
| Week actions menu | Custom popover | shadcn/ui DropdownMenu | Already in WeekActionsMenu, handles positioning |
| Delete confirmation | Custom modal | shadcn/ui AlertDialog | Already in existing code |
| Form validation | Manual checks | Zod schemas from contracts | Already exists: parsePrescriptionNotation |
| Cell value formatting | Custom formatter | formatPrescription from contracts | Already handles all notation patterns |
| Cache invalidation | Manual refetch | TanStack Query + mutation hooks | use-grid-mutations.ts already handles this |

**Key insight:** The existing mutation hooks in `use-grid-mutations.ts` are well-designed. The new grid only needs to call the same mutations - no backend changes required.

## Common Pitfalls

### Pitfall 1: Session Header Row Navigation
**What goes wrong:** Arrow keys try to focus session header rows
**Why it happens:** Session headers are table rows but not editable
**How to avoid:** Skip session-header type rows in navigation logic
**Warning signs:** Focus gets "stuck" or disappears when navigating past session boundaries

### Pitfall 2: Z-Index Layering for Sticky Elements
**What goes wrong:** Sticky column gets covered by cells during scroll, or header disappears
**Why it happens:** Incorrect z-index stacking order
**How to avoid:** Follow layering: body cells (1) < sticky column (10) < header (20) < corner cell (30)
**Warning signs:** Visual glitches during horizontal/vertical scroll

### Pitfall 3: Input Focus vs Grid Focus
**What goes wrong:** Tab key exits grid instead of moving to next cell
**Why it happens:** Input element captures Tab and browser handles it
**How to avoid:** Commit value on Tab, then prevent default and move focus in grid
**Warning signs:** Focus jumps to page navigation or other elements

### Pitfall 4: Exercise Combobox Inside Grid Cell
**What goes wrong:** Combobox dropdown gets clipped by table overflow
**Why it happens:** Table container has `overflow: auto` which clips positioned children
**How to avoid:** Use portal (ComboboxContent uses Portal by default)
**Warning signs:** Dropdown appears behind other cells or cut off

### Pitfall 5: Performance with Many Cells
**What goes wrong:** Grid becomes sluggish when typing in cells
**Why it happens:** Every keystroke re-renders the entire grid
**How to avoid:**
  - Memoize ExerciseRow components
  - Only re-render the cell being edited
  - Debounce mutation calls (mutation hooks already handle this)
**Warning signs:** Typing lag, scroll jank with 6+ weeks

### Pitfall 6: Lost Focus After Mutation
**What goes wrong:** After saving a cell, focus disappears from grid
**Why it happens:** React re-render resets DOM focus
**How to avoid:** Store active cell in state, restore focus after mutation settles
**Warning signs:** User must click back into grid after each edit

## Code Examples

### Grid Container Component
```typescript
// Source: Custom implementation for this project

interface ProgramGridProps {
  programId: string
}

export function ProgramGrid({ programId }: ProgramGridProps) {
  const { data: program, isLoading, error } = useProgram(programId)
  const gridRef = useRef<HTMLTableElement>(null)

  // Grid navigation state
  const [activeCell, setActiveCell] = useState<GridCell | null>(null)
  const [editingCell, setEditingCell] = useState<GridCell | null>(null)

  // Mutation hooks (existing)
  const updatePrescription = useUpdatePrescription(programId)
  const updateExerciseRow = useUpdateExerciseRow(programId)
  const toggleSuperset = useToggleSuperset(programId)

  // Transform data for grid display
  const { rows, columns } = useMemo(() => {
    if (!program) return { rows: [], columns: [] }
    return transformProgramToGrid(program)
  }, [program])

  // Keyboard navigation
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (!activeCell) return

    // Handle Shift+Enter for split row
    if (e.shiftKey && e.key === 'Enter') {
      e.preventDefault()
      handleAddSplitRow(activeCell.rowId)
      return
    }

    // Handle S for superset toggle (only when not editing)
    if (e.key === 's' && !editingCell && !e.metaKey && !e.ctrlKey) {
      e.preventDefault()
      const row = rows.find(r => r.id === activeCell.rowId)
      if (row && row.type === 'exercise') {
        toggleSuperset.mutate({
          rowId: activeCell.rowId,
          supersetGroup: row.supersetGroup ? null : 'A',
        })
      }
      return
    }

    // Navigation keys (handled by useGridNavigation hook)
    // ...
  }, [activeCell, editingCell, rows, toggleSuperset])

  if (isLoading) return <GridSkeleton />
  if (error) return <GridError message={error.message} />
  if (!program) return <GridError message="Programa no encontrado" />

  return (
    <div className="program-grid-container overflow-x-auto">
      <table
        ref={gridRef}
        className="program-grid w-full border-collapse border-spacing-0"
        role="grid"
        aria-label={`Programa: ${program.name}`}
        onKeyDown={handleKeyDown}
      >
        <GridHeader
          weeks={program.weeks}
          programId={programId}
          activeCell={activeCell}
          onCellClick={setActiveCell}
        />
        <GridBody
          rows={rows}
          columns={columns}
          activeCell={activeCell}
          editingCell={editingCell}
          onCellClick={setActiveCell}
          onStartEdit={setEditingCell}
          onCommit={handleCommit}
          onCancel={() => setEditingCell(null)}
        />
      </table>
    </div>
  )
}
```

### Grid Header with Week Actions
```typescript
// Source: Custom implementation, reusing existing WeekActionsMenu

interface GridHeaderProps {
  weeks: ProgramWeek[]
  programId: string
  activeCell: GridCell | null
  onCellClick: (cell: GridCell) => void
}

function GridHeader({ weeks, programId, activeCell, onCellClick }: GridHeaderProps) {
  const isLastWeek = weeks.length === 1

  return (
    <thead className="sticky top-0 z-40">
      <tr className="bg-zinc-900">
        {/* Exercise column header */}
        <th className="sticky left-0 z-30 w-[320px] border-r border-b-2 border-border bg-zinc-900 px-4 py-3">
          <span className="text-[10px] font-bold text-muted-foreground uppercase tracking-[0.2em]">
            Pairing / Exercise Selection
          </span>
        </th>

        {/* Week column headers */}
        {weeks.map((week) => (
          <th
            key={week.id}
            className="w-56 border-r border-b-2 border-border bg-zinc-900/50 px-4 py-3"
          >
            <div className="flex items-center justify-between">
              <span className="text-[10px] font-bold text-muted-foreground uppercase tracking-widest">
                {week.name}
              </span>
              <WeekActionsMenu
                programId={programId}
                weekId={week.id}
                weekName={week.name}
                isLastWeek={isLastWeek}
              />
            </div>
          </th>
        ))}
      </tr>
    </thead>
  )
}
```

### Session Header Row
```typescript
// Source: Based on UI/UX specification

interface SessionHeaderRowProps {
  session: ProgramSession
  colSpan: number
}

function SessionHeaderRow({ session, colSpan }: SessionHeaderRowProps) {
  return (
    <tr className="session-header bg-zinc-900/60 border-y border-border">
      <td
        colSpan={colSpan}
        className="px-4 py-2 text-[11px] font-black text-primary uppercase tracking-[0.15em]"
      >
        {session.name}
      </td>
    </tr>
  )
}
```

### Exercise Cell with Combobox
```typescript
// Source: Custom implementation using existing Combobox component

interface ExerciseCellProps {
  row: GridRow
  isActive: boolean
  isEditing: boolean
  onStartEdit: () => void
  onCommit: (exerciseId: string, exerciseName: string) => void
  onCancel: () => void
}

function ExerciseCell({
  row,
  isActive,
  isEditing,
  onStartEdit,
  onCommit,
  onCancel,
}: ExerciseCellProps) {
  const [searchValue, setSearchValue] = useState('')
  const { data: exercisesData } = useExercises({
    search: searchValue || undefined,
    limit: 10,
  })

  const exercises = exercisesData?.items ?? []

  if (!isEditing) {
    return (
      <td
        className={cn(
          "sticky left-0 z-10 border-r border-b border-border bg-background",
          isActive && "ring-1 ring-inset ring-primary"
        )}
        onClick={onStartEdit}
        tabIndex={isActive ? 0 : -1}
      >
        <div className="flex items-center h-full">
          <ExerciseRowPrefix row={row} />
          <div className="flex-1 flex items-center justify-between px-3">
            <span className={cn(
              "text-[13px] font-semibold",
              row.isSubRow && "text-muted-foreground"
            )}>
              {row.exercise.exerciseName || 'Seleccionar ejercicio'}
            </span>
            {row.setTypeLabel && (
              <span className="text-[9px] font-bold text-muted-foreground bg-muted/50 px-1.5 py-0.5 rounded uppercase">
                {row.setTypeLabel}
              </span>
            )}
          </div>
        </div>
      </td>
    )
  }

  // Edit mode with Combobox
  return (
    <td className="sticky left-0 z-10 border-r border-b border-border bg-background p-0">
      <Combobox
        value={row.exercise.exerciseId}
        onValueChange={(value) => {
          const exercise = exercises.find(e => e.id === value)
          if (exercise) {
            onCommit(exercise.id, exercise.name)
          }
        }}
      >
        <ComboboxInput
          placeholder="Buscar ejercicio..."
          value={searchValue}
          onChange={(e) => setSearchValue(e.target.value)}
          className="h-10 border-none"
          autoFocus
          onKeyDown={(e) => {
            if (e.key === 'Escape') {
              onCancel()
            }
          }}
        />
        <ComboboxContent>
          <ComboboxList>
            {exercises.map((exercise) => (
              <ComboboxItem key={exercise.id} value={exercise.id}>
                {exercise.name}
              </ComboboxItem>
            ))}
          </ComboboxList>
          <ComboboxEmpty>No se encontraron ejercicios</ComboboxEmpty>
        </ComboboxContent>
      </Combobox>
    </td>
  )
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| react-datasheet-grid | Custom HTML table | 2026-01 (this phase) | Full design system integration |
| External grid library | Native table + CSS | 2024+ trend | Smaller bundles, more control |
| Complex virtualization | Simple table (< 100 rows) | N/A | Our grids are small, virtualization not needed |
| tabIndex on every cell | Roving tabindex | W3C recommendation | Proper accessibility, simpler focus management |

**Deprecated/outdated:**
- react-datasheet-grid: Doesn't match design system, removed
- Heavy grid libraries (AG Grid): Overkill for our use case

## Open Questions

Things that couldn't be fully resolved:

1. **Undo/Redo for grid edits**
   - What we know: Users expect Ctrl+Z to work
   - What's unclear: How to implement without external library
   - Recommendation: Defer to future phase; backend operations are atomic and can be re-done

2. **Copy/Paste from Excel**
   - What we know: Nice-to-have feature
   - What's unclear: How much effort to support multi-cell paste
   - Recommendation: Start with single-cell paste; clipboard API is complex

3. **Mobile/Touch interaction**
   - What we know: Grid is desktop-first (coach app)
   - What's unclear: Whether touch gestures are needed
   - Recommendation: Focus on keyboard/mouse; touch is low priority for coach app

## Resolved from UI/UX Specifications

The following were clarified by the UI/UX mockup (code.html and screen.png):

1. **Color scheme**: Dark slate theme (zinc-900/950 bg, zinc-800 borders), blue primary (#3b82f6)
2. **Typography**: 13px for content, 10-11px for labels, uppercase tracking for headers
3. **Sticky column**: 320px width, shadow on scroll
4. **Week column width**: 224px (w-56 in Tailwind)
5. **Session headers**: Full-width, primary color text, uppercase with letter-spacing
6. **Superset lines**: 1.5px width, primary color at 40% opacity
7. **Cell inputs**: Centered text, transparent background, focus ring on active
8. **Footer**: Keyboard shortcut hints (Shift+Enter, S key) and Save button

## Sources

### Primary (HIGH confidence)
- **UI/UX Specifications** (`.planning/phases/03-program-builder/ui-ux-specifications/`) - Visual design reference
- [W3C WAI-ARIA Grid Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/grid/) - Keyboard navigation requirements
- [W3C Keyboard Interface Guide](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/) - Roving tabindex pattern
- [CSS-Tricks Sticky Header/Column](https://css-tricks.com/a-table-with-both-a-sticky-header-and-a-sticky-first-column/) - CSS sticky implementation
- Existing codebase: `use-grid-mutations.ts`, shadcn/ui components

### Secondary (MEDIUM confidence)
- [AG Grid Keyboard Navigation](https://www.ag-grid.com/react-data-grid/keyboard-navigation/) - Reference for keyboard patterns
- [MDN ARIA Grid Role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/grid_role) - ARIA attributes
- [TanStack Table GitHub Discussion #2752](https://github.com/TanStack/table/discussions/2752) - Custom keyboard nav patterns

### Tertiary (LOW confidence)
- [Infragistics Grid Accessibility Blog](https://www.infragistics.com/blogs/grid-keyboard-navigation-accessibility/) - General best practices

## Metadata

**Confidence breakdown:**
- Architecture: HIGH - Clear path using existing components and patterns
- Keyboard navigation: HIGH - W3C patterns are well-documented
- CSS sticky: HIGH - Browser support is universal (except IE11, which we don't support)
- Integration with mutations: HIGH - Existing hooks are well-designed
- Performance: MEDIUM - Depends on implementation, but grid is small

**Research date:** 2026-01-25
**Valid until:** 2026-02-25 (30 days - stable patterns, no external dependencies)
