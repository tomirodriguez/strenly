---
phase: 03.1-custom-program-grid
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - apps/coach-web/src/components/programs/program-grid/types.ts
  - apps/coach-web/src/components/programs/program-grid/use-grid-navigation.ts
  - apps/coach-web/src/components/programs/program-grid/use-cell-editing.ts
  - apps/coach-web/src/components/programs/program-grid/transform-program.ts
  - apps/coach-web/src/styles/program-grid.css
autonomous: true

must_haves:
  truths:
    - "Grid types define row, column, and cell structures"
    - "useGridNavigation hook handles arrow/tab/enter/escape keys"
    - "useCellEditing hook manages edit state transitions"
    - "transformProgramToGrid converts API data to grid rows"
  artifacts:
    - path: "apps/coach-web/src/components/programs/program-grid/types.ts"
      provides: "Grid type definitions"
      exports: ["GridRow", "GridColumn", "GridCell", "SupersetPosition"]
      min_lines: 40
    - path: "apps/coach-web/src/components/programs/program-grid/use-grid-navigation.ts"
      provides: "Keyboard navigation hook"
      exports: ["useGridNavigation"]
      min_lines: 80
    - path: "apps/coach-web/src/components/programs/program-grid/use-cell-editing.ts"
      provides: "Cell editing state hook"
      exports: ["useCellEditing"]
      min_lines: 40
    - path: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      provides: "Data transformation utilities"
      exports: ["transformProgramToGrid"]
      min_lines: 60
  key_links:
    - from: "use-grid-navigation.ts"
      to: "types.ts"
      via: "import"
      pattern: "import.*GridCell.*from.*types"
---

<objective>
Create grid foundation: types, hooks, and data transformation utilities

Purpose: Establish the foundation for the custom grid with reusable types and hooks that handle keyboard navigation and cell editing state.
Output: Type definitions, navigation hook, editing hook, and data transformer ready for grid components.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-custom-program-grid/03.1-RESEARCH.md
@packages/contracts/src/programs/program.ts
@apps/coach-web/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create grid type definitions</name>
  <files>apps/coach-web/src/components/programs/program-grid/types.ts</files>
  <action>
    Create type definitions for the custom grid:

    ```typescript
    import type { ProgramWeek, ProgramSession, ProgramExercise } from '@strenly/contracts/programs/program'

    // Cell position identifier
    export interface GridCell {
      rowIndex: number
      colIndex: number
      rowId: string      // exercise row ID
      colId: string      // week ID or 'exercise' for first column
    }

    // Column definition (weeks + exercise column)
    export interface GridColumn {
      id: string
      name: string
      type: 'exercise' | 'week'
      weekId?: string
    }

    // Row types
    export type GridRowType = 'session-header' | 'exercise' | 'add-exercise'

    // Superset line position for visual indicator
    export type SupersetPosition = 'start' | 'middle' | 'end' | null

    // Row data structure
    export interface GridRow {
      id: string
      type: GridRowType
      sessionId: string
      sessionName: string

      // Exercise-specific fields (only for type: 'exercise')
      exercise?: {
        exerciseId: string
        exerciseName: string
        position: number
      }

      // Superset fields
      supersetGroup: string | null
      supersetOrder: number | null
      supersetPosition: SupersetPosition

      // Split row fields
      isSubRow: boolean
      parentRowId: string | null
      setTypeLabel: string | null

      // Prescriptions indexed by weekId
      prescriptions: Record<string, string>
    }

    // Full grid data structure
    export interface GridData {
      rows: GridRow[]
      columns: GridColumn[]
    }
    ```

    Export all types.
  </action>
  <verify>TypeScript compiles, types are properly exported</verify>
  <done>Grid types defined and exported for use by other modules</done>
</task>

<task type="auto">
  <name>Task 2: Create useGridNavigation hook</name>
  <files>apps/coach-web/src/components/programs/program-grid/use-grid-navigation.ts</files>
  <action>
    Create keyboard navigation hook following W3C ARIA Grid pattern:

    ```typescript
    import { useCallback, useState } from 'react'
    import type { GridCell, GridRow, GridColumn } from './types'

    interface UseGridNavigationOptions {
      rows: GridRow[]
      columns: GridColumn[]
      onCellChange?: (cell: GridCell | null) => void
    }

    export function useGridNavigation({
      rows,
      columns,
      onCellChange,
    }: UseGridNavigationOptions) {
      const [activeCell, setActiveCell] = useState<GridCell | null>(null)

      const moveTo = useCallback((rowIndex: number, colIndex: number) => {
        // Clamp to valid range
        const validRowIndex = Math.max(0, Math.min(rows.length - 1, rowIndex))
        const validColIndex = Math.max(0, Math.min(columns.length - 1, colIndex))

        // Skip session-header rows
        let finalRowIndex = validRowIndex
        while (finalRowIndex >= 0 && finalRowIndex < rows.length && rows[finalRowIndex].type === 'session-header') {
          finalRowIndex += rowIndex > (activeCell?.rowIndex ?? 0) ? 1 : -1
        }

        if (finalRowIndex < 0 || finalRowIndex >= rows.length) return

        const newCell: GridCell = {
          rowIndex: finalRowIndex,
          colIndex: validColIndex,
          rowId: rows[finalRowIndex].id,
          colId: columns[validColIndex].id,
        }

        setActiveCell(newCell)
        onCellChange?.(newCell)
      }, [rows, columns, activeCell, onCellChange])

      const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
        if (!activeCell) return

        const { rowIndex, colIndex } = activeCell

        switch (e.key) {
          case 'ArrowUp':
            e.preventDefault()
            moveTo(rowIndex - 1, colIndex)
            break
          case 'ArrowDown':
            e.preventDefault()
            moveTo(rowIndex + 1, colIndex)
            break
          case 'ArrowLeft':
            e.preventDefault()
            moveTo(rowIndex, colIndex - 1)
            break
          case 'ArrowRight':
            e.preventDefault()
            moveTo(rowIndex, colIndex + 1)
            break
          case 'Tab':
            e.preventDefault()
            if (e.shiftKey) {
              // Move backward
              if (colIndex > 0) {
                moveTo(rowIndex, colIndex - 1)
              } else if (rowIndex > 0) {
                moveTo(rowIndex - 1, columns.length - 1)
              }
            } else {
              // Move forward
              if (colIndex < columns.length - 1) {
                moveTo(rowIndex, colIndex + 1)
              } else if (rowIndex < rows.length - 1) {
                moveTo(rowIndex + 1, 0)
              }
            }
            break
          case 'Home':
            e.preventDefault()
            if (e.ctrlKey) {
              moveTo(0, 0)
            } else {
              moveTo(rowIndex, 0)
            }
            break
          case 'End':
            e.preventDefault()
            if (e.ctrlKey) {
              moveTo(rows.length - 1, columns.length - 1)
            } else {
              moveTo(rowIndex, columns.length - 1)
            }
            break
        }
      }, [activeCell, moveTo, columns.length, rows.length])

      const setActiveCellByPosition = useCallback((rowId: string, colId: string) => {
        const rowIndex = rows.findIndex(r => r.id === rowId)
        const colIndex = columns.findIndex(c => c.id === colId)
        if (rowIndex >= 0 && colIndex >= 0) {
          const cell: GridCell = { rowIndex, colIndex, rowId, colId }
          setActiveCell(cell)
          onCellChange?.(cell)
        }
      }, [rows, columns, onCellChange])

      const clearActiveCell = useCallback(() => {
        setActiveCell(null)
        onCellChange?.(null)
      }, [onCellChange])

      return {
        activeCell,
        setActiveCell: setActiveCellByPosition,
        clearActiveCell,
        handleKeyDown,
      }
    }
    ```
  </action>
  <verify>TypeScript compiles, hook exports correctly</verify>
  <done>Navigation hook handles arrow keys, tab, home/end with session-header skipping</done>
</task>

<task type="auto">
  <name>Task 3: Create useCellEditing hook and transformProgramToGrid utility</name>
  <files>
    apps/coach-web/src/components/programs/program-grid/use-cell-editing.ts
    apps/coach-web/src/components/programs/program-grid/transform-program.ts
  </files>
  <action>
    Create useCellEditing hook:

    ```typescript
    import { useCallback, useState } from 'react'
    import type { GridCell } from './types'

    export function useCellEditing() {
      const [editingCell, setEditingCell] = useState<GridCell | null>(null)

      const startEditing = useCallback((cell: GridCell) => {
        setEditingCell(cell)
      }, [])

      const stopEditing = useCallback(() => {
        setEditingCell(null)
      }, [])

      const isEditing = useCallback((rowId: string, colId: string) => {
        return editingCell?.rowId === rowId && editingCell?.colId === colId
      }, [editingCell])

      return {
        editingCell,
        startEditing,
        stopEditing,
        isEditing,
      }
    }
    ```

    Create transformProgramToGrid utility:

    ```typescript
    import type { ProgramWithDetails } from '@strenly/contracts/programs/program'
    import type { GridData, GridRow, GridColumn, SupersetPosition } from './types'

    export function transformProgramToGrid(program: ProgramWithDetails): GridData {
      // Build columns: exercise column + week columns
      const columns: GridColumn[] = [
        { id: 'exercise', name: 'Ejercicio', type: 'exercise' },
        ...program.weeks.map(w => ({
          id: w.id,
          name: w.name,
          type: 'week' as const,
          weekId: w.id,
        })),
      ]

      // Build rows: session headers + exercise rows per session
      const rows: GridRow[] = []

      for (const session of program.sessions) {
        // Add session header row
        rows.push({
          id: `session-header-${session.id}`,
          type: 'session-header',
          sessionId: session.id,
          sessionName: session.name,
          supersetGroup: null,
          supersetOrder: null,
          supersetPosition: null,
          isSubRow: false,
          parentRowId: null,
          setTypeLabel: null,
          prescriptions: {},
        })

        // Get exercises for this session
        const sessionExercises = program.exerciseRows.filter(e => e.sessionId === session.id)

        // Calculate superset positions
        const supersetGroups = new Map<string, number[]>()
        sessionExercises.forEach((ex, idx) => {
          if (ex.supersetGroup) {
            const group = supersetGroups.get(ex.supersetGroup) ?? []
            group.push(idx)
            supersetGroups.set(ex.supersetGroup, group)
          }
        })

        // Add exercise rows
        sessionExercises.forEach((ex, idx) => {
          // Calculate superset position
          let supersetPosition: SupersetPosition = null
          if (ex.supersetGroup) {
            const groupIndices = supersetGroups.get(ex.supersetGroup) ?? []
            const posInGroup = groupIndices.indexOf(idx)
            if (groupIndices.length === 1) {
              supersetPosition = null // Single item, no line
            } else if (posInGroup === 0) {
              supersetPosition = 'start'
            } else if (posInGroup === groupIndices.length - 1) {
              supersetPosition = 'end'
            } else {
              supersetPosition = 'middle'
            }
          }

          // Build prescriptions map
          const prescriptions: Record<string, string> = {}
          for (const rx of program.prescriptions) {
            if (rx.exerciseRowId === ex.id) {
              // Format prescription as notation string
              prescriptions[rx.weekId] = rx.rawNotation ?? ''
            }
          }

          rows.push({
            id: ex.id,
            type: 'exercise',
            sessionId: session.id,
            sessionName: session.name,
            exercise: {
              exerciseId: ex.exerciseId,
              exerciseName: ex.exerciseName ?? '',
              position: ex.position,
            },
            supersetGroup: ex.supersetGroup,
            supersetOrder: ex.supersetOrder,
            supersetPosition,
            isSubRow: ex.parentRowId !== null,
            parentRowId: ex.parentRowId,
            setTypeLabel: ex.setTypeLabel,
            prescriptions,
          })
        })

        // Add "add exercise" row for this session
        rows.push({
          id: `add-exercise-${session.id}`,
          type: 'add-exercise',
          sessionId: session.id,
          sessionName: session.name,
          supersetGroup: null,
          supersetOrder: null,
          supersetPosition: null,
          isSubRow: false,
          parentRowId: null,
          setTypeLabel: null,
          prescriptions: {},
        })
      }

      return { rows, columns }
    }
    ```
  </action>
  <verify>TypeScript compiles, functions export correctly</verify>
  <done>Cell editing hook and data transformer utility complete</done>
</task>

</tasks>

<verification>
1. Run `pnpm typecheck` - no type errors
2. Run `pnpm lint` - no lint errors
3. All files exist in apps/coach-web/src/components/programs/program-grid/
4. Types are properly exported and can be imported
5. Hooks can be used in a test component without errors
</verification>

<success_criteria>
- Grid types define all necessary structures
- useGridNavigation handles keyboard navigation with session-header skipping
- useCellEditing manages editing state correctly
- transformProgramToGrid converts API data to grid format
- All modules properly export their public API
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-custom-program-grid/03.1-03-SUMMARY.md`
</output>
