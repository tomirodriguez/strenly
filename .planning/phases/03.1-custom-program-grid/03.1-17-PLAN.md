---
phase: 03.1-custom-program-grid
plan: 17
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/backend/src/use-cases/programs/toggle-superset.ts
  - packages/backend/src/use-cases/programs/reorder-exercise-rows.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When removing a row from a superset, the row is repositioned to the end of the session"
    - "Move up/down operations cannot break superset adjacency (rows in same group stay together)"
    - "Superset members are always physically adjacent in the row order"
  artifacts:
    - path: "packages/backend/src/use-cases/programs/toggle-superset.ts"
      provides: "Superset toggle with repositioning on removal"
      contains: "repositionRowToEndOfSession"
    - path: "packages/backend/src/use-cases/programs/reorder-exercise-rows.ts"
      provides: "Reorder with superset adjacency validation/repair"
      contains: "ensureSupersetAdjacency"
    - path: "packages/core/src/ports/program-repository.port.ts"
      provides: "New repository method for end-of-session repositioning"
      contains: "repositionRowToEndOfSession"
    - path: "packages/backend/src/infrastructure/repositories/program.repository.ts"
      provides: "Implementation of repositionRowToEndOfSession"
      contains: "repositionRowToEndOfSession"
  key_links:
    - from: "toggle-superset.ts (removal case)"
      to: "programRepository.repositionRowToEndOfSession"
      via: "Move row to end when removing from superset"
      pattern: "repositionRowToEndOfSession"
    - from: "reorder-exercise-rows.ts"
      to: "ensureSupersetAdjacency helper"
      via: "Validate/repair order before persisting"
      pattern: "ensureSupersetAdjacency"
---

<objective>
Fix superset row positioning when removing from superset and prevent breaking superset adjacency via move up/down.

Purpose: Two related bugs:
1. When removing a row from a superset (A1,A2,A3 -> remove A2), the row stays in place (between A1 and A3) instead of moving to the end of the session
2. Move up/down buttons can move a non-superset row into the middle of a superset group, breaking adjacency

Output: Superset groups always maintain physical adjacency in the grid.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-custom-program-grid/03.1-UAT-v4.md

# Root cause from UAT diagnosis
1. toggle-superset.ts lines 56-70: When removing from superset (supersetGroup = null), only metadata is updated, no repositioning
2. reorder-exercise-rows.ts lines 19-44: Accepts any order without validating superset adjacency

# Existing pattern for adding to superset (lines 113-124 in toggle-superset.ts):
```typescript
.andThen((updatedRow) =>
  deps.programRepository
    .repositionRowToAfterSupersetGroup(ctx, updatedRow.sessionId, updatedRow.id, targetGroup)
    ...
)
```

# Required behavior:
1. When removing from superset: Move row to end of session (after all other rows)
2. When reordering: If proposed order breaks superset adjacency, auto-repair by grouping superset members together
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add repositionRowToEndOfSession to port and repository</name>
  <skills>/repository</skills>
  <files>
packages/core/src/ports/program-repository.port.ts
packages/backend/src/infrastructure/repositories/program.repository.ts
  </files>
  <action>
Add a new repository method `repositionRowToEndOfSession` that moves a row to the end of a session (max orderIndex + 1).

1. In program-repository.port.ts, add after `repositionRowToAfterSupersetGroup`:
```typescript
/**
 * Reposition a row to the end of a session.
 * Used when removing a row from a superset to prevent it staying between group members.
 */
repositionRowToEndOfSession(
  ctx: OrganizationContext,
  sessionId: string,
  rowId: string,
): ResultAsync<void, ProgramRepositoryError>
```

2. In program.repository.ts, implement the method. The approach:
   - Get all rows in session ordered by orderIndex
   - Find current position of rowId
   - If already at end, no-op
   - Otherwise, filter out the row, append it to end, reassign orderIndex 0..N-1
  </action>
  <verify>
`pnpm typecheck` passes in packages/core and packages/backend
  </verify>
  <done>
New repository method `repositionRowToEndOfSession` available for use in toggle-superset use case.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add repositioning on superset removal</name>
  <skills>/use-case</skills>
  <files>packages/backend/src/use-cases/programs/toggle-superset.ts</files>
  <action>
Modify the removal branch (when `input.supersetGroup === null`) to reposition the row to the end of the session after clearing superset metadata.

Current code (lines 56-70):
```typescript
if (input.supersetGroup === null) {
  const updated: ProgramExerciseRow = {
    ...existing,
    supersetGroup: null,
    supersetOrder: null,
    updatedAt: new Date(),
  }

  return deps.programRepository.updateExerciseRow(ctx, updated).mapErr(...)
}
```

Change to:
```typescript
if (input.supersetGroup === null) {
  const updated: ProgramExerciseRow = {
    ...existing,
    supersetGroup: null,
    supersetOrder: null,
    updatedAt: new Date(),
  }

  return deps.programRepository
    .updateExerciseRow(ctx, updated)
    .mapErr(
      (e): ToggleSupersetError => ({
        type: 'repository_error',
        message: e.type === 'DATABASE_ERROR' ? e.message : `Entity not found: ${e.id}`,
      }),
    )
    // After clearing superset metadata, move row to end of session
    .andThen((updatedRow) =>
      deps.programRepository
        .repositionRowToEndOfSession(ctx, existing.sessionId, updatedRow.id)
        .map(() => updatedRow)
        .mapErr(
          (e): ToggleSupersetError => ({
            type: 'repository_error',
            message: e.type === 'DATABASE_ERROR' ? e.message : `Failed to reposition row: ${e.id}`,
          }),
        ),
    )
}
```
  </action>
  <verify>
1. `pnpm typecheck` passes
2. Manual test:
   - Create exercises A1, A2, A3 in superset group A
   - Remove A2 from superset
   - A2 should move to end of session (after A1, A3), becoming B1
  </verify>
  <done>
Removing a row from a superset now moves it to the end of the session, preventing it from staying between superset group members.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add superset adjacency validation to reorder</name>
  <skills>/use-case</skills>
  <files>packages/backend/src/use-cases/programs/reorder-exercise-rows.ts</files>
  <action>
Add validation/auto-repair to prevent breaking superset adjacency when reordering rows.

Strategy: Before persisting the new order, check if any superset groups are non-adjacent. If so, auto-repair by grouping superset members together while preserving the relative order of the first member of each group.

Add a helper function and modify the use case:

```typescript
import { hasPermission, type OrganizationContext, type ProgramRepositoryPort, type Role } from '@strenly/core'
import { errAsync, okAsync, type ResultAsync } from 'neverthrow'

export type ReorderExerciseRowsInput = OrganizationContext & {
  memberRole: Role
  sessionId: string
  rowIds: string[]
}

export type ReorderExerciseRowsError =
  | { type: 'forbidden'; message: string }
  | { type: 'not_found'; entityType: 'session'; id: string }
  | { type: 'repository_error'; message: string }

type Dependencies = {
  programRepository: ProgramRepositoryPort
}

/**
 * Ensures superset groups are adjacent in the row order.
 * If a superset group is split, consolidates all members after the first occurrence.
 */
function ensureSupersetAdjacency(
  rowIds: string[],
  rowMetadata: Map<string, { supersetGroup: string | null }>,
): string[] {
  // Track which rows we've placed
  const placed = new Set<string>()
  const result: string[] = []

  for (const rowId of rowIds) {
    if (placed.has(rowId)) continue

    const metadata = rowMetadata.get(rowId)
    const group = metadata?.supersetGroup

    if (group) {
      // Find all rows in this superset group and place them together
      const groupMembers = rowIds.filter((id) => {
        const m = rowMetadata.get(id)
        return m?.supersetGroup === group && !placed.has(id)
      })
      for (const member of groupMembers) {
        result.push(member)
        placed.add(member)
      }
    } else {
      // Standalone row
      result.push(rowId)
      placed.add(rowId)
    }
  }

  return result
}

export const makeReorderExerciseRows =
  (deps: Dependencies) =>
  (input: ReorderExerciseRowsInput): ResultAsync<void, ReorderExerciseRowsError> => {
    // 1. Authorization FIRST
    if (!hasPermission(input.memberRole, 'programs:write')) {
      return errAsync({
        type: 'forbidden',
        message: 'No permission to modify programs',
      })
    }

    const ctx = { organizationId: input.organizationId, userId: input.userId, memberRole: input.memberRole }

    // 2. Fetch row metadata to check superset groups
    return deps.programRepository
      .findExerciseRowsBySessionId(ctx, input.sessionId)
      .mapErr((e): ReorderExerciseRowsError => {
        if (e.type === 'NOT_FOUND' && e.entityType === 'session') {
          return { type: 'not_found', entityType: 'session', id: e.id }
        }
        return { type: 'repository_error', message: e.message }
      })
      .andThen((rows) => {
        // Build metadata map
        const rowMetadata = new Map<string, { supersetGroup: string | null }>()
        for (const row of rows) {
          rowMetadata.set(row.id, { supersetGroup: row.supersetGroup })
        }

        // Ensure superset adjacency
        const validatedOrder = ensureSupersetAdjacency(input.rowIds, rowMetadata)

        // 3. Delegate to repository
        return deps.programRepository
          .reorderExerciseRows(ctx, input.sessionId, validatedOrder)
          .mapErr((e): ReorderExerciseRowsError => {
            if (e.type === 'NOT_FOUND' && e.entityType === 'session') {
              return { type: 'not_found', entityType: 'session', id: e.id }
            }
            if (e.type === 'NOT_FOUND') {
              return { type: 'repository_error', message: `Entity not found: ${e.id}` }
            }
            return { type: 'repository_error', message: e.message }
          })
      })
  }
```

Note: This requires adding a new repository method `findExerciseRowsBySessionId`. Add it to the port and implement it.
  </action>
  <verify>
1. `pnpm typecheck` passes
2. Manual test:
   - Create A1, A2 (superset), B1 (standalone)
   - Try to move B1 between A1 and A2 via reorder
   - Order should auto-repair: A1, A2, B1 (superset members kept together)
  </verify>
  <done>
Reorder operation validates and auto-repairs superset adjacency, preventing non-superset rows from being placed between superset group members.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add findExerciseRowsBySessionId to port and repository</name>
  <skills>/repository</skills>
  <files>
packages/core/src/ports/program-repository.port.ts
packages/backend/src/infrastructure/repositories/program.repository.ts
  </files>
  <action>
Add a new repository method `findExerciseRowsBySessionId` that returns all exercise rows for a session.

1. In program-repository.port.ts, add:
```typescript
/**
 * Find all exercise rows for a session.
 * Used for validating reorder operations.
 */
findExerciseRowsBySessionId(
  ctx: OrganizationContext,
  sessionId: string,
): ResultAsync<ProgramExerciseRow[], ProgramRepositoryError>
```

2. In program.repository.ts, implement:
```typescript
findExerciseRowsBySessionId(
  ctx: OrganizationContext,
  sessionId: string,
): ResultAsync<ProgramExerciseRow[], ProgramRepositoryError> {
  return RA.fromPromise(
    (async (): Promise<{ ok: true; data: ProgramExerciseRow[] } | { ok: false; error: ProgramRepositoryError }> => {
      const existingSession = await verifySessionAccess(ctx, sessionId)
      if (!existingSession) {
        return { ok: false, error: notFoundError('session', sessionId) }
      }

      const rows = await db
        .select()
        .from(programExercises)
        .where(eq(programExercises.sessionId, sessionId))
        .orderBy(asc(programExercises.orderIndex))

      return { ok: true, data: rows.map(mapExerciseRowToDomain) }
    })(),
    wrapDbError,
  ).andThen((result) => {
    if (!result.ok) {
      return err(result.error)
    }
    return ok(result.data)
  })
}
```
  </action>
  <verify>
`pnpm typecheck` passes
  </verify>
  <done>
Repository method `findExerciseRowsBySessionId` implemented and available for use in reorder-exercise-rows use case.
  </done>
</task>

</tasks>

<verification>
Test 1 - Superset removal repositioning:
1. Create program with 3 exercises in session
2. Put all 3 in superset group A (A1, A2, A3)
3. Remove A2 from superset
4. Verify: A2 moves to end, display shows A1, A2 (remaining superset), B1 (the removed row)

Test 2 - Move up/down respects superset boundaries:
1. Create program with A1, A2 (superset), B1 (standalone)
2. Try to move B1 up (which would place it between A1 and A2)
3. Verify: B1 cannot break into the superset - it either stays below or goes above both A1 and A2

Full validation:
- `pnpm typecheck` - all packages pass
- `pnpm lint` - no errors
</verification>

<success_criteria>
- [ ] repositionRowToEndOfSession method added to port
- [ ] repositionRowToEndOfSession implemented in repository
- [ ] findExerciseRowsBySessionId method added to port
- [ ] findExerciseRowsBySessionId implemented in repository
- [ ] toggle-superset calls repositionRowToEndOfSession on removal
- [ ] reorder-exercise-rows validates/repairs superset adjacency
- [ ] TypeScript compiles without errors
- [ ] Biome lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-custom-program-grid/03.1-17-SUMMARY.md`
</output>
