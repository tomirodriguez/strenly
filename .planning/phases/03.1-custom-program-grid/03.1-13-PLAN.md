---
phase: 03.1-custom-program-grid
plan: 13
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/coach-web/src/components/programs/program-grid/transform-program.ts
  - packages/backend/src/use-cases/programs/toggle-superset.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Creating a superset moves the row adjacent to existing group members"
    - "Adding to existing superset assigns next sequential order (A1 -> A2 -> A3)"
    - "Reordering rows within a superset updates the visual order numbers"
    - "Blue superset indicator connects all members of a group"
  artifacts:
    - path: "apps/coach-web/src/components/programs/program-grid/transform-program.ts"
      provides: "Dynamic supersetOrder calculation based on physical position"
      contains: "supersetOrder"
    - path: "packages/backend/src/use-cases/programs/toggle-superset.ts"
      provides: "Row repositioning when joining superset"
      contains: "reposition"
  key_links:
    - from: "transform-program.ts"
      to: "GridRow"
      via: "supersetOrder calculation"
      pattern: "supersetOrder.*=.*\\d+"
---

<objective>
Fix superset grouping to physically reposition rows and calculate correct order numbers dynamically.

Purpose: UAT Tests 3 & 4 revealed critical issues:
1. Creating a superset only "tags" rows, doesn't move them to be adjacent
2. Reordering exercises in a superset keeps stale order numbers (A1, A3, A2 scenarios)

Output: Supersets work as expected - joining a group moves the row adjacent to group members, and order numbers are calculated from physical position, not stored values.
</objective>

<execution_context>
@/Users/tomiardz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomiardz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@apps/coach-web/src/components/programs/program-grid/transform-program.ts
@packages/backend/src/use-cases/programs/toggle-superset.ts
@packages/backend/src/infrastructure/repositories/program.repository.ts
@packages/core/src/ports/program-repository.port.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Calculate supersetOrder dynamically in transform-program.ts</name>
  <skills>/frontend-design</skills>
  <files>apps/coach-web/src/components/programs/program-grid/transform-program.ts</files>
  <action>
Modify transform-program.ts to calculate supersetOrder dynamically based on physical row position rather than using the stored database value.

**Current problem:**
- `supersetOrder` is stored in the database and set when a row joins a superset
- When rows are reordered, the stored supersetOrder becomes stale
- Result: A1 at position 3, A3 at position 1, A2 at position 2

**Solution:**
Calculate supersetOrder during transform based on physical order within each group.

**Implementation:**

In the flatRows processing section (around line 155-165), after building the superset groups map:

```typescript
// After building supersetGroups Map<string, number[]>

// Calculate dynamic supersetOrder based on physical position within each group
const dynamicSupersetOrder = new Map<number, number>() // flatRowIndex -> order

for (const [group, indices] of supersetGroups) {
  // indices are already in physical order (since we iterated flatRows in order)
  indices.forEach((idx, orderInGroup) => {
    dynamicSupersetOrder.set(idx, orderInGroup + 1) // 1-based: A1, A2, A3
  })
}

// Then in the flatRows.forEach where we build GridRows:
flatRows.forEach((row, idx) => {
  // Calculate superset position (existing code)
  let supersetPosition: SupersetPosition = null
  // ... existing supersetPosition logic ...

  // Use dynamic supersetOrder instead of stored value
  const calculatedSupersetOrder = row.supersetGroup
    ? dynamicSupersetOrder.get(idx) ?? null
    : null

  rows.push({
    id: row.id,
    type: 'exercise',
    sessionId: session.id,
    sessionName: session.name,
    exercise: { ... },
    supersetGroup: row.supersetGroup,
    supersetOrder: calculatedSupersetOrder,  // Use calculated, not row.supersetOrder
    supersetPosition,
    // ... rest of properties
  })
})
```

**Key changes:**
1. Build a map from row index to calculated order (1, 2, 3) based on physical position
2. Use this calculated order instead of `row.supersetOrder` from the API
3. Physical order is already correct because we sorted by orderIndex earlier

This makes supersetOrder purely visual - always reflecting current physical position.
  </action>
  <verify>
1. Create exercises A, B, C in a session
2. Add A and B to superset group A (becomes A1, A2)
3. Drag A2 above A1
4. Order should update to show A1 (originally B) and A2 (originally A)
5. Run: `pnpm typecheck`
  </verify>
  <done>
supersetOrder is calculated dynamically from physical position. Reordering rows within a superset correctly updates their visual order numbers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Reposition row when adding to superset</name>
  <skills>/use-case, /repository</skills>
  <files>
    packages/backend/src/use-cases/programs/toggle-superset.ts
    packages/backend/src/infrastructure/repositories/program.repository.ts
    packages/core/src/ports/program-repository.port.ts
  </files>
  <action>
Modify toggle-superset.ts to physically reposition a row when it joins a superset, placing it adjacent to existing group members.

**Current problem:**
- toggle-superset only updates metadata (supersetGroup, supersetOrder)
- Row stays in its original position
- Result: Superset members scattered throughout session, not adjacent

**Solution:**
When adding to a superset, reorder so the row is placed immediately after the last member of the target group.

**Implementation in toggle-superset.ts:**

After setting the new supersetGroup/supersetOrder, call a reposition operation:

```typescript
// In the andThen chain after updating the row's superset metadata:

.andThen((updatedRow) => {
  // After updating metadata, reposition the row to be adjacent to group
  return deps.programRepository
    .repositionRowToAfterSupersetGroup(ctx, updatedRow.sessionId, updatedRow.id, input.supersetGroup)
    .map(() => updatedRow)
    .mapErr((e): ToggleSupersetError => ({
      type: 'repository_error',
      message: e.type === 'DATABASE_ERROR' ? e.message : `Failed to reposition: ${e.id}`,
    }))
})
```

**Add to ProgramRepositoryPort:**

```typescript
repositionRowToAfterSupersetGroup(
  ctx: OrganizationContext,
  sessionId: string,
  rowId: string,
  supersetGroup: string,
): ResultAsync<void, ProgramRepositoryError>
```

**Implement in program.repository.ts:**

```typescript
repositionRowToAfterSupersetGroup(
  ctx: OrganizationContext,
  sessionId: string,
  rowId: string,
  supersetGroup: string,
): ResultAsync<void, ProgramRepositoryError> {
  return RA.fromPromise(
    (async (): Promise<{ ok: true } | { ok: false; error: ProgramRepositoryError }> => {
      // 1. Get all rows in session ordered by orderIndex
      const sessionRows = await db
        .select({ id: programExercises.id, orderIndex: programExercises.orderIndex, supersetGroup: programExercises.supersetGroup })
        .from(programExercises)
        .where(eq(programExercises.sessionId, sessionId))
        .orderBy(programExercises.orderIndex)

      // 2. Find the last row in the target superset group (excluding the row being moved)
      let lastGroupIndex = -1
      for (let i = 0; i < sessionRows.length; i++) {
        const row = sessionRows[i]
        if (row && row.supersetGroup === supersetGroup && row.id !== rowId) {
          lastGroupIndex = i
        }
      }

      // 3. If no other members in group, no repositioning needed
      if (lastGroupIndex === -1) {
        return { ok: true }
      }

      // 4. Build new order: remove the row, insert it after lastGroupIndex
      const currentIndex = sessionRows.findIndex(r => r.id === rowId)
      if (currentIndex === -1) {
        return { ok: true } // Row not found, nothing to do
      }

      // If already in position (right after last group member), no change needed
      if (currentIndex === lastGroupIndex + 1) {
        return { ok: true }
      }

      // Create new order array
      const newOrder = sessionRows.filter(r => r.id !== rowId)
      // Insert after the last group member
      const insertPosition = lastGroupIndex < currentIndex ? lastGroupIndex + 1 : lastGroupIndex
      newOrder.splice(insertPosition, 0, sessionRows[currentIndex]!)

      // 5. Update all orderIndex values
      await db.transaction(async (tx) => {
        for (let i = 0; i < newOrder.length; i++) {
          const row = newOrder[i]
          if (row) {
            await tx
              .update(programExercises)
              .set({ orderIndex: i, updatedAt: new Date() })
              .where(eq(programExercises.id, row.id))
          }
        }
      })

      return { ok: true }
    })(),
    wrapDbError,
  ).andThen((result) => {
    if (!result.ok) {
      return err(result.error)
    }
    return ok(undefined)
  })
}
```

**Important:** Only reposition when ADDING to a superset (input.supersetGroup !== null). When removing (null), don't reposition.
  </action>
  <verify>
1. Create exercises A, B, C, D in a session (in that order)
2. Add A to superset group "A" -> A is now A1
3. Select D (at position 4) and add to superset group "A"
4. D should physically move to position 2 (right after A) and become A2
5. Grid should now show: A1, A2 (was D), B, C
6. Run: `pnpm typecheck && pnpm lint`
  </verify>
  <done>
When adding a row to a superset, it is physically repositioned to be adjacent to existing group members. The row moves to immediately after the last member of the target superset group.
  </done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles: `pnpm typecheck`
- [ ] Lint passes: `pnpm lint`
- [ ] Manual test: Creating superset with distant rows moves them adjacent
- [ ] Manual test: Adding to existing superset places row right after group
- [ ] Manual test: Reordering rows in superset updates order numbers correctly
- [ ] Manual test: Blue superset indicator connects all adjacent group members
</verification>

<success_criteria>
1. When adding a row to superset, it physically moves next to existing group members
2. SupersetOrder (A1, A2, A3) reflects physical position, not stored value
3. Reordering rows within a superset updates their display order
4. Blue superset indicator line connects all members correctly
5. Menu shows existing groups to join and option to create new group
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-custom-program-grid/03.1-13-SUMMARY.md`
</output>
